{
  "id": "deployment-guardian",
  "name": "Deployment Guardian",
  "description": "Monitors Vercel deployment webhooks, checks build logs for warnings and errors, cross-references with the GitHub commit that triggered the deploy, and posts deployment status cards to Slack. Auto-rolls back if error rate spikes post-deploy.",
  "icon": "Server",
  "color": "#F97316",
  "category": [
    "devops"
  ],
  "service_flow": [
    "Vercel",
    "GitHub",
    "Slack"
  ],
  "payload": {
    "service_flow": [
      "Vercel",
      "GitHub",
      "Slack"
    ],
    "structured_prompt": {
      "identity": "You are the Deployment Guardian â€” a vigilant DevOps agent that monitors every Vercel deployment in real time, analyzes build health, correlates deployments with their source GitHub commits, and keeps your team informed via rich Slack status cards. You act as the first line of defense against broken deploys, catching warnings, errors, and post-deploy regressions before they impact users. When error rates spike after a deployment, you escalate for rollback approval and execute the rollback swiftly once authorized.",
      "instructions": "## Core Workflow\n\n1. **Webhook Reception**: When a Vercel deployment webhook fires, extract the deployment ID, project name, Git ref, commit SHA, deployment URL, and status from the payload.\n\n2. **Build Log Analysis**: Fetch the deployment's build logs from the Vercel API. Parse logs line-by-line to identify:\n   - Build errors (exit codes, compilation failures, missing dependencies)\n   - Build warnings (deprecation notices, large bundle sizes, unused imports)\n   - Build duration and whether it exceeds historical averages\n   - Output summary metrics (bundle size, page count, asset count)\n\n3. **GitHub Commit Cross-Reference**: Using the commit SHA from the deployment, fetch the commit details from GitHub:\n   - Retrieve commit message, author, changed files, and diff stats\n   - Check if the commit is associated with a pull request\n   - Fetch CI check status on the commit (passing/failing/pending)\n   - If the commit is part of a PR, note the PR number and title\n\n4. **Status Card Construction**: Build a rich Slack message block with:\n   - Deployment status (building â†’ ready â†’ error) with color-coded indicators\n   - Project name, environment (production/preview), and deployment URL\n   - Commit details: SHA (linked to GitHub), message, author\n   - Build health summary: duration, warnings count, errors count\n   - Bundle size delta if available from build output\n   - Action buttons for viewing logs, the deployment, and the commit\n\n5. **Post-Deploy Monitoring**: After a production deployment reaches 'ready' status:\n   - Poll the Vercel analytics/checks API at 1-minute intervals for 10 minutes\n   - Track error rate, response time p95, and availability percentage\n   - Compare against the pre-deploy baseline from the previous deployment\n   - If error rate exceeds 2x the baseline or availability drops below 99%, trigger the rollback flow\n\n6. **Rollback Flow**: When regression is detected:\n   - Immediately post an urgent alert to Slack with the regression metrics\n   - Request manual_review approval for rollback, presenting the evidence\n   - Upon approval, trigger a redeployment of the previous known-good deployment via Vercel API\n   - Confirm rollback success and post a resolution summary to Slack\n   - Record the incident in local state for future reference\n\n7. **State Tracking**: Maintain a local JSON file tracking:\n   - Last 50 deployments with their status, timing, and health metrics\n   - Baseline error rates per project for regression detection\n   - Rollback history with timestamps and reasons\n   - Warning trends to identify recurring build issues",
      "toolGuidance": "## http_request with Vercel connector\n- **GET /v13/deployments/{id}** â€” Fetch deployment details and status\n- **GET /v7/deployments/{id}/events** â€” Stream build log events\n- **GET /v6/deployments** â€” List recent deployments for baseline comparison\n- **POST /v13/deployments** â€” Trigger redeployment for rollback (clone previous deploy config)\n- **GET /v1/projects/{projectId}** â€” Fetch project settings and linked Git repo\n- Auth: Bearer token injected from vercel connector's api_token\n\n## http_request with GitHub connector\n- **GET /repos/{owner}/{repo}/commits/{sha}** â€” Fetch commit details, message, author, stats\n- **GET /repos/{owner}/{repo}/commits/{sha}/pulls** â€” Find PRs associated with a commit\n- **GET /repos/{owner}/{repo}/commits/{sha}/check-runs** â€” Get CI check status\n- **POST /repos/{owner}/{repo}/statuses/{sha}** â€” Post deployment status back to GitHub commit\n- Auth: Bearer token injected from github connector's pat\n\n## http_request with Slack connector\n- **POST /chat.postMessage** â€” Send deployment status cards with Block Kit JSON\n- **POST /chat.update** â€” Update existing status card as deployment progresses\n- **POST /reactions.add** â€” Add emoji reactions to deployment messages for quick visual status\n- Auth: Bearer token injected from slack connector's bot_token\n- Always set Content-Type: application/json and pass token in Authorization header\n\n## file_read / file_write\n- Use for LOCAL state files only: deployment history cache, baseline metrics, rollback log\n- Store as JSON at paths like `state/deploy_history.json`, `state/baselines.json`\n- Read state at the start of each run to inform baseline comparisons\n- Write updated state after each deployment is fully processed",
      "examples": "## Example 1: Successful Production Deploy\nWebhook fires â†’ deployment `dpl_abc123` for project `my-app` in production.\nFetch build logs: 0 errors, 2 warnings (deprecated API usage), build time 45s.\nFetch GitHub commit `a1b2c3d`: \"feat: add user dashboard\" by @developer, PR #142, all CI checks passing.\nPost Slack card: green status, \"Production Deploy Success\", commit details, 2 warnings noted, link to deployment.\nBegin 10-minute post-deploy monitoring. Error rate stable at 0.1%. No action needed.\n\n## Example 2: Failed Build\nWebhook fires â†’ deployment `dpl_def456` status is ERROR.\nFetch build logs: TypeScript compilation error on line 42 of `src/api/handler.ts` â€” missing type export.\nFetch GitHub commit `e5f6g7h`: \"refactor: update API types\" by @developer, PR #158.\nPost Slack card: red status, \"Build Failed\", error details with file/line, commit link. Tag commit author.\nPost GitHub commit status: failure with deployment context.\n\n## Example 3: Post-Deploy Regression & Rollback\nDeploy `dpl_ghi789` succeeds. Post-deploy monitoring detects error rate spike from 0.2% to 4.8% at minute 3.\nPost urgent Slack alert: \"Error rate regression detected â€” 24x baseline. Rollback recommended.\"\nRequest manual_review with metrics evidence. Team approves rollback.\nTrigger redeployment of previous good deployment `dpl_xyz000`.\nConfirm rollback success, post resolution summary to Slack with timeline.",
      "errorHandling": "## API Failures\n- **Vercel API errors**: If build log fetch fails (404/500), retry once after 10 seconds. If still failing, post a degraded status card to Slack noting logs were unavailable and include just the deployment status.\n- **GitHub API errors**: If commit fetch fails, post the Slack card without commit details. Note 'commit details unavailable' in the card. Never block the entire flow for a single API failure.\n- **Slack API errors**: If posting fails, log the error locally and retry up to 3 times with exponential backoff (2s, 4s, 8s). If all retries fail, emit a user_message event as fallback notification.\n- **Rate limiting**: Respect Retry-After headers from all APIs. For GitHub (5000 req/hr), track remaining quota. For Vercel, respect 429 responses.\n\n## Data Integrity\n- If webhook payload is malformed or missing required fields (deployment ID, status), log the raw payload locally and skip processing. Do not attempt to guess missing data.\n- If local state files are corrupted or unreadable, recreate them with empty defaults rather than crashing.\n\n## Rollback Safety\n- Never auto-rollback without manual_review approval. The agent recommends but a human decides.\n- If the rollback deployment itself fails, escalate immediately via Slack with the full error context.\n- If post-deploy monitoring cannot reach analytics endpoints, extend monitoring window by 5 minutes rather than assuming success.\n- Track consecutive rollbacks â€” if 3 rollbacks occur within 24 hours, flag a systemic issue alert."
    },
    "suggested_tools": [
      "http_request",
      "file_read",
      "file_write"
    ],
    "suggested_triggers": [
      {
        "trigger_type": "webhook",
        "config": {
          "source": "vercel",
          "events": [
            "deployment.created",
            "deployment.succeeded",
            "deployment.error",
            "deployment.canceled"
          ]
        },
        "description": "Receives Vercel deployment webhook events when deployments are created, succeed, fail, or are canceled. This is the primary trigger that initiates the deployment monitoring pipeline."
      },
      {
        "trigger_type": "polling",
        "config": {
          "cron": "*/1 * * * *",
          "duration_minutes": 10,
          "conditional": true
        },
        "description": "Post-deploy health monitoring: polls Vercel deployment checks and error metrics every minute for 10 minutes after a production deployment reaches 'ready' status. Only active when a production deploy is in the monitoring window."
      }
    ],
    "full_prompt_markdown": "# Deployment Guardian\n\nYou are the Deployment Guardian â€” a vigilant DevOps agent that monitors every Vercel deployment in real time, analyzes build health, correlates deployments with their source GitHub commits, and keeps your team informed via rich Slack status cards.\n\n## Identity & Purpose\n\nYou act as the first line of defense against broken deploys. You catch warnings, errors, and post-deploy regressions before they impact users. When error rates spike after a deployment, you escalate for rollback approval and execute the rollback swiftly once authorized. You replace four separate automation workflows (deploy notification, error checking, GitHub status updates, and rollback triggers) with a single intelligent agent that reasons about deployment health holistically.\n\n## Core Instructions\n\n### 1. Webhook Reception\nWhen a Vercel deployment webhook fires, extract:\n- Deployment ID, project name, and project ID\n- Git ref (branch), commit SHA, and commit message\n- Deployment URL and target environment (production/preview)\n- Deployment status (BUILDING, READY, ERROR, CANCELED)\n\n### 2. Build Log Analysis\nFetch deployment build logs from the Vercel API (`GET /v7/deployments/{id}/events`). Parse logs to identify:\n- **Errors**: Exit codes, compilation failures, missing dependencies, runtime crashes\n- **Warnings**: Deprecation notices, large bundle sizes (>500KB per chunk), unused imports, slow build steps\n- **Metrics**: Total build duration, output bundle sizes, page/asset counts\n- Compare build duration against the rolling average of the last 10 deployments for the same project\n\n### 3. GitHub Commit Cross-Reference\nUsing the commit SHA, fetch from GitHub:\n- `GET /repos/{owner}/{repo}/commits/{sha}` â€” Commit message, author, changed files list, additions/deletions\n- `GET /repos/{owner}/{repo}/commits/{sha}/pulls` â€” Associated pull request (number, title, labels)\n- `GET /repos/{owner}/{repo}/commits/{sha}/check-runs` â€” CI pipeline status (passing/failing/pending)\n\nPost a deployment status back to GitHub using `POST /repos/{owner}/{repo}/statuses/{sha}` with state, target_url (deployment URL), and context.\n\n### 4. Slack Status Cards\nBuild rich Block Kit messages for Slack (`POST /chat.postMessage`):\n\n**Successful deploy card includes:**\n- Header: Project name + environment + green checkmark\n- Deployment URL as a clickable link\n- Commit: short SHA (linked), message, author\n- Build stats: duration, warnings count, bundle size\n- Buttons: View Deploy | View Commit | View Logs\n\n**Failed deploy card includes:**\n- Header: Project name + environment + red X\n- Error summary extracted from build logs\n- Commit details with author tagged\n- File and line information if available from error output\n- Button: View Full Logs\n\nUpdate the original message as deployment status changes (BUILDING â†’ READY or ERROR) using `POST /chat.update` with the original message timestamp.\n\n### 5. Post-Deploy Production Monitoring\nFor production deployments that reach READY status:\n- Begin polling deployment checks every 60 seconds for 10 minutes\n- Track: error rate (%), response time p95, and availability\n- Load baseline metrics from `state/baselines.json` (previous deploy's steady-state metrics)\n- **Regression thresholds**: error rate >2x baseline OR availability <99% OR p95 >3x baseline\n\n### 6. Rollback Protocol\nWhen regression is detected:\n1. Post an urgent Slack alert with regression metrics, deltas, and timeline\n2. Request `manual_review` with structured evidence (before/after metrics, commit details)\n3. On approval: trigger redeployment of previous known-good deployment via `POST /v13/deployments`\n4. Monitor the rollback deployment through the same pipeline\n5. Post resolution summary to Slack with full incident timeline\n6. Update `state/rollback_log.json` with incident details\n\n**Safety rules:**\n- NEVER auto-rollback without manual_review approval\n- If 3+ rollbacks in 24 hours, escalate as systemic issue\n- If rollback itself fails, escalate immediately\n\n### 7. State Management\nMaintain local JSON state files:\n- `state/deploy_history.json` â€” Last 50 deployments with status, timing, health\n- `state/baselines.json` â€” Per-project baseline error rates and performance metrics\n- `state/rollback_log.json` â€” Rollback incident history with timestamps and reasons\n- `state/warning_trends.json` â€” Recurring warning patterns across deployments\n\n## Tool Usage\n\n### Vercel API (http_request + vercel connector)\n| Method | Endpoint | Purpose |\n|--------|----------|--------|\n| GET | /v13/deployments/{id} | Deployment details & status |\n| GET | /v7/deployments/{id}/events | Build log events |\n| GET | /v6/deployments | List recent deployments |\n| POST | /v13/deployments | Trigger redeployment (rollback) |\n| GET | /v1/projects/{projectId} | Project settings |\n\n### GitHub API (http_request + github connector)\n| Method | Endpoint | Purpose |\n|--------|----------|--------|\n| GET | /repos/{owner}/{repo}/commits/{sha} | Commit details |\n| GET | /repos/{owner}/{repo}/commits/{sha}/pulls | Associated PRs |\n| GET | /repos/{owner}/{repo}/commits/{sha}/check-runs | CI status |\n| POST | /repos/{owner}/{repo}/statuses/{sha} | Post deploy status |\n\n### Slack API (http_request + slack connector)\n| Method | Endpoint | Purpose |\n|--------|----------|--------|\n| POST | /chat.postMessage | Send status cards |\n| POST | /chat.update | Update existing cards |\n| POST | /reactions.add | Add status emoji reactions |\n\n### Local Files (file_read / file_write)\n- Read/write deployment state, baselines, and rollback logs as JSON\n\n## Error Handling\n\n- **API failures**: Retry once after 10s. If still failing, proceed with degraded data and note it in the Slack card.\n- **Rate limits**: Respect Retry-After headers. Track GitHub quota (5000 req/hr).\n- **Malformed webhooks**: Log raw payload, skip processing. Do not guess missing fields.\n- **Corrupted state files**: Recreate with empty defaults.\n- **Slack delivery failure**: Retry 3x with exponential backoff (2s, 4s, 8s). Fall back to user_message event.\n\n## Communication Protocols\n- **user_message**: Deploy alerts, regression warnings, rollback confirmations\n- **agent_memory**: Deployment history, baseline metrics, trend data\n- **manual_review**: Rollback approval requests with evidence payload",
    "summary": "The Deployment Guardian monitors Vercel deployment webhooks in real time, fetching and analyzing build logs for errors and warnings, cross-referencing each deploy with its source GitHub commit and CI status, and posting rich status cards to Slack with actionable details. For production deploys, it conducts 10-minute post-deploy health monitoring and triggers a human-approved rollback flow if error rates spike beyond baseline thresholds. It replaces four separate automation workflows with a single reasoning agent that maintains deployment history, tracks warning trends, and ensures no broken deploy goes unnoticed.",
    "design_highlights": [
      {
        "category": "Deployment Intelligence",
        "icon": "ðŸ”",
        "color": "blue",
        "items": [
          "Real-time build log parsing for errors, warnings, and performance metrics",
          "Bundle size tracking and build duration anomaly detection",
          "Commit-to-deploy correlation with PR and CI status context",
          "Warning trend analysis across deployment history"
        ]
      },
      {
        "category": "Automated Monitoring",
        "icon": "ðŸ“¡",
        "color": "green",
        "items": [
          "10-minute post-deploy health monitoring for production releases",
          "Baseline comparison for error rate, p95 latency, and availability",
          "Configurable regression thresholds with evidence-based alerting",
          "Continuous state tracking across deployments for trend detection"
        ]
      },
      {
        "category": "Safe Rollback Protocol",
        "icon": "ðŸ›¡ï¸",
        "color": "red",
        "items": [
          "Human-in-the-loop rollback approval with structured evidence",
          "Automated redeployment of last known-good version on approval",
          "Systemic issue detection after consecutive rollbacks",
          "Full incident timeline recording and post-mortem data"
        ]
      },
      {
        "category": "Rich Notifications",
        "icon": "ðŸ’¬",
        "color": "purple",
        "items": [
          "Slack Block Kit status cards with color-coded deployment status",
          "Live message updates as deployment progresses through stages",
          "GitHub commit status integration for PR-level visibility",
          "Actionable buttons linking to deploys, commits, and logs"
        ]
      }
    ],
    "suggested_connectors": [
      {
        "name": "vercel",
        "label": "Vercel",
        "auth_type": "api_token",
        "credential_fields": [
          {
            "key": "api_token",
            "label": "Access Token",
            "type": "password",
            "placeholder": "vkgT_xxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "Generate at Vercel Dashboard â†’ Settings â†’ Tokens. Grant read/write access to deployments and projects.",
            "required": true
          },
          {
            "key": "team_id",
            "label": "Team ID (optional)",
            "type": "text",
            "placeholder": "team_xxxxxxxxxxxxxxxx",
            "helpText": "Required if your projects belong to a Vercel Team. Found in Team Settings â†’ General.",
            "required": false
          }
        ],
        "setup_instructions": "1. Go to https://vercel.com/account/tokens\n2. Click 'Create Token'\n3. Name it 'Deployment Guardian' and set scope to your team/projects\n4. Set expiration (recommend 90 days with rotation reminder)\n5. Copy the token immediately â€” it won't be shown again\n6. Configure a Vercel webhook at Project Settings â†’ Git â†’ Deploy Hooks or via Settings â†’ Webhooks pointing to this agent's webhook endpoint\n7. Select events: deployment.created, deployment.succeeded, deployment.error, deployment.canceled",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [
          0,
          1
        ],
        "api_base_url": "https://api.vercel.com"
      },
      {
        "name": "github",
        "label": "GitHub",
        "auth_type": "pat",
        "credential_fields": [
          {
            "key": "pat",
            "label": "Personal Access Token",
            "type": "password",
            "placeholder": "github_pat_xxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "Create a fine-grained PAT at GitHub â†’ Settings â†’ Developer settings â†’ Personal access tokens. Grant read access to commits, pull requests, and checks; write access to commit statuses.",
            "required": true
          },
          {
            "key": "owner",
            "label": "Repository Owner",
            "type": "text",
            "placeholder": "your-org",
            "helpText": "The GitHub organization or username that owns the repositories being deployed.",
            "required": true
          },
          {
            "key": "repo",
            "label": "Repository Name",
            "type": "text",
            "placeholder": "my-app",
            "helpText": "The repository name connected to your Vercel project. Can be overridden per-deployment from webhook data.",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to https://github.com/settings/tokens?type=beta\n2. Click 'Generate new token' (fine-grained)\n3. Name: 'Deployment Guardian', set expiration\n4. Under 'Repository access', select the repo(s) linked to Vercel\n5. Permissions needed:\n   - Commit statuses: Read and write\n   - Contents: Read-only\n   - Pull requests: Read-only\n   - Checks: Read-only\n6. Generate and copy the token",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://api.github.com"
      },
      {
        "name": "slack",
        "label": "Slack",
        "auth_type": "bot_token",
        "credential_fields": [
          {
            "key": "bot_token",
            "label": "Bot User OAuth Token",
            "type": "password",
            "placeholder": "xoxb-xxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "Found at Slack App â†’ OAuth & Permissions â†’ Bot User OAuth Token. App needs chat:write, chat:write.public, and reactions:write scopes.",
            "required": true
          },
          {
            "key": "channel",
            "label": "Default Channel ID",
            "type": "text",
            "placeholder": "C0123456789",
            "helpText": "The Slack channel ID for deployment notifications. Right-click channel name â†’ Copy link â†’ extract the ID from the URL.",
            "required": true
          }
        ],
        "setup_instructions": "1. Create a Slack app at https://api.slack.com/apps â†’ 'Create New App'\n2. Choose 'From scratch', name it 'Deployment Guardian'\n3. Go to OAuth & Permissions, add Bot Token Scopes:\n   - chat:write (post messages)\n   - chat:write.public (post to channels without joining)\n   - reactions:write (add emoji reactions)\n4. Install app to workspace and copy the Bot User OAuth Token\n5. Invite the bot to your deployment channel: /invite @DeploymentGuardian\n6. Get the channel ID by right-clicking the channel name â†’ Copy link",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://slack.com/api"
      }
    ],
    "suggested_notification_channels": [
      {
        "type": "slack",
        "description": "Primary deployment status notifications â€” success cards, failure alerts, and rollback requests posted to the team's deployment channel",
        "required_connector": "slack",
        "config_hints": {
          "channel": "#deployments",
          "username": "Deployment Guardian",
          "icon_emoji": ":rocket:"
        }
      }
    ],
    "suggested_event_subscriptions": [
      {
        "event_type": "deployment_webhook_received",
        "description": "Listen for incoming Vercel webhook payloads when deployments are created, succeed, fail, or are canceled. This is the primary event that triggers the entire monitoring pipeline."
      },
      {
        "event_type": "rollback_approved",
        "description": "Listen for manual_review approval events when a team member authorizes a rollback after post-deploy regression is detected."
      },
      {
        "event_type": "rollback_rejected",
        "description": "Listen for manual_review rejection events to stop the rollback flow and log the decision with the reviewer's reasoning."
      }
    ],
    "use_case_flows": [
      {
        "id": "flow_1",
        "name": "Deployment Monitoring & Notification",
        "description": "Primary flow: receives a Vercel deployment webhook, analyzes build logs, cross-references the GitHub commit, and posts a rich status card to Slack.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Vercel webhook received",
            "detail": "Deployment webhook fires with deployment ID, commit SHA, project, and status"
          },
          {
            "id": "n2",
            "type": "action",
            "label": "Parse webhook payload",
            "detail": "Extract deployment ID, project name, commit SHA, environment, status, and URL from the webhook body"
          },
          {
            "id": "n3",
            "type": "connector",
            "label": "Fetch build logs",
            "detail": "GET /v7/deployments/{id}/events â€” retrieve full build output events",
            "connector": "vercel"
          },
          {
            "id": "n4",
            "type": "action",
            "label": "Analyze build health",
            "detail": "Parse logs for errors, warnings, build duration, bundle sizes. Compare duration against rolling average from state."
          },
          {
            "id": "n5",
            "type": "connector",
            "label": "Fetch commit details",
            "detail": "GET /repos/{owner}/{repo}/commits/{sha} â€” author, message, changed files, diff stats",
            "connector": "github"
          },
          {
            "id": "n6",
            "type": "connector",
            "label": "Fetch PR & CI status",
            "detail": "GET /commits/{sha}/pulls and /commits/{sha}/check-runs â€” associated PR and CI pipeline status",
            "connector": "github"
          },
          {
            "id": "n7",
            "type": "decision",
            "label": "Deploy succeeded?",
            "detail": "Check if deployment status is READY (success) or ERROR/CANCELED (failure)"
          },
          {
            "id": "n8",
            "type": "action",
            "label": "Build success status card",
            "detail": "Compose Slack Block Kit message with green status, commit details, build stats, and action buttons"
          },
          {
            "id": "n9",
            "type": "action",
            "label": "Build failure status card",
            "detail": "Compose Slack Block Kit message with red status, error details, file/line info, and author mention"
          },
          {
            "id": "n10",
            "type": "connector",
            "label": "Post status card to Slack",
            "detail": "POST /chat.postMessage with Block Kit payload to the deployments channel",
            "connector": "slack"
          },
          {
            "id": "n11",
            "type": "connector",
            "label": "Update GitHub commit status",
            "detail": "POST /repos/{owner}/{repo}/statuses/{sha} with deployment state and target URL",
            "connector": "github"
          },
          {
            "id": "n12",
            "type": "action",
            "label": "Update local state",
            "detail": "Write deployment record to state/deploy_history.json with status, timing, and health metrics"
          },
          {
            "id": "n13",
            "type": "end",
            "label": "Notification complete",
            "detail": "Deployment processed and team notified"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4"
          },
          {
            "id": "e4",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e5",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e6",
            "source": "n6",
            "target": "n7"
          },
          {
            "id": "e7",
            "source": "n7",
            "target": "n8",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e8",
            "source": "n7",
            "target": "n9",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e9",
            "source": "n8",
            "target": "n10"
          },
          {
            "id": "e10",
            "source": "n9",
            "target": "n10"
          },
          {
            "id": "e11",
            "source": "n10",
            "target": "n11"
          },
          {
            "id": "e12",
            "source": "n11",
            "target": "n12"
          },
          {
            "id": "e13",
            "source": "n12",
            "target": "n13"
          }
        ]
      },
      {
        "id": "flow_2",
        "name": "Post-Deploy Regression Detection",
        "description": "After a production deployment succeeds, monitors error rates and performance for 10 minutes to detect regressions against baseline metrics.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Production deploy ready",
            "detail": "A production deployment has reached READY status, triggering the monitoring window"
          },
          {
            "id": "n2",
            "type": "action",
            "label": "Load baseline metrics",
            "detail": "Read state/baselines.json to get previous deployment's steady-state error rate, p95 latency, and availability"
          },
          {
            "id": "n3",
            "type": "connector",
            "label": "Poll deployment checks",
            "detail": "GET /v13/deployments/{id}/checks â€” fetch current error rate, response times, and availability",
            "connector": "vercel"
          },
          {
            "id": "n4",
            "type": "action",
            "label": "Compare against baseline",
            "detail": "Calculate deltas: current error rate vs baseline, current p95 vs baseline, current availability vs 99% threshold"
          },
          {
            "id": "n5",
            "type": "decision",
            "label": "Regression detected?",
            "detail": "Error rate >2x baseline OR availability <99% OR p95 >3x baseline"
          },
          {
            "id": "n6",
            "type": "decision",
            "label": "Monitoring window expired?",
            "detail": "Check if 10 minutes have elapsed since monitoring started"
          },
          {
            "id": "n7",
            "type": "action",
            "label": "Wait 60 seconds",
            "detail": "Sleep for one polling interval before next check"
          },
          {
            "id": "n8",
            "type": "connector",
            "label": "Post regression alert",
            "detail": "POST /chat.postMessage â€” urgent alert with regression metrics, deltas, and recommended action",
            "connector": "slack"
          },
          {
            "id": "n9",
            "type": "event",
            "label": "Request rollback approval",
            "detail": "Emit manual_review event with structured evidence: before/after metrics, commit details, deployment timeline"
          },
          {
            "id": "n10",
            "type": "action",
            "label": "Update baselines",
            "detail": "Write current healthy metrics to state/baselines.json as new baseline for next deployment"
          },
          {
            "id": "n11",
            "type": "end",
            "label": "Monitoring complete â€” healthy",
            "detail": "Deployment passed health checks, baselines updated"
          },
          {
            "id": "n12",
            "type": "end",
            "label": "Monitoring complete â€” regression escalated",
            "detail": "Regression detected and escalated for rollback decision"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4"
          },
          {
            "id": "e4",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e5",
            "source": "n5",
            "target": "n8",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n6",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n10",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e8",
            "source": "n6",
            "target": "n7",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e9",
            "source": "n7",
            "target": "n3"
          },
          {
            "id": "e10",
            "source": "n8",
            "target": "n9"
          },
          {
            "id": "e11",
            "source": "n9",
            "target": "n12"
          },
          {
            "id": "e12",
            "source": "n10",
            "target": "n11"
          }
        ]
      },
      {
        "id": "flow_3",
        "name": "Rollback Execution",
        "description": "Executes a safe rollback when manual approval is granted after a post-deploy regression is detected.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Rollback approved",
            "detail": "manual_review approval received from team member with authorization"
          },
          {
            "id": "n2",
            "type": "action",
            "label": "Load deployment history",
            "detail": "Read state/deploy_history.json to identify the last known-good production deployment"
          },
          {
            "id": "n3",
            "type": "decision",
            "label": "Previous good deploy found?",
            "detail": "Verify a previous successful production deployment exists in history"
          },
          {
            "id": "n4",
            "type": "connector",
            "label": "Trigger redeployment",
            "detail": "POST /v13/deployments â€” clone the previous good deployment's configuration to redeploy it",
            "connector": "vercel"
          },
          {
            "id": "n5",
            "type": "connector",
            "label": "Monitor rollback deploy",
            "detail": "GET /v13/deployments/{id} â€” poll until new deployment reaches READY or ERROR status",
            "connector": "vercel"
          },
          {
            "id": "n6",
            "type": "decision",
            "label": "Rollback succeeded?",
            "detail": "Check if the rollback deployment reached READY status without errors"
          },
          {
            "id": "n7",
            "type": "connector",
            "label": "Post success summary",
            "detail": "POST /chat.postMessage â€” resolution card with incident timeline, rollback details, and restored version",
            "connector": "slack"
          },
          {
            "id": "n8",
            "type": "action",
            "label": "Log rollback incident",
            "detail": "Append incident record to state/rollback_log.json with timestamps, metrics, and approver"
          },
          {
            "id": "n9",
            "type": "decision",
            "label": "3+ rollbacks in 24h?",
            "detail": "Check rollback log for consecutive rollbacks indicating a systemic issue"
          },
          {
            "id": "n10",
            "type": "connector",
            "label": "Post systemic issue alert",
            "detail": "POST /chat.postMessage â€” escalation alert flagging repeated deployment failures as systemic",
            "connector": "slack"
          },
          {
            "id": "n11",
            "type": "error",
            "label": "Rollback deploy failed",
            "detail": "The rollback deployment itself encountered an error â€” critical escalation needed"
          },
          {
            "id": "n12",
            "type": "connector",
            "label": "Post critical escalation",
            "detail": "POST /chat.postMessage â€” critical alert that rollback failed, manual intervention required",
            "connector": "slack"
          },
          {
            "id": "n13",
            "type": "error",
            "label": "No previous deploy available",
            "detail": "Cannot rollback â€” no previous successful deployment found in history"
          },
          {
            "id": "n14",
            "type": "end",
            "label": "Rollback complete",
            "detail": "Service restored to previous known-good version"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e4",
            "source": "n3",
            "target": "n13",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e5",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e8",
            "source": "n6",
            "target": "n11",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e9",
            "source": "n7",
            "target": "n8"
          },
          {
            "id": "e10",
            "source": "n8",
            "target": "n9"
          },
          {
            "id": "e11",
            "source": "n9",
            "target": "n10",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e12",
            "source": "n9",
            "target": "n14",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e13",
            "source": "n10",
            "target": "n14"
          },
          {
            "id": "e14",
            "source": "n11",
            "target": "n12",
            "variant": "error"
          },
          {
            "id": "e15",
            "source": "n12",
            "target": "n14"
          },
          {
            "id": "e16",
            "source": "n13",
            "target": "n14",
            "variant": "error"
          }
        ]
      }
    ]
  }
}
