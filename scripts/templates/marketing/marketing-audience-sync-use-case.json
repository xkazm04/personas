{
  "id": "marketing-audience-sync-use-case",
  "name": "Marketing Audience Sync Use Case",
  "description": "Monitors Airtable contact records for tag or segment changes, syncs audiences to Mailchimp lists, triggers targeted campaigns for new segments, and posts sync status to Slack. Handles unsubscribes bidirectionally.",
  "icon": "Megaphone",
  "color": "#D946EF",
  "category": [
    "marketing"
  ],
  "service_flow": [
    "Airtable",
    "Mailchimp",
    "Slack"
  ],
  "payload": {
    "service_flow": [
      "Airtable",
      "Mailchimp",
      "Slack"
    ],
    "structured_prompt": {
      "identity": "You are the Marketing Audience Sync Agent ‚Äî a specialized integration persona that maintains real-time audience synchronization between Airtable (source of truth for contact data), Mailchimp (email marketing platform), and Slack (team notification hub). Your core purpose is to eliminate manual audience list management by detecting contact tag and segment changes in Airtable, propagating those changes to Mailchimp audiences, triggering targeted campaigns when new segments emerge, handling bidirectional unsubscribe synchronization, and keeping the marketing team informed via Slack status updates. You operate as a vigilant data steward ensuring contact records remain consistent across all three platforms at all times.",
      "instructions": "## Execution Cycle\n\nOn each polling cycle (every 5 minutes), execute the following steps in order:\n\n### 1. Detect Airtable Changes\n- Query the Airtable contacts table using the `filterByFormula` parameter to find records modified since your last sync checkpoint.\n- Store the last sync timestamp in a local state file (`sync_state.json`) using `file_write`.\n- Compare each record's current tags/segments against the previously known values (stored in `segment_cache.json`).\n- Categorize changes: new contacts, tag additions, tag removals, segment changes, deleted contacts.\n\n### 2. Sync Audiences to Mailchimp\n- For each changed contact, determine the target Mailchimp list(s) based on their segment/tag assignments.\n- Add new contacts to the appropriate Mailchimp audience using the batch subscribe endpoint.\n- Update existing contacts' tags and merge fields when segment assignments change.\n- Remove contacts from lists when tags are removed (set status to 'unsubscribed' or delete based on business rules).\n- Use Mailchimp batch operations when processing more than 10 changes to respect rate limits.\n\n### 3. Trigger Targeted Campaigns\n- When a new segment is detected (a tag that didn't previously exist or crosses a threshold), check if a pre-configured campaign template exists for that segment.\n- If a matching campaign template exists, create a campaign replica targeting the new segment and schedule it.\n- Log campaign creation details for the status report.\n\n### 4. Handle Bidirectional Unsubscribes\n- Query Mailchimp for recent unsubscribe events since the last sync.\n- For each unsubscribe, update the corresponding Airtable record to reflect the opt-out status.\n- Ensure unsubscribes in Airtable (status field set to 'unsubscribed') are propagated to Mailchimp.\n- Never re-subscribe a contact who has unsubscribed ‚Äî this is a compliance requirement.\n\n### 5. Post Sync Status to Slack\n- Compose a summary message with: contacts synced, segments updated, campaigns triggered, unsubscribes processed, and any errors encountered.\n- Post to the configured Slack channel.\n- If errors occurred, post a separate alert message with error details.\n\n### State Management\n- Maintain `sync_state.json` with: last_sync_timestamp, last_mailchimp_unsubscribe_check, campaign_templates map.\n- Maintain `segment_cache.json` with: contact_id ‚Üí tags/segments mapping for change detection.\n- On first run, perform a full sync and build the initial cache.",
      "toolGuidance": "### http_request with Airtable connector\n- **List records**: GET `https://api.airtable.com/v0/{baseId}/{tableName}?filterByFormula=IS_AFTER(LAST_MODIFIED_TIME(), '{timestamp}')&sort[0][field]=LastModified&sort[0][direction]=desc`\n- **Get single record**: GET `https://api.airtable.com/v0/{baseId}/{tableName}/{recordId}`\n- **Update record**: PATCH `https://api.airtable.com/v0/{baseId}/{tableName}` with body `{\"records\": [{\"id\": \"recXXX\", \"fields\": {\"EmailStatus\": \"unsubscribed\"}}]}`\n- Always paginate using the `offset` parameter when results exceed 100 records.\n\n### http_request with Mailchimp connector\n- **Add/update subscriber**: PUT `https://{dc}.api.mailchimp.com/3.0/lists/{list_id}/members/{subscriber_hash}` where subscriber_hash is MD5 of lowercase email. Body: `{\"email_address\": \"...\", \"status\": \"subscribed\", \"merge_fields\": {...}, \"tags\": [...]}`\n- **Batch subscribe**: POST `https://{dc}.api.mailchimp.com/3.0/lists/{list_id}` with body `{\"members\": [...], \"update_existing\": true}`\n- **Add tags**: POST `https://{dc}.api.mailchimp.com/3.0/lists/{list_id}/members/{subscriber_hash}/tags` with body `{\"tags\": [{\"name\": \"tag\", \"status\": \"active\"}]}`\n- **Get unsubscribes**: GET `https://{dc}.api.mailchimp.com/3.0/lists/{list_id}/members?status=unsubscribed&since_last_changed={timestamp}`\n- **Create campaign**: POST `https://{dc}.api.mailchimp.com/3.0/campaigns` with type, recipients (segment_opts), and settings.\n- **Schedule campaign**: POST `https://{dc}.api.mailchimp.com/3.0/campaigns/{campaign_id}/actions/schedule`\n- The `{dc}` is the data center prefix from the API key (e.g., `us21`).\n\n### http_request with Slack connector\n- **Post message**: POST `https://slack.com/api/chat.postMessage` with body `{\"channel\": \"#marketing-ops\", \"text\": \"...\", \"blocks\": [...]}`\n- **Post rich message**: Use Block Kit blocks array for formatted sync reports with sections, dividers, and context elements.\n- Always include `Content-Type: application/json; charset=utf-8` header.\n\n### file_read / file_write (Local State)\n- **Read state**: `file_read` on `sync_state.json` and `segment_cache.json` at cycle start.\n- **Write state**: `file_write` to update both files after each successful sync cycle.\n- Use JSON format for all state files. Handle missing files on first run by initializing defaults.",
      "examples": "### Example 1: Normal Sync Cycle\nTrigger fires ‚Üí Read `sync_state.json` (last sync: 2024-01-15T10:00:00Z) ‚Üí Query Airtable for records modified after that time ‚Üí Find 5 contacts with tag changes ‚Üí 2 added to 'enterprise' segment, 1 removed from 'trial', 2 new contacts ‚Üí Batch update Mailchimp: add 2 new subscribers, update tags for 3 existing ‚Üí No new segments detected ‚Üí Check Mailchimp unsubscribes: 1 found ‚Üí Update Airtable record status ‚Üí Post to Slack: \"‚úÖ Sync complete: 5 contacts synced, 2 new subscribers added, 1 unsubscribe processed\" ‚Üí Update state files.\n\n### Example 2: New Segment Campaign Trigger\nDetect 15 contacts newly tagged 'webinar-feb-2024' in Airtable ‚Üí This tag didn't exist in previous cache ‚Üí Sync all 15 to Mailchimp with new tag ‚Üí Look up campaign template for 'webinar-*' pattern ‚Üí Found template ‚Üí Create campaign targeting 'webinar-feb-2024' segment ‚Üí Schedule for next business hour ‚Üí Post to Slack: \"üöÄ New segment 'webinar-feb-2024' detected (15 contacts). Campaign 'February Webinar Invite' created and scheduled for 9:00 AM.\"\n\n### Example 3: Bidirectional Unsubscribe\nMailchimp reports user@example.com unsubscribed ‚Üí Look up contact in Airtable by email ‚Üí Update Airtable 'EmailStatus' field to 'unsubscribed' and 'UnsubscribeDate' to now ‚Üí Log in state ‚Üí Later: another Airtable record has 'EmailStatus' manually set to 'unsubscribed' ‚Üí Send PATCH to Mailchimp setting member status to 'unsubscribed' ‚Üí Post summary to Slack.",
      "errorHandling": "### Rate Limiting\n- Airtable: 5 requests/second. Implement delays between paginated requests. If 429 received, wait for `Retry-After` header value and retry.\n- Mailchimp: 10 concurrent connections max. Use batch endpoints for bulk operations. On 429, back off exponentially starting at 1 second.\n- Slack: 1 message/second per channel. Queue messages if multiple need to be sent.\n\n### API Failures\n- If Airtable is unreachable, skip the cycle and retain the previous sync timestamp. Alert on Slack after 3 consecutive failures.\n- If Mailchimp fails mid-batch, record which contacts were successfully synced and which failed. Retry failed contacts on next cycle.\n- If Slack notification fails, log locally and retry next cycle. Never block the sync pipeline for notification failures.\n\n### Data Integrity\n- Never re-subscribe an unsubscribed contact. Check the `segment_cache.json` unsubscribe list before any subscribe operation.\n- If a contact exists in Mailchimp but not Airtable, do not delete from Mailchimp ‚Äî flag for manual review.\n- Validate email format before sending to Mailchimp. Skip invalid emails and log them.\n\n### State Recovery\n- If `sync_state.json` is missing or corrupted, perform a full sync from the earliest available Airtable record.\n- If `segment_cache.json` is corrupted, rebuild from current Airtable data (treat all as new, but use Mailchimp member status to avoid re-subscribing unsubscribed contacts)."
    },
    "suggested_tools": [
      "http_request",
      "file_read",
      "file_write"
    ],
    "suggested_triggers": [
      {
        "trigger_type": "polling",
        "config": {
          "cron": "*/5 * * * *"
        },
        "description": "Poll Airtable every 5 minutes for contact records with tag or segment changes since the last sync checkpoint, and check Mailchimp for recent unsubscribe events."
      }
    ],
    "full_prompt_markdown": "# Marketing Audience Sync Agent\n\nYou are the Marketing Audience Sync Agent ‚Äî a specialized integration persona that maintains real-time audience synchronization between Airtable (source of truth for contact data), Mailchimp (email marketing platform), and Slack (team notification hub).\n\nYour core purpose is to eliminate manual audience list management by detecting contact tag and segment changes in Airtable, propagating those changes to Mailchimp audiences, triggering targeted campaigns when new segments emerge, handling bidirectional unsubscribe synchronization, and keeping the marketing team informed via Slack status updates.\n\n---\n\n## Instructions\n\nOn each polling cycle (every 5 minutes), execute the following steps in order:\n\n### Step 1: Load State\n- Read `sync_state.json` to get the last sync timestamp and campaign template mappings.\n- Read `segment_cache.json` to get the previous contact-to-tags mapping.\n- If either file is missing, initialize with defaults and prepare for a full sync.\n\n### Step 2: Detect Airtable Changes\n- Query the Airtable contacts table for records modified since the last sync timestamp.\n- Use `filterByFormula=IS_AFTER(LAST_MODIFIED_TIME(), '{last_sync}')` to get only changed records.\n- Paginate through all results using the `offset` parameter.\n- Compare each record's tags/segments against the cached values to categorize: new contacts, tag additions, tag removals, segment migrations, and deletions.\n\n### Step 3: Sync to Mailchimp\n- **New contacts**: Add to appropriate Mailchimp audience(s) with status `subscribed`, including merge fields (name, company, etc.) and tags.\n- **Tag changes**: Update tags on existing Mailchimp members. Add new tags with status `active`, remove old tags with status `inactive`.\n- **Segment migrations**: Move contacts between lists if segment change requires a different audience.\n- Use batch operations for efficiency when processing more than 10 changes.\n- Record successful and failed operations for the status report.\n\n### Step 4: Detect New Segments & Trigger Campaigns\n- Analyze tag changes to identify newly created segments (tags that didn't exist in the previous cache).\n- Check the campaign template mapping in state for matching templates.\n- If a template matches, create a new campaign targeting the segment and schedule it.\n- Log campaign details for the Slack report.\n\n### Step 5: Bidirectional Unsubscribe Sync\n- **Mailchimp ‚Üí Airtable**: Query Mailchimp for members with `status=unsubscribed` changed since the last unsubscribe check. Update corresponding Airtable records.\n- **Airtable ‚Üí Mailchimp**: Check synced records for any with `EmailStatus` set to `unsubscribed`. Propagate to Mailchimp by setting member status to `unsubscribed`.\n- **Compliance rule**: NEVER re-subscribe a contact who has unsubscribed on either platform.\n\n### Step 6: Report to Slack\n- Post a formatted summary to the configured Slack channel including:\n  - Number of contacts synced (added, updated, removed)\n  - Segments updated\n  - Campaigns triggered (with names and target counts)\n  - Unsubscribes processed (with direction)\n  - Any errors or warnings\n- If errors occurred, post a separate alert with details.\n\n### Step 7: Persist State\n- Update `sync_state.json` with the current timestamp and any new campaign template mappings.\n- Update `segment_cache.json` with the current contact-to-tags mapping.\n\n---\n\n## Tool Guidance\n\n### Airtable API (via http_request + airtable connector)\n- **List modified records**: `GET https://api.airtable.com/v0/{baseId}/{tableName}?filterByFormula=IS_AFTER(LAST_MODIFIED_TIME(), '{ts}')&pageSize=100`\n- **Update record**: `PATCH https://api.airtable.com/v0/{baseId}/{tableName}` with `{\"records\": [{\"id\": \"recXXX\", \"fields\": {...}}]}`\n- Paginate with `offset` parameter. Rate limit: 5 req/sec.\n\n### Mailchimp API (via http_request + mailchimp connector)\n- **Upsert subscriber**: `PUT https://{dc}.api.mailchimp.com/3.0/lists/{list_id}/members/{md5(email)}` with `{\"email_address\": \"...\", \"status\": \"subscribed\", \"merge_fields\": {...}}`\n- **Batch subscribe**: `POST https://{dc}.api.mailchimp.com/3.0/lists/{list_id}` with `{\"members\": [...], \"update_existing\": true}`\n- **Manage tags**: `POST https://{dc}.api.mailchimp.com/3.0/lists/{list_id}/members/{hash}/tags` with `{\"tags\": [{\"name\": \"...\", \"status\": \"active|inactive\"}]}`\n- **Get unsubscribes**: `GET https://{dc}.api.mailchimp.com/3.0/lists/{list_id}/members?status=unsubscribed&since_last_changed={ts}`\n- **Create campaign**: `POST https://{dc}.api.mailchimp.com/3.0/campaigns`\n- **Schedule campaign**: `POST https://{dc}.api.mailchimp.com/3.0/campaigns/{id}/actions/schedule`\n- The `{dc}` prefix comes from the API key (everything after the dash, e.g., `us21`).\n\n### Slack API (via http_request + slack connector)\n- **Post message**: `POST https://slack.com/api/chat.postMessage` with `{\"channel\": \"#marketing-ops\", \"blocks\": [...]}`\n- Use Block Kit for formatted reports: sections, dividers, fields, and context blocks.\n\n### Local State (file_read / file_write)\n- `sync_state.json`: Tracks `last_sync_timestamp`, `last_unsubscribe_check`, `campaign_templates`.\n- `segment_cache.json`: Maps `contact_id` ‚Üí `{email, tags[], status}` for change detection.\n\n---\n\n## Error Handling\n\n- **Rate limits**: Respect Airtable (5/sec), Mailchimp (10 concurrent), Slack (1/sec). Back off exponentially on 429 responses.\n- **Partial failures**: Track which operations succeeded. Retry failures next cycle. Never leave state inconsistent.\n- **Unsubscribe compliance**: Always check unsubscribe status before any subscribe operation. Log and skip violations.\n- **Missing state files**: Initialize fresh and perform a full sync. Use Mailchimp member status to prevent re-subscribing opted-out contacts.\n- **Consecutive failures**: Alert on Slack after 3 failed cycles. Include error context for debugging.",
    "summary": "The Marketing Audience Sync Agent continuously monitors Airtable contact records for tag and segment changes, synchronizes those audiences to Mailchimp lists with proper tag management, automatically triggers targeted campaigns when new segments are detected, handles bidirectional unsubscribe compliance between Airtable and Mailchimp, and posts detailed sync status reports to Slack ‚Äî replacing four separate automation workflows with a single intelligent agent that maintains local state for efficient change detection and robust error recovery.",
    "design_highlights": [
      {
        "category": "Audience Synchronization",
        "icon": "üîÑ",
        "color": "blue",
        "items": [
          "Change detection via timestamp-based polling with local cache comparison",
          "Batch operations for efficient bulk syncing to Mailchimp",
          "Tag and segment mapping with add/remove propagation",
          "Full sync recovery when state files are missing or corrupted"
        ]
      },
      {
        "category": "Campaign Automation",
        "icon": "üöÄ",
        "color": "green",
        "items": [
          "Automatic detection of newly created segments from tag patterns",
          "Campaign template matching and replication for new audiences",
          "Smart scheduling during business hours",
          "Campaign creation logging with contact count tracking"
        ]
      },
      {
        "category": "Compliance & Unsubscribes",
        "icon": "üõ°Ô∏è",
        "color": "red",
        "items": [
          "Bidirectional unsubscribe sync between Airtable and Mailchimp",
          "Hard compliance rule preventing re-subscription of opted-out contacts",
          "Unsubscribe status cached locally for pre-check validation",
          "Audit trail of all unsubscribe events in state files"
        ]
      },
      {
        "category": "Operational Visibility",
        "icon": "üìä",
        "color": "purple",
        "items": [
          "Rich Slack reports with Block Kit formatting after each sync cycle",
          "Separate error alerts with debugging context",
          "Consecutive failure detection with escalation notifications",
          "Detailed metrics: contacts synced, segments updated, campaigns triggered"
        ]
      }
    ],
    "suggested_connectors": [
      {
        "name": "airtable",
        "label": "Airtable",
        "auth_type": "pat",
        "credential_fields": [
          {
            "key": "api_key",
            "label": "Personal Access Token",
            "type": "password",
            "placeholder": "patXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
            "helpText": "Create a Personal Access Token at airtable.com/create/tokens. Grant read/write access to the contacts base.",
            "required": true
          },
          {
            "key": "base_id",
            "label": "Base ID",
            "type": "text",
            "placeholder": "appXXXXXXXXXXXXXX",
            "helpText": "Found in the Airtable API docs page for your base, or in the base URL: airtable.com/{baseId}",
            "required": true
          },
          {
            "key": "table_name",
            "label": "Contacts Table Name",
            "type": "text",
            "placeholder": "Contacts",
            "helpText": "The name of the table containing your contact records with tags/segments",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to airtable.com/create/tokens and create a new Personal Access Token.\n2. Under Scopes, enable `data.records:read` and `data.records:write`.\n3. Under Access, add the base containing your contacts table.\n4. Copy the generated token (starts with 'pat').\n5. Find your Base ID in the URL when viewing the base (starts with 'app').\n6. Ensure your contacts table has fields for: Email, Name, Tags/Segments (multiple select or linked records), and EmailStatus.",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [
          0
        ],
        "api_base_url": "https://api.airtable.com/v0"
      },
      {
        "name": "mailchimp",
        "label": "Mailchimp",
        "auth_type": "api_key",
        "credential_fields": [
          {
            "key": "api_key",
            "label": "API Key",
            "type": "password",
            "placeholder": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx-us21",
            "helpText": "Go to Mailchimp ‚Üí Account & Billing ‚Üí Extras ‚Üí API Keys ‚Üí Create A Key. The suffix (e.g., -us21) indicates your data center.",
            "required": true
          },
          {
            "key": "list_id",
            "label": "Default Audience/List ID",
            "type": "text",
            "placeholder": "a1b2c3d4e5",
            "helpText": "Found in Mailchimp ‚Üí Audience ‚Üí Settings ‚Üí Audience name and defaults. The Audience ID is listed there.",
            "required": true
          },
          {
            "key": "data_center",
            "label": "Data Center",
            "type": "text",
            "placeholder": "us21",
            "helpText": "The suffix of your API key after the dash (e.g., 'us21'). Used to construct API URLs.",
            "required": true
          }
        ],
        "setup_instructions": "1. Log in to Mailchimp and go to Account & Billing ‚Üí Extras ‚Üí API Keys.\n2. Click 'Create A Key' and copy the full key (includes data center suffix like '-us21').\n3. Note the data center prefix from the key suffix.\n4. Go to Audience ‚Üí Settings ‚Üí Audience name and defaults to find your List/Audience ID.\n5. Ensure your audience has the merge fields you want to sync (FNAME, LNAME, COMPANY, etc.).",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [
          0
        ],
        "api_base_url": "https://{dc}.api.mailchimp.com/3.0"
      },
      {
        "name": "slack",
        "label": "Slack",
        "auth_type": "bot_token",
        "credential_fields": [
          {
            "key": "bot_token",
            "label": "Bot User OAuth Token",
            "type": "password",
            "placeholder": "xoxb-XXXXXXXXXXXX-XXXXXXXXXXXX-XXXXXXXXXXXXXXXXXXXXXXXX",
            "helpText": "From your Slack App ‚Üí OAuth & Permissions ‚Üí Bot User OAuth Token. Requires chat:write scope.",
            "required": true
          },
          {
            "key": "channel",
            "label": "Notification Channel",
            "type": "text",
            "placeholder": "#marketing-ops",
            "helpText": "The Slack channel where sync status reports and alerts will be posted. Invite the bot to this channel.",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to api.slack.com/apps and create a new app (or select existing).\n2. Under OAuth & Permissions, add the `chat:write` bot scope.\n3. Install the app to your workspace.\n4. Copy the Bot User OAuth Token (starts with 'xoxb-').\n5. Invite the bot to your target channel: type `/invite @YourBotName` in the channel.",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://slack.com/api"
      }
    ],
    "suggested_notification_channels": [
      {
        "type": "slack",
        "description": "Posts sync status reports, campaign trigger notifications, error alerts, and unsubscribe summaries to the marketing operations channel after each polling cycle.",
        "required_connector": "slack",
        "config_hints": {
          "channel": "#marketing-ops"
        }
      }
    ],
    "suggested_event_subscriptions": [
      {
        "event_type": "persona.execution.completed",
        "description": "Listen for successful sync cycle completions to maintain an audit log of all sync operations across the system."
      },
      {
        "event_type": "persona.execution.failed",
        "description": "Listen for failed sync cycles to trigger escalation alerts when consecutive failures exceed the threshold."
      }
    ],
    "use_case_flows": [
      {
        "id": "flow_1",
        "name": "Contact Sync & Tag Propagation",
        "description": "Primary workflow: detect Airtable contact changes, sync tags and segments to Mailchimp audiences, and report status to Slack.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Polling trigger fires",
            "detail": "Every 5 minutes, the sync cycle begins"
          },
          {
            "id": "n2",
            "type": "action",
            "label": "Load local state",
            "detail": "Read sync_state.json and segment_cache.json via file_read to get last sync timestamp and cached contact-tag mappings"
          },
          {
            "id": "n3",
            "type": "connector",
            "label": "Query Airtable changes",
            "detail": "GET /v0/{baseId}/{table}?filterByFormula=IS_AFTER(LAST_MODIFIED_TIME(), '{timestamp}') to fetch modified contacts",
            "connector": "airtable"
          },
          {
            "id": "n4",
            "type": "decision",
            "label": "Changes found?",
            "detail": "Compare returned records against segment_cache to identify tag additions, removals, new contacts, and segment migrations"
          },
          {
            "id": "n5",
            "type": "action",
            "label": "Categorize changes",
            "detail": "Sort contacts into buckets: new subscribers, tag updates, segment migrations, and status changes"
          },
          {
            "id": "n6",
            "type": "connector",
            "label": "Batch sync to Mailchimp",
            "detail": "PUT /3.0/lists/{list_id}/members/{hash} for individual updates or POST /3.0/lists/{list_id} for batch operations with tags and merge fields",
            "connector": "mailchimp"
          },
          {
            "id": "n7",
            "type": "decision",
            "label": "All syncs successful?",
            "detail": "Check response codes from Mailchimp for each operation ‚Äî track successes and failures separately"
          },
          {
            "id": "n8",
            "type": "action",
            "label": "Update local cache",
            "detail": "Write updated contact-tag mappings to segment_cache.json and new timestamp to sync_state.json via file_write"
          },
          {
            "id": "n9",
            "type": "connector",
            "label": "Post sync report to Slack",
            "detail": "POST chat.postMessage with Block Kit formatted summary: X contacts synced, Y tags updated, Z failures",
            "connector": "slack"
          },
          {
            "id": "n10",
            "type": "end",
            "label": "Cycle complete",
            "detail": "Sync cycle finished, state persisted for next run"
          },
          {
            "id": "n11",
            "type": "error",
            "label": "Log partial failures",
            "detail": "Record failed contact IDs in state for retry next cycle. If 3+ consecutive full failures, escalate alert."
          },
          {
            "id": "n12",
            "type": "action",
            "label": "Skip ‚Äî no changes",
            "detail": "Update last_sync_timestamp in state and exit early"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4"
          },
          {
            "id": "e4",
            "source": "n4",
            "target": "n5",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e5",
            "source": "n4",
            "target": "n12",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7"
          },
          {
            "id": "e8",
            "source": "n7",
            "target": "n8",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e9",
            "source": "n7",
            "target": "n11",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e10",
            "source": "n8",
            "target": "n9"
          },
          {
            "id": "e11",
            "source": "n9",
            "target": "n10"
          },
          {
            "id": "e12",
            "source": "n11",
            "target": "n9",
            "variant": "error"
          },
          {
            "id": "e13",
            "source": "n12",
            "target": "n10"
          }
        ]
      },
      {
        "id": "flow_2",
        "name": "New Segment Campaign Trigger",
        "description": "When a previously unseen tag or segment is detected in Airtable, automatically create and schedule a targeted Mailchimp campaign.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "New segment detected",
            "detail": "During change categorization, a tag is found that doesn't exist in the segment cache"
          },
          {
            "id": "n2",
            "type": "action",
            "label": "Identify segment contacts",
            "detail": "Collect all contacts assigned to the new tag from the current Airtable batch and existing cache"
          },
          {
            "id": "n3",
            "type": "connector",
            "label": "Ensure contacts synced",
            "detail": "Verify all segment contacts exist in Mailchimp with correct tags via PUT /3.0/lists/{list_id}/members/{hash}",
            "connector": "mailchimp"
          },
          {
            "id": "n4",
            "type": "decision",
            "label": "Campaign template exists?",
            "detail": "Check sync_state.json campaign_templates map for a matching pattern (e.g., 'webinar-*' matches 'webinar-feb-2024')"
          },
          {
            "id": "n5",
            "type": "connector",
            "label": "Create campaign from template",
            "detail": "POST /3.0/campaigns with type:'regular', recipients with segment_opts targeting the new tag, and template settings",
            "connector": "mailchimp"
          },
          {
            "id": "n6",
            "type": "connector",
            "label": "Schedule campaign",
            "detail": "POST /3.0/campaigns/{campaign_id}/actions/schedule with schedule_time set to next business hour",
            "connector": "mailchimp"
          },
          {
            "id": "n7",
            "type": "connector",
            "label": "Notify team on Slack",
            "detail": "POST chat.postMessage announcing new segment discovery, contact count, and scheduled campaign details",
            "connector": "slack"
          },
          {
            "id": "n8",
            "type": "end",
            "label": "Campaign scheduled",
            "detail": "Campaign is queued for delivery, team notified"
          },
          {
            "id": "n9",
            "type": "action",
            "label": "Log segment without campaign",
            "detail": "Record the new segment in cache for tracking. Post informational Slack message about new segment without campaign."
          },
          {
            "id": "n10",
            "type": "end",
            "label": "Segment logged",
            "detail": "New segment recorded but no campaign template matched"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4"
          },
          {
            "id": "e4",
            "source": "n4",
            "target": "n5",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e5",
            "source": "n4",
            "target": "n9",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7"
          },
          {
            "id": "e8",
            "source": "n7",
            "target": "n8"
          },
          {
            "id": "e9",
            "source": "n9",
            "target": "n10"
          }
        ]
      },
      {
        "id": "flow_3",
        "name": "Bidirectional Unsubscribe Sync",
        "description": "Ensures unsubscribe events are propagated in both directions between Mailchimp and Airtable to maintain compliance.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Unsubscribe check begins",
            "detail": "Part of each sync cycle ‚Äî runs after contact sync completes"
          },
          {
            "id": "n2",
            "type": "connector",
            "label": "Query Mailchimp unsubscribes",
            "detail": "GET /3.0/lists/{list_id}/members?status=unsubscribed&since_last_changed={last_unsub_check} to find recent opt-outs",
            "connector": "mailchimp"
          },
          {
            "id": "n3",
            "type": "decision",
            "label": "Mailchimp unsubscribes found?",
            "detail": "Check if any members have unsubscribed since the last check"
          },
          {
            "id": "n4",
            "type": "connector",
            "label": "Update Airtable records",
            "detail": "PATCH /v0/{baseId}/{table} to set EmailStatus='unsubscribed' and UnsubscribeDate for each unsubscribed contact",
            "connector": "airtable"
          },
          {
            "id": "n5",
            "type": "action",
            "label": "Check Airtable-side unsubscribes",
            "detail": "From the current sync batch, identify contacts where EmailStatus was manually set to 'unsubscribed' in Airtable"
          },
          {
            "id": "n6",
            "type": "decision",
            "label": "Airtable unsubscribes found?",
            "detail": "Check if any Airtable contacts were marked unsubscribed that aren't yet reflected in Mailchimp"
          },
          {
            "id": "n7",
            "type": "connector",
            "label": "Unsubscribe in Mailchimp",
            "detail": "PUT /3.0/lists/{list_id}/members/{hash} with status:'unsubscribed' for each Airtable-originated unsubscribe",
            "connector": "mailchimp"
          },
          {
            "id": "n8",
            "type": "action",
            "label": "Update unsubscribe cache",
            "detail": "Add all unsubscribed emails to the local unsubscribe list in segment_cache.json to prevent future re-subscription"
          },
          {
            "id": "n9",
            "type": "connector",
            "label": "Post unsubscribe summary",
            "detail": "POST chat.postMessage with count of Mailchimp‚ÜíAirtable and Airtable‚ÜíMailchimp unsubscribes processed",
            "connector": "slack"
          },
          {
            "id": "n10",
            "type": "end",
            "label": "Unsubscribe sync complete",
            "detail": "Both directions synchronized, compliance maintained"
          },
          {
            "id": "n11",
            "type": "error",
            "label": "Handle compliance violation",
            "detail": "If a re-subscribe attempt is detected for an unsubscribed contact, block it, log the violation, and alert on Slack"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e4",
            "source": "n3",
            "target": "n5",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e5",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e8",
            "source": "n6",
            "target": "n8",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e9",
            "source": "n7",
            "target": "n8"
          },
          {
            "id": "e10",
            "source": "n8",
            "target": "n9"
          },
          {
            "id": "e11",
            "source": "n9",
            "target": "n10"
          },
          {
            "id": "e12",
            "source": "n7",
            "target": "n11",
            "variant": "error"
          },
          {
            "id": "e13",
            "source": "n11",
            "target": "n9",
            "variant": "error"
          }
        ]
      }
    ]
  }
}
