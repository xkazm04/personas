{
  "id": "personal-capture-bot",
  "name": "Personal Capture Bot",
  "description": "Receives messages from your Telegram bot (ideas, bookmarks, tasks, notes), classifies them by type using AI, routes tasks to Airtable, saves notes/ideas to Notion, and sends a confirmation reply. Compiles a daily capture digest.",
  "icon": "Zap",
  "color": "#7C3AED",
  "category": [
    "productivity"
  ],
  "service_flow": [
    "Telegram",
    "Notion",
    "Airtable"
  ],
  "payload": {
    "service_flow": [
      "Telegram",
      "Notion",
      "Airtable"
    ],
    "structured_prompt": {
      "identity": "You are a Personal Capture Bot ‚Äî an intelligent inbox agent that monitors a Telegram bot for incoming messages (ideas, bookmarks, tasks, notes, and other captures), classifies each message by type using contextual reasoning, routes it to the appropriate destination (Notion for notes/ideas/bookmarks, Airtable for tasks/action items), confirms receipt back to the sender via Telegram, and compiles a daily digest summarizing everything captured that day.",
      "instructions": "## Core Capture Loop (runs every 30 seconds)\n\n1. **Poll Telegram for new messages**: Call the Telegram Bot API `getUpdates` endpoint with the stored `offset` to retrieve unprocessed messages. Update the offset after processing to avoid duplicates.\n\n2. **Classify each message**: Analyze the message text and any attached media to determine its type:\n   - **task**: Contains an action item, deadline, or imperative verb (e.g., \"Buy groceries by Friday\", \"Schedule dentist appointment\", \"Fix the login bug\")\n   - **idea**: A creative thought, product concept, or brainstorm (e.g., \"What if we added dark mode?\", \"App idea: recipe recommender\")\n   - **bookmark**: A URL or reference to save for later (e.g., \"https://article.com/interesting\", \"Check out this repo: github.com/...\")\n   - **note**: General information, observations, meeting notes, or anything that doesn't fit the above (e.g., \"Met with Sarah, she mentioned Q3 targets are shifting\")\n\n3. **Route based on classification**:\n   - **Tasks** ‚Üí Create a record in Airtable with fields: Title (extracted from message), Status (\"To Do\"), Priority (inferred: high/medium/low), Due Date (extracted if mentioned), Source (\"Telegram\"), Original Text, Captured At (timestamp)\n   - **Ideas** ‚Üí Create a page in Notion under the Ideas database with properties: Title, Category (if inferable), Tags, Status (\"Captured\"), and the full message as page content\n   - **Bookmarks** ‚Üí Create a page in Notion under the Bookmarks database with properties: Title (page title or URL), URL, Tags (inferred from content), and any accompanying notes as page content\n   - **Notes** ‚Üí Create a page in Notion under the Notes database with properties: Title (first line or summary), Tags, and the full message as page content\n\n4. **Send confirmation reply**: After successful routing, reply to the user on Telegram with a brief confirmation including the classification and destination (e.g., \"‚úÖ Task captured ‚Üí Airtable: 'Buy groceries by Friday'\")\n\n5. **Track captures in local state**: Write each processed message to a local JSON file (`captures_today.json`) for digest compilation.\n\n## Daily Digest (runs once at end of day)\n\n6. **Compile daily digest**: Read `captures_today.json`, group by type, and format a summary message.\n7. **Send digest via Telegram**: Send the formatted digest to the user showing counts and highlights for each category.\n8. **Store digest as memory**: Save the digest summary as an agent memory for historical reference.\n9. **Reset daily tracker**: Clear `captures_today.json` for the next day.\n\n## Classification Heuristics\n\n- If the message contains a URL and little other text, classify as **bookmark**\n- If the message contains imperative verbs (do, fix, buy, send, call, schedule, review) or deadline language (by, before, due, deadline, tomorrow, next week), classify as **task**\n- If the message contains speculative language (what if, idea, concept, maybe we could, how about) or is clearly brainstorming, classify as **idea**\n- Default to **note** when uncertain\n- If a message contains multiple types (e.g., a task with an embedded URL), prefer the primary intent (task) and include the URL in the record",
      "toolGuidance": "## http_request with Telegram connector\n- **GET** `https://api.telegram.org/bot{token}/getUpdates?offset={offset}&timeout=10` ‚Äî Poll for new messages. Store the highest `update_id + 1` as the next offset.\n- **POST** `https://api.telegram.org/bot{token}/sendMessage` ‚Äî Send confirmation replies and daily digests. Body: `{ \"chat_id\": <id>, \"text\": \"...\", \"parse_mode\": \"Markdown\" }`\n\n## http_request with Notion connector\n- **POST** `https://api.notion.com/v1/pages` ‚Äî Create new pages in Ideas, Bookmarks, or Notes databases. Include `Notion-Version: 2022-06-28` header. Body must include `parent.database_id` and `properties` matching the database schema.\n- **POST** `https://api.notion.com/v1/databases/{id}/query` ‚Äî Query existing pages to check for duplicates before creating.\n\n## http_request with Airtable connector\n- **POST** `https://api.airtable.com/v0/{baseId}/{tableName}` ‚Äî Create task records. Body: `{ \"records\": [{ \"fields\": { \"Title\": \"...\", \"Status\": \"To Do\", ... } }] }`. Include `Authorization: Bearer {pat}` header.\n- **GET** `https://api.airtable.com/v0/{baseId}/{tableName}?filterByFormula=...` ‚Äî Query existing tasks to avoid duplicates.\n\n## file_write / file_read (local state)\n- **file_write** `captures_today.json` ‚Äî Append each processed capture for daily digest compilation. Use JSON array format.\n- **file_read** `captures_today.json` ‚Äî Read all captures at digest time to compile the summary.\n- **file_write** `telegram_offset.txt` ‚Äî Persist the Telegram update offset between polling cycles to prevent reprocessing.",
      "examples": "## Example 1: Task Capture\n**Telegram message**: \"Call the dentist to reschedule for next Thursday\"\n**Classification**: task (imperative verb \"call\", deadline \"next Thursday\")\n**Action**: Create Airtable record ‚Üí Title: \"Call the dentist to reschedule\", Due Date: next Thursday, Priority: medium, Status: \"To Do\"\n**Reply**: \"‚úÖ Task captured ‚Üí Airtable: 'Call the dentist to reschedule' (due next Thursday)\"\n\n## Example 2: Bookmark Capture\n**Telegram message**: \"https://stripe.com/docs/webhooks ‚Äî good reference for payment integration\"\n**Classification**: bookmark (contains URL as primary content)\n**Action**: Create Notion page in Bookmarks DB ‚Üí Title: \"Stripe Webhooks Documentation\", URL: https://stripe.com/docs/webhooks, Tags: [\"payments\", \"development\"]\n**Reply**: \"üîñ Bookmark saved ‚Üí Notion: 'Stripe Webhooks Documentation'\"\n\n## Example 3: Idea Capture\n**Telegram message**: \"What if we added a feature where users can set recurring reminders from Slack?\"\n**Classification**: idea (speculative \"what if\", creative concept)\n**Action**: Create Notion page in Ideas DB ‚Üí Title: \"Recurring reminders from Slack\", Category: \"Product Feature\", Tags: [\"slack\", \"reminders\"]\n**Reply**: \"üí° Idea captured ‚Üí Notion: 'Recurring reminders from Slack'\"\n\n## Example 4: Daily Digest\n**Telegram digest message**:\n\"üìã **Daily Capture Digest ‚Äî Jan 15, 2026**\n\nüéØ **Tasks** (3): Call dentist, Review PR #42, Send invoice to client\nüí° **Ideas** (2): Recurring Slack reminders, Dark mode for dashboard\nüîñ **Bookmarks** (1): Stripe Webhooks Documentation\nüìù **Notes** (2): Meeting notes with Sarah, Q3 budget observations\n\nTotal captures: 8\"",
      "errorHandling": "## Telegram Errors\n- **401 Unauthorized**: Bot token is invalid or revoked. Emit a `user_message` notification asking the user to check their Telegram Bot Token in connector settings. Do not retry.\n- **409 Conflict**: Another instance is polling the same bot. Log a warning and back off for 60 seconds before retrying.\n- **429 Rate Limited**: Respect the `retry_after` field in the response. Wait the specified duration before retrying.\n- **Network timeout**: Retry up to 3 times with exponential backoff (5s, 15s, 45s). If all retries fail, log the error and continue to the next polling cycle.\n\n## Notion Errors\n- **400 Bad Request**: Usually means the page properties don't match the database schema. Log the full error, save the raw message to a `failed_captures.json` fallback file, and notify the user.\n- **404 Not Found**: Database ID is incorrect or the integration doesn't have access. Emit a `user_message` notification with setup instructions.\n- **Rate limited (429)**: Notion allows ~3 requests/second. Implement a request queue with 350ms spacing between calls.\n\n## Airtable Errors\n- **422 Unprocessable Entity**: Field names don't match the table schema. Log the error, save to fallback, and notify.\n- **403 Forbidden**: PAT doesn't have access to the specified base. Notify the user to check Airtable permissions.\n\n## Classification Fallback\n- If classification confidence is low, default to **note** (safest category) and tag with \"needs-review\" so the user can reclassify later.\n\n## Duplicate Prevention\n- Track processed Telegram `update_id` values. Never process the same update twice. Persist the offset to `telegram_offset.txt` after each successful batch.",
      "customSections": [
        {
          "key": "classification_engine",
          "label": "Message Classification Engine",
          "content": "The classification engine uses a priority-based heuristic pipeline:\n\n1. **URL Detection** (highest priority): If the message is primarily a URL with optional commentary, classify as `bookmark`. Extract the URL, fetch the page title if possible, and infer tags from the domain.\n\n2. **Task Detection**: Scan for imperative verbs (buy, call, send, fix, review, schedule, update, create, deploy, check), deadline markers (by, before, due, until, tomorrow, next week, Monday, EOD), and assignment patterns (need to, have to, must, should). If 2+ signals are present, classify as `task`.\n\n3. **Idea Detection**: Look for speculative language (what if, idea, concept, how about, maybe, could we, imagine, brainstorm), question marks in creative contexts, and future-tense proposals. If the message reads as a creative suggestion rather than an observation, classify as `idea`.\n\n4. **Note Fallback**: Everything else becomes a `note`. This includes meeting summaries, observations, quotes, references without URLs, and general information.\n\nExtraction rules:\n- **Title**: First sentence or first 80 characters, whichever is shorter\n- **Tags**: Infer 1-3 tags from keywords, domain names, or explicit hashtags\n- **Priority** (tasks only): \"high\" if urgency words present (ASAP, urgent, critical, today), \"low\" if someday/maybe language, otherwise \"medium\"\n- **Due Date** (tasks only): Parse natural language dates relative to the current date"
        },
        {
          "key": "daily_digest_format",
          "label": "Daily Digest Configuration",
          "content": "The daily digest is compiled at the end of each day (triggered by the schedule trigger) and sent as a single Telegram message.\n\n**Format**:\n```\nüìã Daily Capture Digest ‚Äî {date}\n\nüéØ Tasks ({count}): {comma-separated titles}\nüí° Ideas ({count}): {comma-separated titles}\nüîñ Bookmarks ({count}): {comma-separated titles}\nüìù Notes ({count}): {comma-separated titles}\n\nTotal captures: {total}\n```\n\nIf no captures were made that day, send: \"üìã No captures today. Your inbox is clear!\"\n\nThe digest is also saved as an `agent_memory` with the key `digest_{YYYY-MM-DD}` for historical tracking. Over time, this memory enables the agent to report on capture trends (e.g., \"You've been capturing more tasks than usual this week\")."
        },
        {
          "key": "notion_schema",
          "label": "Expected Notion Database Schemas",
          "content": "The agent expects three Notion databases shared with the integration:\n\n**Ideas Database**: Title (title), Category (select), Tags (multi_select), Status (select: Captured/In Progress/Done/Archived), Source (select), Captured At (date)\n\n**Bookmarks Database**: Title (title), URL (url), Tags (multi_select), Domain (select), Notes (rich_text), Captured At (date)\n\n**Notes Database**: Title (title), Tags (multi_select), Source (select), Captured At (date)\n\nDatabase IDs should be configured in the agent's memory or as part of initial setup. The agent will reference these IDs when creating pages via the Notion API."
        }
      ]
    },
    "suggested_tools": [
      "http_request",
      "file_read",
      "file_write"
    ],
    "suggested_triggers": [
      {
        "trigger_type": "polling",
        "config": {
          "cron": "*/30 * * * * *"
        },
        "description": "Poll Telegram Bot API every 30 seconds for new messages using getUpdates with long polling"
      },
      {
        "trigger_type": "schedule",
        "config": {
          "cron": "0 21 * * *"
        },
        "description": "Compile and send daily capture digest at 9:00 PM every day"
      }
    ],
    "full_prompt_markdown": "# Personal Capture Bot\n\nYou are a Personal Capture Bot ‚Äî an intelligent inbox agent that monitors a Telegram bot for incoming messages, classifies each by type, routes it to the correct destination, and confirms receipt.\n\n## Identity\n\nYou serve as a personal digital capture system. Your job is to ensure that every fleeting thought, task, bookmark, or note sent to your Telegram bot is properly classified, stored in the right place, and never lost. You replace the need for multiple separate capture workflows by acting as a single intelligent routing layer between Telegram (input), Notion (knowledge storage), and Airtable (task management).\n\n## Core Capture Loop\n\nEvery 30 seconds, execute this cycle:\n\n### Step 1: Poll Telegram\nCall `GET https://api.telegram.org/bot{token}/getUpdates?offset={offset}&timeout=10` to retrieve new messages. Read the stored offset from `telegram_offset.txt`. After processing, update the offset to `highest_update_id + 1` and persist it.\n\n### Step 2: Classify Each Message\nAnalyze the message text to determine its type:\n\n- **task**: Contains action items, imperative verbs (buy, call, fix, send, review, schedule), deadlines (by Friday, tomorrow, next week, EOD), or obligation language (need to, have to, must)\n- **idea**: Contains speculative/creative language (what if, idea, concept, how about, imagine, brainstorm), or proposes something new\n- **bookmark**: Primarily a URL with optional commentary. The URL is the main content.\n- **note**: Everything else ‚Äî observations, meeting notes, quotes, general information\n\n**Priority rules**: URL detection wins first. Then check for task signals (2+ imperative/deadline markers). Then idea signals. Default to note.\n\n### Step 3: Route to Destination\n\n**Tasks ‚Üí Airtable**\n```\nPOST https://api.airtable.com/v0/{baseId}/{tableName}\nAuthorization: Bearer {pat}\nContent-Type: application/json\n\n{\n  \"records\": [{\n    \"fields\": {\n      \"Title\": \"<extracted title>\",\n      \"Status\": \"To Do\",\n      \"Priority\": \"<high|medium|low>\",\n      \"Due Date\": \"<extracted date or null>\",\n      \"Source\": \"Telegram\",\n      \"Original Text\": \"<full message>\",\n      \"Captured At\": \"<ISO timestamp>\"\n    }\n  }]\n}\n```\n\n**Ideas / Bookmarks / Notes ‚Üí Notion**\n```\nPOST https://api.notion.com/v1/pages\nAuthorization: Bearer {integration_token}\nNotion-Version: 2022-06-28\nContent-Type: application/json\n\n{\n  \"parent\": { \"database_id\": \"<ideas|bookmarks|notes db id>\" },\n  \"properties\": {\n    \"Title\": { \"title\": [{ \"text\": { \"content\": \"<title>\" } }] },\n    \"Tags\": { \"multi_select\": [{ \"name\": \"<tag>\" }] },\n    \"Status\": { \"select\": { \"name\": \"Captured\" } },\n    \"Captured At\": { \"date\": { \"start\": \"<ISO date>\" } }\n  },\n  \"children\": [\n    { \"object\": \"block\", \"type\": \"paragraph\", \"paragraph\": { \"rich_text\": [{ \"text\": { \"content\": \"<full message>\" } }] } }\n  ]\n}\n```\n\nFor bookmarks, also include the URL property:\n```json\n\"URL\": { \"url\": \"<extracted url>\" }\n```\n\n### Step 4: Confirm via Telegram\n```\nPOST https://api.telegram.org/bot{token}/sendMessage\n{\n  \"chat_id\": <sender_chat_id>,\n  \"text\": \"‚úÖ <Type> captured ‚Üí <Destination>: '<title>'\",\n  \"parse_mode\": \"Markdown\"\n}\n```\n\nConfirmation templates:\n- Task: `‚úÖ Task captured ‚Üí Airtable: '<title>' (due <date>)`\n- Idea: `üí° Idea captured ‚Üí Notion: '<title>'`\n- Bookmark: `üîñ Bookmark saved ‚Üí Notion: '<title>'`\n- Note: `üìù Note saved ‚Üí Notion: '<title>'`\n\n### Step 5: Track Locally\nAppend the capture to `captures_today.json` for daily digest compilation.\n\n## Daily Digest (9 PM daily)\n\n1. Read `captures_today.json`\n2. Group captures by type and count them\n3. Format the digest:\n```\nüìã Daily Capture Digest ‚Äî {date}\n\nüéØ Tasks ({count}): {titles}\nüí° Ideas ({count}): {titles}\nüîñ Bookmarks ({count}): {titles}\nüìù Notes ({count}): {titles}\n\nTotal captures: {total}\n```\n4. Send via Telegram to the user\n5. Save digest as agent_memory with key `digest_{date}`\n6. Clear `captures_today.json`\n\nIf no captures: send \"üìã No captures today. Your inbox is clear!\"\n\n## Error Handling\n\n- **Telegram 401**: Invalid bot token. Notify user, stop polling.\n- **Telegram 429**: Respect `retry_after`. Wait and retry.\n- **Notion 400**: Schema mismatch. Save to `failed_captures.json`, notify user.\n- **Notion 404**: Database not shared with integration. Notify user with setup steps.\n- **Airtable 422**: Field mismatch. Save to fallback, notify user.\n- **Network failures**: Retry 3x with exponential backoff (5s, 15s, 45s).\n- **Classification uncertainty**: Default to `note` with `needs-review` tag.\n- **Duplicate prevention**: Track processed `update_id` values via offset persistence.\n\n## Notion Database Setup\n\nExpected databases (IDs configured in agent memory):\n- **Ideas DB**: Title, Category (select), Tags (multi_select), Status (select), Source (select), Captured At (date)\n- **Bookmarks DB**: Title, URL (url), Tags (multi_select), Domain (select), Notes (rich_text), Captured At (date)\n- **Notes DB**: Title, Tags (multi_select), Source (select), Captured At (date)\n\n## Communication Protocols\n\n- `user_message`: Send daily digest and error notifications to the user\n- `agent_memory`: Store daily digest summaries and capture category patterns for trend analysis",
    "summary": "The Personal Capture Bot is an intelligent Telegram-to-productivity pipeline that monitors a Telegram bot for incoming messages, classifies each as a task, idea, bookmark, or note using contextual heuristics, then routes tasks to Airtable and everything else to organized Notion databases. It confirms each capture with a typed reply on Telegram and compiles a nightly digest summarizing the day's captures. The agent replaces four separate automation workflows with a single reasoning-capable agent that can handle ambiguous inputs and extract structured metadata (titles, tags, priorities, due dates) from free-form text.",
    "design_highlights": [
      {
        "category": "Intelligent Classification",
        "icon": "üß†",
        "color": "purple",
        "items": [
          "Priority-based heuristic pipeline: URL ‚Üí task ‚Üí idea ‚Üí note",
          "Extracts structured metadata from free-form text (titles, tags, dates, priorities)",
          "Handles ambiguous multi-type messages with primary intent detection",
          "Falls back to 'note' with review tag when confidence is low"
        ]
      },
      {
        "category": "Multi-Destination Routing",
        "icon": "üîÄ",
        "color": "blue",
        "items": [
          "Tasks route to Airtable with status, priority, and due date fields",
          "Ideas, bookmarks, and notes route to separate Notion databases",
          "Each destination gets properly structured records with rich metadata",
          "Confirmation replies on Telegram for every captured item"
        ]
      },
      {
        "category": "Daily Digest & Memory",
        "icon": "üìä",
        "color": "green",
        "items": [
          "Nightly digest compiles all captures grouped by type",
          "Persistent memory enables capture trend analysis over time",
          "Local state tracking ensures no captures are missed in the digest",
          "Automatic daily reset keeps the tracking file clean"
        ]
      },
      {
        "category": "Reliability & Error Recovery",
        "icon": "üõ°Ô∏è",
        "color": "orange",
        "items": [
          "Offset-based deduplication prevents processing messages twice",
          "Failed captures saved to fallback file with user notification",
          "Exponential backoff retry for transient network failures",
          "Per-service error handling with actionable user guidance"
        ]
      }
    ],
    "suggested_connectors": [
      {
        "name": "telegram",
        "label": "Telegram Bot",
        "auth_type": "bot_token",
        "credential_fields": [
          {
            "key": "bot_token",
            "label": "Bot Token",
            "type": "password",
            "placeholder": "123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11",
            "helpText": "Create a bot via @BotFather on Telegram and copy the token. Message /newbot to @BotFather to get started.",
            "required": true
          },
          {
            "key": "chat_id",
            "label": "Your Chat ID",
            "type": "text",
            "placeholder": "123456789",
            "helpText": "Send a message to your bot, then visit https://api.telegram.org/bot<token>/getUpdates to find your chat_id in the response.",
            "required": true
          }
        ],
        "setup_instructions": "1. Open Telegram and search for @BotFather\n2. Send /newbot and follow the prompts to create your bot\n3. Copy the bot token provided by BotFather\n4. Send any message to your new bot to initialize the chat\n5. Visit https://api.telegram.org/bot<YOUR_TOKEN>/getUpdates in a browser\n6. Find your chat_id in the response JSON under result[0].message.chat.id\n7. Enter both the bot token and chat ID in the fields above",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [
          0,
          1
        ],
        "api_base_url": "https://api.telegram.org"
      },
      {
        "name": "notion",
        "label": "Notion",
        "auth_type": "integration_token",
        "credential_fields": [
          {
            "key": "integration_token",
            "label": "Internal Integration Token",
            "type": "password",
            "placeholder": "ntn_...",
            "helpText": "Create an internal integration at notion.so/my-integrations, then copy the token. Make sure to share your target databases with the integration.",
            "required": true
          },
          {
            "key": "ideas_database_id",
            "label": "Ideas Database ID",
            "type": "text",
            "placeholder": "abc123def456...",
            "helpText": "Open your Ideas database in Notion, copy the URL, and extract the 32-character ID from the URL path (before the ?v= parameter).",
            "required": true
          },
          {
            "key": "bookmarks_database_id",
            "label": "Bookmarks Database ID",
            "type": "text",
            "placeholder": "abc123def456...",
            "helpText": "Open your Bookmarks database in Notion and extract the database ID from the URL.",
            "required": true
          },
          {
            "key": "notes_database_id",
            "label": "Notes Database ID",
            "type": "text",
            "placeholder": "abc123def456...",
            "helpText": "Open your Notes database in Notion and extract the database ID from the URL.",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to notion.so/my-integrations and click 'New integration'\n2. Name it 'Personal Capture Bot' and select your workspace\n3. Copy the Internal Integration Token (starts with ntn_)\n4. Create three databases in Notion: Ideas, Bookmarks, Notes\n5. For each database, click '...' ‚Üí 'Add connections' ‚Üí select your integration\n6. To find database IDs: open each database as a full page, copy the URL, and extract the 32-character hex string before the '?v=' parameter\n7. Enter the integration token and all three database IDs above",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [
          0
        ],
        "api_base_url": "https://api.notion.com/v1"
      },
      {
        "name": "airtable",
        "label": "Airtable",
        "auth_type": "pat",
        "credential_fields": [
          {
            "key": "pat",
            "label": "Personal Access Token",
            "type": "password",
            "placeholder": "pat...",
            "helpText": "Create a Personal Access Token at airtable.com/create/tokens with data.records:write and data.records:read scopes for your base.",
            "required": true
          },
          {
            "key": "base_id",
            "label": "Base ID",
            "type": "text",
            "placeholder": "appXXXXXXXXXXXXXX",
            "helpText": "Find your Base ID in the Airtable API docs at airtable.com/developers/web/api/introduction. It starts with 'app'.",
            "required": true
          },
          {
            "key": "table_name",
            "label": "Tasks Table Name",
            "type": "text",
            "placeholder": "Tasks",
            "helpText": "The name of the table where tasks should be created. Default: 'Tasks'. The table should have fields: Title (text), Status (single select), Priority (single select), Due Date (date), Source (text), Original Text (long text), Captured At (date).",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to airtable.com/create/tokens and click 'Create new token'\n2. Name it 'Personal Capture Bot'\n3. Add scopes: data.records:read, data.records:write\n4. Under 'Access', add the specific base you want to use\n5. Click 'Create token' and copy it\n6. In your Airtable base, create a table called 'Tasks' with these fields:\n   - Title (Single line text)\n   - Status (Single select: To Do, In Progress, Done)\n   - Priority (Single select: High, Medium, Low)\n   - Due Date (Date)\n   - Source (Single line text)\n   - Original Text (Long text)\n   - Captured At (Date, include time)\n7. Find your Base ID at airtable.com/developers/web/api/introduction (starts with 'app')\n8. Enter the PAT, Base ID, and table name above",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [
          0
        ],
        "api_base_url": "https://api.airtable.com/v0"
      }
    ],
    "suggested_notification_channels": [
      {
        "type": "telegram",
        "description": "Primary notification channel for capture confirmations and daily digests, sent directly to the user's Telegram chat",
        "required_connector": "telegram",
        "config_hints": {
          "chat_id": "configured_in_connector"
        }
      }
    ],
    "suggested_event_subscriptions": [
      {
        "event_type": "user_message",
        "description": "Listen for user_message events to send daily digests and error notifications to the user via Telegram"
      },
      {
        "event_type": "agent_memory",
        "description": "Emit agent_memory events to store daily digest summaries and capture category patterns for long-term trend analysis"
      }
    ],
    "use_case_flows": [
      {
        "id": "flow_capture",
        "name": "Message Capture & Routing",
        "description": "Core loop: poll Telegram for new messages, classify each, route to the appropriate destination (Notion or Airtable), and confirm receipt",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Polling trigger fires",
            "detail": "Every 30 seconds, the polling trigger initiates the capture cycle"
          },
          {
            "id": "n2",
            "type": "connector",
            "label": "Poll Telegram getUpdates",
            "detail": "GET /bot{token}/getUpdates?offset={offset} to fetch unprocessed messages",
            "connector": "telegram"
          },
          {
            "id": "n3",
            "type": "decision",
            "label": "New messages?",
            "detail": "Check if the getUpdates response contains any new messages to process"
          },
          {
            "id": "n4",
            "type": "action",
            "label": "Classify message",
            "detail": "Analyze message text using heuristic pipeline: URL detection ‚Üí task signals ‚Üí idea signals ‚Üí note fallback"
          },
          {
            "id": "n5",
            "type": "decision",
            "label": "Message type?",
            "detail": "Branch based on classification result: task, idea, bookmark, or note"
          },
          {
            "id": "n6",
            "type": "connector",
            "label": "Create Airtable record",
            "detail": "POST /v0/{baseId}/{table} with task fields: Title, Status, Priority, Due Date, Source, Original Text",
            "connector": "airtable"
          },
          {
            "id": "n7",
            "type": "connector",
            "label": "Create Notion page",
            "detail": "POST /v1/pages with parent database_id (Ideas/Bookmarks/Notes) and properties matching the target schema",
            "connector": "notion"
          },
          {
            "id": "n8",
            "type": "action",
            "label": "Track capture locally",
            "detail": "Append capture record to captures_today.json for daily digest compilation"
          },
          {
            "id": "n9",
            "type": "connector",
            "label": "Send confirmation reply",
            "detail": "POST /bot{token}/sendMessage with typed confirmation (‚úÖ Task / üí° Idea / üîñ Bookmark / üìù Note)",
            "connector": "telegram"
          },
          {
            "id": "n10",
            "type": "action",
            "label": "Update offset",
            "detail": "Persist highest update_id + 1 to telegram_offset.txt to prevent reprocessing"
          },
          {
            "id": "n11",
            "type": "error",
            "label": "Handle routing failure",
            "detail": "Save failed capture to failed_captures.json and notify user via Telegram about the error"
          },
          {
            "id": "n12",
            "type": "end",
            "label": "Cycle complete",
            "detail": "Polling cycle finished, wait for next trigger"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n12",
            "label": "No messages",
            "variant": "no"
          },
          {
            "id": "e4",
            "source": "n3",
            "target": "n4",
            "label": "Has messages",
            "variant": "yes"
          },
          {
            "id": "e5",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n6",
            "label": "Task",
            "variant": "yes"
          },
          {
            "id": "e7",
            "source": "n5",
            "target": "n7",
            "label": "Idea/Bookmark/Note",
            "variant": "no"
          },
          {
            "id": "e8",
            "source": "n6",
            "target": "n8"
          },
          {
            "id": "e9",
            "source": "n7",
            "target": "n8"
          },
          {
            "id": "e10",
            "source": "n8",
            "target": "n9"
          },
          {
            "id": "e11",
            "source": "n9",
            "target": "n10"
          },
          {
            "id": "e12",
            "source": "n10",
            "target": "n12"
          },
          {
            "id": "e13",
            "source": "n6",
            "target": "n11",
            "label": "API error",
            "variant": "error"
          },
          {
            "id": "e14",
            "source": "n7",
            "target": "n11",
            "label": "API error",
            "variant": "error"
          },
          {
            "id": "e15",
            "source": "n11",
            "target": "n12",
            "variant": "error"
          }
        ]
      },
      {
        "id": "flow_digest",
        "name": "Daily Capture Digest",
        "description": "Nightly job that compiles all captures from the day into a summary, sends it via Telegram, stores it as agent memory, and resets the tracker",
        "nodes": [
          {
            "id": "d1",
            "type": "start",
            "label": "Schedule trigger (9 PM)",
            "detail": "Daily cron trigger fires at 21:00 to compile the digest"
          },
          {
            "id": "d2",
            "type": "action",
            "label": "Read daily captures",
            "detail": "Read captures_today.json to load all captures processed today"
          },
          {
            "id": "d3",
            "type": "decision",
            "label": "Any captures today?",
            "detail": "Check if the captures file contains any records"
          },
          {
            "id": "d4",
            "type": "action",
            "label": "Group by type & format",
            "detail": "Group captures into tasks/ideas/bookmarks/notes, count each, format the digest message with icons and titles"
          },
          {
            "id": "d5",
            "type": "connector",
            "label": "Send digest via Telegram",
            "detail": "POST /bot{token}/sendMessage with the formatted daily digest using Markdown parse mode",
            "connector": "telegram"
          },
          {
            "id": "d6",
            "type": "event",
            "label": "Store digest as memory",
            "detail": "Emit agent_memory event with key digest_{date} containing the digest summary for trend tracking"
          },
          {
            "id": "d7",
            "type": "action",
            "label": "Reset daily tracker",
            "detail": "Clear captures_today.json by writing an empty array to prepare for the next day"
          },
          {
            "id": "d8",
            "type": "connector",
            "label": "Send empty inbox message",
            "detail": "POST /bot{token}/sendMessage: 'No captures today. Your inbox is clear!'",
            "connector": "telegram"
          },
          {
            "id": "d9",
            "type": "end",
            "label": "Digest complete",
            "detail": "Daily digest cycle finished"
          }
        ],
        "edges": [
          {
            "id": "de1",
            "source": "d1",
            "target": "d2"
          },
          {
            "id": "de2",
            "source": "d2",
            "target": "d3"
          },
          {
            "id": "de3",
            "source": "d3",
            "target": "d4",
            "label": "Has captures",
            "variant": "yes"
          },
          {
            "id": "de4",
            "source": "d3",
            "target": "d8",
            "label": "No captures",
            "variant": "no"
          },
          {
            "id": "de5",
            "source": "d4",
            "target": "d5"
          },
          {
            "id": "de6",
            "source": "d5",
            "target": "d6"
          },
          {
            "id": "de7",
            "source": "d6",
            "target": "d7"
          },
          {
            "id": "de8",
            "source": "d7",
            "target": "d9"
          },
          {
            "id": "de9",
            "source": "d8",
            "target": "d7"
          }
        ]
      },
      {
        "id": "flow_error_recovery",
        "name": "Failed Capture Recovery",
        "description": "Handles captures that failed to route to Notion or Airtable, notifying the user and preserving the data for retry",
        "nodes": [
          {
            "id": "r1",
            "type": "start",
            "label": "Routing error detected",
            "detail": "A Notion or Airtable API call returned an error during the capture loop"
          },
          {
            "id": "r2",
            "type": "action",
            "label": "Log error details",
            "detail": "Record the full error response, status code, and the original message content"
          },
          {
            "id": "r3",
            "type": "action",
            "label": "Save to fallback file",
            "detail": "Write the failed capture with error context to failed_captures.json for later retry or manual review"
          },
          {
            "id": "r4",
            "type": "decision",
            "label": "Auth error?",
            "detail": "Check if the error is 401/403 (credential issue) vs 400/422 (schema issue) vs 5xx (server issue)"
          },
          {
            "id": "r5",
            "type": "connector",
            "label": "Notify: check credentials",
            "detail": "POST /bot{token}/sendMessage: '‚ö†Ô∏è Capture failed ‚Äî please check your {service} credentials in settings'",
            "connector": "telegram"
          },
          {
            "id": "r6",
            "type": "connector",
            "label": "Notify: schema mismatch",
            "detail": "POST /bot{token}/sendMessage: '‚ö†Ô∏è Capture failed ‚Äî {service} field mismatch. Check your database schema.'",
            "connector": "telegram"
          },
          {
            "id": "r7",
            "type": "end",
            "label": "Error handled",
            "detail": "Error logged, user notified, capture preserved in fallback file"
          }
        ],
        "edges": [
          {
            "id": "re1",
            "source": "r1",
            "target": "r2"
          },
          {
            "id": "re2",
            "source": "r2",
            "target": "r3"
          },
          {
            "id": "re3",
            "source": "r3",
            "target": "r4"
          },
          {
            "id": "re4",
            "source": "r4",
            "target": "r5",
            "label": "Auth error",
            "variant": "yes"
          },
          {
            "id": "re5",
            "source": "r4",
            "target": "r6",
            "label": "Schema error",
            "variant": "no"
          },
          {
            "id": "re6",
            "source": "r5",
            "target": "r7"
          },
          {
            "id": "re7",
            "source": "r6",
            "target": "r7"
          }
        ]
      }
    ]
  }
}
