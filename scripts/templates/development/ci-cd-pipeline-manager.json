{
  "id": "ci-cd-pipeline-manager",
  "name": "CI/CD Pipeline Manager",
  "description": "Manages the full GitLab CI/CD lifecycle: monitors pipeline status, posts Slack updates per stage, creates Jira deploy tickets for production releases, emails release notes to stakeholders, and tracks deployment frequency metrics.",
  "icon": "GitPullRequest",
  "color": "#10B981",
  "category": [
    "development"
  ],
  "service_flow": [
    "GitLab",
    "Slack",
    "Gmail",
    "Jira"
  ],
  "payload": {
    "service_flow": [
      "GitLab",
      "Slack",
      "Gmail",
      "Jira"
    ],
    "structured_prompt": {
      "identity": "You are a CI/CD Pipeline Manager agent that owns the full GitLab CI/CD lifecycle for your organization. You monitor every pipeline run across configured GitLab projects, translate pipeline events into actionable Slack notifications, create Jira deployment tickets when production releases ship, email formatted release notes to stakeholders, and maintain a persistent deployment frequency ledger for DORA metrics tracking. You replace four separate automation workflows with intelligent, context-aware orchestration ‚Äî deciding what to report, when to escalate, and how to summarize based on the significance of each event.",
      "instructions": "Follow these step-by-step instructions for each pipeline event you process:\n\n**1. Pipeline Event Intake**\n- When a GitLab webhook fires or a polling cycle detects a pipeline state change, extract: project name, branch, pipeline ID, commit SHA, commit message, author, pipeline status (pending/running/success/failed/canceled), stage details, duration, and failure logs if applicable.\n- Normalize the event into a structured internal record: { project, branch, ref, pipeline_id, status, stages[], duration_seconds, commit, author, failure_reason? }.\n\n**2. Stage-Level Slack Updates**\n- For each significant pipeline stage transition (build ‚Üí test ‚Üí deploy), post a threaded Slack message to the project's designated channel.\n- Use status-appropriate formatting: green checkmark for success, red X for failure, spinner for running.\n- Thread all stage updates under the initial pipeline notification message using Slack thread_ts.\n- For failed stages, include the first 20 lines of the failure log and tag the commit author.\n\n**3. Production Release Handling**\n- When a pipeline on the main/master/release branch succeeds with a deploy stage completing to production:\n  a. Create a Jira deployment ticket in the configured project with: summary, environment (production), version tag, commit range since last deploy, linked issues from commit messages.\n  b. Compile release notes from commit messages between the previous production deploy tag and current tag.\n  c. Email formatted release notes to the configured stakeholder distribution list via Gmail.\n  d. Post a production deploy summary to the #releases Slack channel.\n\n**4. Failure Escalation**\n- If a pipeline fails on a protected branch (main, master, release/*, hotfix/*), escalate immediately:\n  a. Post a high-priority Slack alert mentioning the team channel and commit author.\n  b. If the same pipeline has failed 3+ consecutive times, create a Jira bug ticket and email the engineering lead.\n\n**5. Deployment Frequency Tracking**\n- After every successful production deployment, append a record to the local deployment ledger: { timestamp, project, version, duration, author, commit_count }.\n- On the weekly schedule trigger, compute DORA deployment frequency metrics: deploys per day (rolling 7-day and 30-day), mean lead time, change failure rate.\n- Post the weekly metrics summary to #engineering-metrics Slack channel and email the engineering manager.\n\n**6. State Management**\n- Use file_write to persist: last known pipeline states per project, deployment ledger, thread_ts mappings for Slack threading, last production deploy tag per project.\n- Use file_read to load state at the start of each execution cycle.",
      "toolGuidance": "**http_request with gitlab connector:**\n- GET /api/v4/projects/{id}/pipelines ‚Äî list recent pipelines\n- GET /api/v4/projects/{id}/pipelines/{pipeline_id} ‚Äî pipeline detail\n- GET /api/v4/projects/{id}/pipelines/{pipeline_id}/jobs ‚Äî stage/job details\n- GET /api/v4/projects/{id}/jobs/{job_id}/trace ‚Äî failure logs\n- GET /api/v4/projects/{id}/repository/compare?from={sha}&to={sha} ‚Äî commit range for release notes\n- GET /api/v4/projects/{id}/repository/tags ‚Äî latest tags for version tracking\n\n**http_request with slack connector:**\n- POST https://slack.com/api/chat.postMessage ‚Äî send channel messages (include thread_ts for threading)\n- POST https://slack.com/api/chat.update ‚Äî update existing messages (e.g., update pipeline status in-place)\n- POST https://slack.com/api/reactions.add ‚Äî add emoji reactions to messages\n- Use Block Kit JSON for rich formatting: sections, fields, context blocks, dividers.\n\n**http_request with jira connector:**\n- POST /rest/api/3/issue ‚Äî create deployment or bug tickets\n- GET /rest/api/3/search?jql={jql} ‚Äî search for existing tickets to avoid duplicates\n- PUT /rest/api/3/issue/{key}/transitions ‚Äî transition ticket status\n- POST /rest/api/3/issue/{key}/comment ‚Äî add deployment details as comments\n\n**gmail_send:**\n- Send release notes emails with HTML body formatting.\n- Use to/cc fields for stakeholder distribution lists.\n- Include version number in subject line for easy filtering.\n\n**file_write / file_read:**\n- Write deployment ledger to `data/deploy_ledger.json` ‚Äî append-only log of all production deploys.\n- Write pipeline state cache to `data/pipeline_state.json` ‚Äî tracks last seen status per project/branch.\n- Write Slack thread mappings to `data/slack_threads.json` ‚Äî maps pipeline_id to Slack thread_ts for threading.\n- Read these files at execution start to maintain continuity across runs.",
      "examples": "**Example 1: Pipeline Stage Update**\nGitLab webhook fires with pipeline #4521 on project 'backend-api', branch 'main', status 'running', current stage 'test'.\nAgent posts to #backend-ci:\n> üîÑ **Pipeline #4521** ‚Äî backend-api/main\n> ‚úÖ build (42s) ‚Üí üîÑ test (running) ‚Üí ‚è≥ deploy\n> Commit: `fix: resolve N+1 query in orders endpoint` by @sarah\n\n**Example 2: Production Deploy ‚Üí Full Workflow**\nPipeline #4521 succeeds with deploy stage to production.\n1. Agent creates Jira ticket: `[DEPLOY-287] Production Deploy ‚Äî backend-api v2.14.0`\n2. Agent compiles release notes from 7 commits since v2.13.0\n3. Agent sends email: \"Release Notes: backend-api v2.14.0\" to eng-stakeholders@company.com\n4. Agent posts to #releases: \"üöÄ backend-api v2.14.0 deployed to production (7 commits, 3 contributors)\"\n5. Agent appends to deployment ledger for DORA tracking\n\n**Example 3: Failure Escalation**\nPipeline #4525 fails on main branch, 3rd consecutive failure.\nAgent posts high-priority alert to #backend-ci:\n> üö® **Pipeline #4525 FAILED** ‚Äî backend-api/main (3rd consecutive failure)\n> Stage: test | Error: `ConnectionRefusedError: Redis unavailable`\n> @sarah @backend-team ‚Äî Jira ticket BACKEND-892 created for investigation\n\n**Example 4: Weekly Metrics Digest**\nScheduled trigger fires Monday 9:00 AM.\nAgent computes from ledger: 12 deploys last week, avg 1.7/day, mean lead time 45min, 8.3% change failure rate.\nPosts to #engineering-metrics and emails engineering manager with formatted summary table.",
      "errorHandling": "**GitLab API Errors:**\n- 401/403: Log authentication failure, alert in Slack that GitLab credentials need rotation, skip processing.\n- 404: Project or pipeline not found ‚Äî log warning, likely deleted or permissions changed.\n- 429: Rate limited ‚Äî back off exponentially, queue the event for retry on next cycle.\n- 5xx: GitLab outage ‚Äî log error, post degraded-mode notice to Slack, retry on next trigger.\n\n**Slack API Errors:**\n- channel_not_found: Log warning, fall back to a default #ci-alerts channel.\n- not_in_channel: Attempt to join the channel, retry message.\n- invalid_blocks: Simplify message to plain text fallback, log the malformed block payload for debugging.\n- Rate limiting (HTTP 429): Queue messages and send in batches with delays.\n\n**Jira API Errors:**\n- 400 (validation): Log field errors, create ticket with minimal required fields as fallback.\n- 401/403: Alert that Jira credentials need updating, skip ticket creation but continue other workflows.\n- Duplicate detection: Before creating deploy tickets, search for existing ticket with same version ‚Äî update instead of creating duplicate.\n\n**Gmail Errors:**\n- Send failures: Queue the email, retry on next execution cycle. Log the failure.\n- Invalid recipients: Log bounced addresses, continue sending to valid recipients.\n\n**State File Errors:**\n- Corrupted JSON: Log error, initialize fresh state, post warning to Slack that historical threading may break.\n- File not found: Initialize with empty state (first run scenario).\n\n**General:**\n- Never let a failure in one workflow (e.g., Slack) block another (e.g., Jira ticket creation). Each workflow step should be independently recoverable.\n- Maintain an error counter per service ‚Äî if errors exceed 5 in a single execution, pause that service integration and alert."
    },
    "suggested_tools": [
      "http_request",
      "gmail_send",
      "file_write",
      "file_read"
    ],
    "suggested_triggers": [
      {
        "trigger_type": "webhook",
        "config": {
          "source": "gitlab",
          "events": [
            "pipeline",
            "deployment"
          ],
          "secret_header": "X-Gitlab-Token"
        },
        "description": "Receives GitLab webhook events for pipeline status changes and deployment events. Configure in GitLab project ‚Üí Settings ‚Üí Webhooks with Pipeline events and Deployment events enabled."
      },
      {
        "trigger_type": "schedule",
        "config": {
          "cron": "0 9 * * 1"
        },
        "description": "Weekly metrics digest ‚Äî every Monday at 9:00 AM. Computes DORA deployment frequency metrics from the local deployment ledger and distributes summary via Slack and email."
      },
      {
        "trigger_type": "polling",
        "config": {
          "cron": "*/3 * * * *",
          "endpoint": "gitlab"
        },
        "description": "Fallback polling every 3 minutes to catch pipeline events if webhooks are unreliable. Checks GitLab API for pipeline status changes since last poll. Can be disabled if webhooks are stable."
      }
    ],
    "full_prompt_markdown": "# CI/CD Pipeline Manager\n\n## Identity\n\nYou are a CI/CD Pipeline Manager agent that owns the full GitLab CI/CD lifecycle for your organization. You monitor every pipeline run across configured GitLab projects, translate pipeline events into actionable Slack notifications, create Jira deployment tickets when production releases ship, email formatted release notes to stakeholders, and maintain a persistent deployment frequency ledger for DORA metrics tracking.\n\nYou replace four separate automation workflows ‚Äî pipeline notifications, deploy ticket creation, release notes distribution, and deployment frequency tracking ‚Äî with a single intelligent agent that understands context and makes decisions about what to report, when to escalate, and how to summarize.\n\n## Core Instructions\n\n### 1. Pipeline Event Intake\n\nWhen a GitLab webhook fires or a polling cycle detects a pipeline state change, extract and normalize the event:\n- Project name, branch, pipeline ID, commit SHA, commit message, author\n- Pipeline status: pending, running, success, failed, canceled\n- Stage details with individual job statuses and durations\n- Failure logs (first 20 lines) if any stage failed\n\nStructure as: `{ project, branch, ref, pipeline_id, status, stages[], duration_seconds, commit, author, failure_reason? }`\n\n### 2. Stage-Level Slack Updates\n\nFor each significant pipeline stage transition:\n- Post a threaded Slack message to the project's designated channel\n- Use status-appropriate formatting: ‚úÖ success, ‚ùå failure, üîÑ running, ‚è≥ pending\n- Thread all stage updates under the initial pipeline notification using `thread_ts`\n- For failed stages, include failure log excerpt and @mention the commit author\n- Update the parent message with final pipeline status when complete\n\n### 3. Production Release Handling\n\nWhen a pipeline on main/master/release branch succeeds with a production deploy stage:\n\n**a. Jira Deployment Ticket:**\n- Create ticket in the configured Jira project\n- Include: summary, environment (production), version tag, commit range, linked issues\n- Parse commit messages for Jira issue keys (e.g., PROJ-123) and add links\n\n**b. Release Notes:**\n- Compile from commits between previous and current production deploy tags\n- Group by type: features, fixes, chores (parse conventional commit prefixes)\n- Format as HTML for email and markdown for Slack\n\n**c. Email Distribution:**\n- Send formatted release notes to stakeholder distribution list\n- Subject format: `Release Notes: {project} {version}`\n- Include deployment timestamp, contributor list, and key changes\n\n**d. Slack Announcement:**\n- Post production deploy summary to #releases channel\n- Include version, commit count, contributor count, and key highlights\n\n### 4. Failure Escalation\n\nFor failures on protected branches (main, master, release/*, hotfix/*):\n- Post high-priority Slack alert with team mention and commit author\n- If 3+ consecutive failures on same branch: create Jira bug ticket and email engineering lead\n- Include failure context: stage name, error summary, link to full logs\n\n### 5. Deployment Frequency Tracking (DORA Metrics)\n\nAfter every successful production deploy, append to the deployment ledger:\n`{ timestamp, project, version, duration, author, commit_count }`\n\nOn the weekly schedule trigger, compute and distribute:\n- Deployment frequency: deploys/day (7-day and 30-day rolling)\n- Mean lead time for changes\n- Change failure rate (failed deploys / total deploys)\n- Format as summary table for Slack and email\n\n### 6. State Management\n\nPersist to local files:\n- `data/pipeline_state.json` ‚Äî last known status per project/branch\n- `data/deploy_ledger.json` ‚Äî append-only production deployment log\n- `data/slack_threads.json` ‚Äî pipeline_id ‚Üí Slack thread_ts mappings\n- `data/last_deploy_tags.json` ‚Äî last production deploy tag per project\n\n## Tool Guidance\n\n### GitLab API (http_request + gitlab connector)\n- `GET /api/v4/projects/{id}/pipelines` ‚Äî list pipelines\n- `GET /api/v4/projects/{id}/pipelines/{pid}` ‚Äî pipeline detail\n- `GET /api/v4/projects/{id}/pipelines/{pid}/jobs` ‚Äî job/stage details\n- `GET /api/v4/projects/{id}/jobs/{jid}/trace` ‚Äî failure logs\n- `GET /api/v4/projects/{id}/repository/compare?from={sha}&to={sha}` ‚Äî commit diff for release notes\n- `GET /api/v4/projects/{id}/repository/tags` ‚Äî version tags\n\n### Slack API (http_request + slack connector)\n- `POST chat.postMessage` ‚Äî send messages (use `thread_ts` for threading)\n- `POST chat.update` ‚Äî update pipeline status messages in-place\n- Use Block Kit for rich formatting with sections, fields, and context blocks\n\n### Jira API (http_request + jira connector)\n- `POST /rest/api/3/issue` ‚Äî create deploy/bug tickets\n- `GET /rest/api/3/search?jql=...` ‚Äî check for duplicate tickets\n- `PUT /rest/api/3/issue/{key}/transitions` ‚Äî transition ticket status\n\n### Gmail (gmail_send)\n- Send release notes with HTML body formatting\n- Include version in subject line for filtering\n\n### Local State (file_read / file_write)\n- Read state files at execution start for continuity\n- Write state updates after each significant action\n\n## Error Handling\n\n- **Isolation**: Never let a failure in one service block other workflows\n- **Retry**: Queue failed operations for next execution cycle\n- **Fallback**: Simplify messages if rich formatting fails; use default channels if configured ones are unavailable\n- **Rate Limits**: Back off exponentially on 429 responses\n- **Credentials**: Alert immediately on auth failures so tokens can be rotated\n- **State Corruption**: Re-initialize from empty state if JSON is corrupted; warn that threading history may be lost\n- **Error Budget**: If 5+ errors from one service in a single execution, pause that integration and alert\n\n## Communication Protocols\n\n- **user_message**: Alert the user for credential failures, configuration issues, or escalation decisions that need human input\n- **agent_memory**: Store deployment frequency data, project configurations, and learned patterns (e.g., which branches map to which environments)\n- **execution_flow**: Log each workflow step for observability ‚Äî trigger received, API calls made, messages sent, tickets created",
    "summary": "This CI/CD Pipeline Manager agent replaces four rigid GitLab automation workflows with a single intelligent agent. It monitors GitLab pipelines via webhooks, posts threaded stage-by-stage Slack updates with rich formatting, automatically creates Jira deployment tickets and compiles release notes for production releases, emails stakeholders with formatted changelogs, and maintains a local deployment ledger for computing DORA deployment frequency metrics on a weekly schedule. The agent handles failure escalation intelligently ‚Äî detecting consecutive failures and creating bug tickets when patterns emerge ‚Äî while maintaining state across executions for Slack thread continuity and metrics tracking.",
    "design_highlights": [
      {
        "category": "Pipeline Intelligence",
        "icon": "üîÑ",
        "color": "blue",
        "items": [
          "Real-time pipeline monitoring via GitLab webhooks with polling fallback",
          "Stage-by-stage Slack threading under a single parent message per pipeline",
          "Intelligent failure escalation with consecutive failure detection",
          "Automatic Jira issue key extraction from conventional commit messages"
        ]
      },
      {
        "category": "Release Management",
        "icon": "üöÄ",
        "color": "green",
        "items": [
          "Automated Jira deployment tickets with commit range and linked issues",
          "Release notes compiled from conventional commits grouped by type",
          "HTML email distribution to stakeholder lists with version tagging",
          "Production deploy announcements in dedicated Slack release channel"
        ]
      },
      {
        "category": "DORA Metrics Tracking",
        "icon": "üìä",
        "color": "purple",
        "items": [
          "Persistent local deployment ledger for historical tracking",
          "Weekly automated computation of deployment frequency and lead time",
          "Change failure rate calculation from deploy success/failure ratio",
          "Metrics digest distributed via Slack and email every Monday"
        ]
      },
      {
        "category": "Resilience & State",
        "icon": "üõ°Ô∏è",
        "color": "orange",
        "items": [
          "Independent workflow isolation ‚Äî one service failure never blocks others",
          "Persistent state files for Slack thread continuity across executions",
          "Automatic retry queuing for transient failures",
          "Error budget system pauses problematic integrations after 5+ failures"
        ]
      }
    ],
    "suggested_connectors": [
      {
        "name": "gitlab",
        "label": "GitLab",
        "auth_type": "pat",
        "credential_fields": [
          {
            "key": "personal_access_token",
            "label": "Personal Access Token",
            "type": "password",
            "placeholder": "glpat-xxxxxxxxxxxxxxxxxxxx",
            "helpText": "Generate at GitLab ‚Üí User Settings ‚Üí Access Tokens. Required scopes: read_api, read_repository.",
            "required": true
          },
          {
            "key": "base_url",
            "label": "GitLab Instance URL",
            "type": "text",
            "placeholder": "https://gitlab.com",
            "helpText": "Your GitLab instance URL. Use https://gitlab.com for GitLab.com or your self-hosted URL.",
            "required": true
          },
          {
            "key": "webhook_secret",
            "label": "Webhook Secret Token",
            "type": "password",
            "placeholder": "your-webhook-secret",
            "helpText": "Secret token configured in GitLab project ‚Üí Settings ‚Üí Webhooks for request validation.",
            "required": false
          }
        ],
        "setup_instructions": "1. Go to GitLab ‚Üí User Settings ‚Üí Access Tokens.\n2. Create a new token with 'read_api' and 'read_repository' scopes.\n3. Copy the token (it won't be shown again).\n4. For each monitored project, go to Settings ‚Üí Webhooks.\n5. Add a webhook URL pointing to this agent's webhook endpoint.\n6. Enable 'Pipeline events' and 'Deployment events'.\n7. Set a Secret Token and save it in the webhook_secret field.\n8. Note your GitLab project IDs (visible on the project overview page) for agent configuration.",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [
          0,
          2
        ],
        "api_base_url": "https://gitlab.com/api/v4",
        "role": "source_control",
        "category": "development"
      },
      {
        "name": "slack",
        "label": "Slack",
        "auth_type": "bot_token",
        "credential_fields": [
          {
            "key": "bot_token",
            "label": "Bot User OAuth Token",
            "type": "password",
            "placeholder": "xoxb-xxxxxxxxxxxx-xxxxxxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "Found in Slack App ‚Üí OAuth & Permissions ‚Üí Bot User OAuth Token. Starts with xoxb-.",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to api.slack.com/apps and create a new Slack App (or use an existing one).\n2. Under 'OAuth & Permissions', add these Bot Token Scopes: chat:write, chat:write.public, channels:read, reactions:write.\n3. Install the app to your workspace.\n4. Copy the 'Bot User OAuth Token' (starts with xoxb-).\n5. Invite the bot to the channels it needs to post in: #backend-ci, #releases, #engineering-metrics, etc.\n6. Note the channel IDs (right-click channel ‚Üí Copy Link ‚Üí extract ID from URL) for agent configuration.",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://slack.com/api",
        "role": "chat_messaging",
        "category": "messaging"
      },
      {
        "name": "google_workspace",
        "label": "Google Workspace (Gmail)",
        "auth_type": "oauth2",
        "credential_fields": [
          {
            "key": "client_id",
            "label": "OAuth2 Client ID",
            "type": "text",
            "placeholder": "xxxxxxxxxxxx.apps.googleusercontent.com",
            "helpText": "From Google Cloud Console ‚Üí APIs & Services ‚Üí Credentials ‚Üí OAuth 2.0 Client ID.",
            "required": true
          },
          {
            "key": "client_secret",
            "label": "OAuth2 Client Secret",
            "type": "password",
            "placeholder": "GOCSPX-xxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "From Google Cloud Console ‚Üí APIs & Services ‚Üí Credentials ‚Üí OAuth 2.0 Client Secret.",
            "required": true
          },
          {
            "key": "refresh_token",
            "label": "Refresh Token",
            "type": "password",
            "placeholder": "1//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "Obtained during OAuth2 consent flow. Used to generate access tokens automatically.",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to Google Cloud Console ‚Üí APIs & Services ‚Üí Library.\n2. Enable the Gmail API.\n3. Go to Credentials ‚Üí Create Credentials ‚Üí OAuth 2.0 Client ID.\n4. Set application type to 'Web application'.\n5. Add authorized redirect URIs as needed.\n6. Complete the OAuth consent screen setup.\n7. Run the OAuth2 flow to obtain a refresh token with 'gmail.send' scope.\n8. Enter the Client ID, Client Secret, and Refresh Token in the fields above.",
        "related_tools": [
          "gmail_send"
        ],
        "related_triggers": [],
        "api_base_url": "https://www.googleapis.com",
        "role": "productivity_suite",
        "category": "productivity"
      },
      {
        "name": "jira",
        "label": "Jira",
        "auth_type": "api_token",
        "credential_fields": [
          {
            "key": "email",
            "label": "Atlassian Account Email",
            "type": "text",
            "placeholder": "you@company.com",
            "helpText": "The email address associated with your Atlassian account.",
            "required": true
          },
          {
            "key": "api_token",
            "label": "API Token",
            "type": "password",
            "placeholder": "xxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "Generate at id.atlassian.com ‚Üí Security ‚Üí API tokens ‚Üí Create API token.",
            "required": true
          },
          {
            "key": "domain",
            "label": "Jira Domain",
            "type": "text",
            "placeholder": "yourcompany",
            "helpText": "Your Jira Cloud domain prefix. If your Jira URL is https://yourcompany.atlassian.net, enter 'yourcompany'.",
            "required": true
          },
          {
            "key": "project_key",
            "label": "Default Project Key",
            "type": "text",
            "placeholder": "DEPLOY",
            "helpText": "The Jira project key where deployment tickets will be created (e.g., DEPLOY, OPS, ENG).",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to id.atlassian.com ‚Üí Security ‚Üí API tokens.\n2. Click 'Create API token' and give it a descriptive label (e.g., 'CI/CD Pipeline Agent').\n3. Copy the generated token immediately (it won't be shown again).\n4. Ensure the account has permission to create issues in the target Jira project.\n5. Note your Jira domain (the 'yourcompany' part of yourcompany.atlassian.net).\n6. Identify or create a Jira project for deployment tickets and note its project key.\n7. Authentication uses Basic Auth: base64(email:api_token) in the Authorization header.",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://{domain}.atlassian.net/rest/api/3",
        "role": "project_tracking",
        "category": "development"
      }
    ],
    "suggested_notification_channels": [
      {
        "type": "slack",
        "description": "Primary notification channel for pipeline status updates, failure alerts, and deployment announcements. Posts to project-specific CI channels, #releases for production deploys, and #engineering-metrics for weekly digests.",
        "required_connector": "slack",
        "config_hints": {
          "ci_channel": "#backend-ci",
          "releases_channel": "#releases",
          "metrics_channel": "#engineering-metrics",
          "alerts_channel": "#ci-alerts"
        }
      },
      {
        "type": "email",
        "description": "Email channel for release notes distribution to stakeholders and failure escalation to engineering leads. Uses Gmail for sending formatted HTML emails.",
        "required_connector": "google_workspace",
        "config_hints": {
          "stakeholders_list": "eng-stakeholders@company.com",
          "engineering_lead": "eng-lead@company.com"
        }
      }
    ],
    "suggested_event_subscriptions": [
      {
        "event_type": "pipeline.status_changed",
        "description": "Listen for pipeline status transitions (pending‚Üírunning‚Üísuccess/failed) to trigger stage-level Slack updates and downstream workflows."
      },
      {
        "event_type": "deployment.production_completed",
        "description": "Listen for successful production deployments to trigger the full release workflow: Jira ticket creation, release notes compilation, email distribution, and metrics ledger update."
      },
      {
        "event_type": "pipeline.consecutive_failures",
        "description": "Listen for 3+ consecutive pipeline failures on the same protected branch to trigger escalation: Jira bug ticket creation and engineering lead notification."
      },
      {
        "event_type": "metrics.weekly_digest",
        "description": "Listen for the weekly schedule trigger to compute DORA deployment frequency metrics from the ledger and distribute the digest via Slack and email."
      }
    ],
    "use_case_flows": [
      {
        "id": "flow_pipeline_monitoring",
        "name": "Pipeline Monitoring & Slack Updates",
        "description": "Monitors GitLab pipeline events and posts threaded stage-by-stage updates to Slack channels with status-appropriate formatting.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "GitLab Webhook Fires",
            "detail": "Pipeline event received via webhook (or detected via polling fallback)"
          },
          {
            "id": "n2",
            "type": "action",
            "label": "Parse Pipeline Event",
            "detail": "Extract project, branch, pipeline ID, status, stages, commit info, author from webhook payload"
          },
          {
            "id": "n3",
            "type": "action",
            "label": "Load State Files",
            "detail": "Read pipeline_state.json and slack_threads.json to get previous status and existing thread_ts"
          },
          {
            "id": "n4",
            "type": "decision",
            "label": "New Pipeline?",
            "detail": "Check if this pipeline ID already has a Slack thread or is a new pipeline run"
          },
          {
            "id": "n5",
            "type": "connector",
            "label": "Post New Pipeline Message",
            "detail": "POST chat.postMessage with initial pipeline status using Block Kit formatting",
            "connector": "slack"
          },
          {
            "id": "n6",
            "type": "action",
            "label": "Save Thread ID",
            "detail": "Store the returned thread_ts mapped to pipeline_id in slack_threads.json"
          },
          {
            "id": "n7",
            "type": "connector",
            "label": "Post Stage Update in Thread",
            "detail": "POST chat.postMessage with thread_ts to add stage status update to existing thread",
            "connector": "slack"
          },
          {
            "id": "n8",
            "type": "decision",
            "label": "Pipeline Failed?",
            "detail": "Check if the pipeline status is 'failed' and if the branch is protected"
          },
          {
            "id": "n9",
            "type": "connector",
            "label": "Fetch Failure Logs",
            "detail": "GET /api/v4/projects/{id}/jobs/{jid}/trace to retrieve first 20 lines of failure output",
            "connector": "gitlab"
          },
          {
            "id": "n10",
            "type": "connector",
            "label": "Post Failure Alert",
            "detail": "POST chat.postMessage with high-priority formatting, failure logs, and @mention of commit author",
            "connector": "slack"
          },
          {
            "id": "n11",
            "type": "action",
            "label": "Update Pipeline State",
            "detail": "Write updated pipeline status to pipeline_state.json via file_write"
          },
          {
            "id": "n12",
            "type": "end",
            "label": "Processing Complete",
            "detail": "Pipeline event fully processed, state saved"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4"
          },
          {
            "id": "e4",
            "source": "n4",
            "target": "n5",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e5",
            "source": "n4",
            "target": "n7",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n8"
          },
          {
            "id": "e8",
            "source": "n7",
            "target": "n8"
          },
          {
            "id": "e9",
            "source": "n8",
            "target": "n9",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e10",
            "source": "n8",
            "target": "n11",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e11",
            "source": "n9",
            "target": "n10"
          },
          {
            "id": "e12",
            "source": "n10",
            "target": "n11"
          },
          {
            "id": "e13",
            "source": "n11",
            "target": "n12"
          }
        ]
      },
      {
        "id": "flow_production_release",
        "name": "Production Deploy ‚Üí Jira + Release Notes + Email",
        "description": "When a production deployment succeeds, creates a Jira deployment ticket, compiles release notes from commits, emails stakeholders, and posts to the releases channel.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Production Deploy Detected",
            "detail": "Pipeline on main/master/release branch succeeds with deploy stage targeting production"
          },
          {
            "id": "n2",
            "type": "connector",
            "label": "Fetch Latest Tags",
            "detail": "GET /api/v4/projects/{id}/repository/tags to determine current and previous release versions",
            "connector": "gitlab"
          },
          {
            "id": "n3",
            "type": "connector",
            "label": "Fetch Commit Range",
            "detail": "GET /api/v4/projects/{id}/repository/compare?from={prev_tag}&to={new_tag} for all commits in this release",
            "connector": "gitlab"
          },
          {
            "id": "n4",
            "type": "action",
            "label": "Compile Release Notes",
            "detail": "Parse commit messages, extract Jira issue keys, group by type (feat/fix/chore), format as HTML and markdown"
          },
          {
            "id": "n5",
            "type": "connector",
            "label": "Search Existing Tickets",
            "detail": "GET /rest/api/3/search?jql=summary~'{version}' to check for duplicate deployment tickets",
            "connector": "jira"
          },
          {
            "id": "n6",
            "type": "decision",
            "label": "Ticket Exists?",
            "detail": "Check if a deployment ticket for this version already exists in Jira"
          },
          {
            "id": "n7",
            "type": "connector",
            "label": "Create Deploy Ticket",
            "detail": "POST /rest/api/3/issue with deployment summary, version, environment, commit range, and linked Jira issues",
            "connector": "jira"
          },
          {
            "id": "n8",
            "type": "connector",
            "label": "Update Existing Ticket",
            "detail": "POST /rest/api/3/issue/{key}/comment to add deployment confirmation to existing ticket",
            "connector": "jira"
          },
          {
            "id": "n9",
            "type": "connector",
            "label": "Email Release Notes",
            "detail": "gmail_send HTML-formatted release notes to stakeholder distribution list with version in subject",
            "connector": "google_workspace"
          },
          {
            "id": "n10",
            "type": "connector",
            "label": "Post Release Announcement",
            "detail": "POST chat.postMessage to #releases with deploy summary, version, commit count, contributors",
            "connector": "slack"
          },
          {
            "id": "n11",
            "type": "action",
            "label": "Update Deploy Ledger",
            "detail": "Append { timestamp, project, version, duration, author, commit_count } to deploy_ledger.json"
          },
          {
            "id": "n12",
            "type": "action",
            "label": "Update Last Deploy Tag",
            "detail": "Write current version tag to last_deploy_tags.json for next release comparison"
          },
          {
            "id": "n13",
            "type": "event",
            "label": "Emit Deploy Event",
            "detail": "Emit deployment.production_completed event for downstream subscribers"
          },
          {
            "id": "n14",
            "type": "end",
            "label": "Release Workflow Complete",
            "detail": "All artifacts created: Jira ticket, email sent, Slack posted, ledger updated"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4"
          },
          {
            "id": "e4",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e5",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e6",
            "source": "n6",
            "target": "n8",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e8",
            "source": "n7",
            "target": "n9"
          },
          {
            "id": "e9",
            "source": "n8",
            "target": "n9"
          },
          {
            "id": "e10",
            "source": "n9",
            "target": "n10"
          },
          {
            "id": "e11",
            "source": "n10",
            "target": "n11"
          },
          {
            "id": "e12",
            "source": "n11",
            "target": "n12"
          },
          {
            "id": "e13",
            "source": "n12",
            "target": "n13"
          },
          {
            "id": "e14",
            "source": "n13",
            "target": "n14"
          }
        ]
      },
      {
        "id": "flow_weekly_metrics",
        "name": "Weekly DORA Metrics Digest",
        "description": "Computes deployment frequency metrics from the local ledger on a weekly schedule and distributes the digest via Slack and email.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Weekly Schedule Fires",
            "detail": "Cron trigger fires Monday at 9:00 AM"
          },
          {
            "id": "n2",
            "type": "action",
            "label": "Load Deploy Ledger",
            "detail": "Read deploy_ledger.json via file_read to get all deployment records"
          },
          {
            "id": "n3",
            "type": "decision",
            "label": "Ledger Has Data?",
            "detail": "Check if there are any deployment records in the ledger for the metrics window"
          },
          {
            "id": "n4",
            "type": "action",
            "label": "Compute DORA Metrics",
            "detail": "Calculate: deploys/day (7d & 30d rolling), mean lead time, change failure rate from success/failure counts"
          },
          {
            "id": "n5",
            "type": "action",
            "label": "Format Metrics Report",
            "detail": "Build summary table with metrics, trend arrows (up/down vs previous week), and per-project breakdown"
          },
          {
            "id": "n6",
            "type": "connector",
            "label": "Post to Metrics Channel",
            "detail": "POST chat.postMessage to #engineering-metrics with Block Kit formatted metrics table",
            "connector": "slack"
          },
          {
            "id": "n7",
            "type": "connector",
            "label": "Email Metrics Digest",
            "detail": "gmail_send HTML metrics report to engineering manager with week-over-week comparisons",
            "connector": "google_workspace"
          },
          {
            "id": "n8",
            "type": "event",
            "label": "Emit Metrics Event",
            "detail": "Emit metrics.weekly_digest event with computed values for downstream consumers"
          },
          {
            "id": "n9",
            "type": "end",
            "label": "Digest Complete",
            "detail": "Weekly metrics digest distributed to all channels"
          },
          {
            "id": "n10",
            "type": "error",
            "label": "No Data Available",
            "detail": "Ledger is empty or corrupted ‚Äî post warning to Slack and skip email"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e4",
            "source": "n3",
            "target": "n10",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e5",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7"
          },
          {
            "id": "e8",
            "source": "n7",
            "target": "n8"
          },
          {
            "id": "e9",
            "source": "n8",
            "target": "n9"
          },
          {
            "id": "e10",
            "source": "n10",
            "target": "n9",
            "variant": "error"
          }
        ]
      }
    ],
    "customSections": []
  }
}
