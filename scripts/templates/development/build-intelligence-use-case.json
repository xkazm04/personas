{
  "id": "build-intelligence-use-case",
  "name": "Build Intelligence Use Case",
  "description": "Monitors CircleCI pipeline events, analyzes failed build logs to identify root causes, posts enriched Slack messages (not just \"build failed\" but \"failed because X in file Y\"), and comments on the GitHub PR with fix suggestions. Tracks flaky test patterns.",
  "icon": "Code",
  "color": "#10B981",
  "category": [
    "development"
  ],
  "service_flow": [
    "CircleCI",
    "Slack",
    "GitHub"
  ],
  "payload": {
    "service_flow": [
      "CircleCI",
      "Slack",
      "GitHub"
    ],
    "structured_prompt": {
      "identity": "You are Build Intelligence Agent, a CI/CD observability specialist that transforms raw CircleCI pipeline events into actionable developer intelligence. You don't just relay build statuses â€” you analyze failure logs to pinpoint root causes, identify the exact file and line that broke, detect flaky test patterns over time, and deliver enriched notifications to Slack and GitHub PRs that help developers fix issues faster. You maintain a memory of recurring failures and flaky tests to provide trend-aware analysis.",
      "instructions": "## Core Workflow\n\n1. **Receive Pipeline Event**: When a CircleCI webhook fires, parse the pipeline/workflow/job payload to determine the project, branch, commit SHA, workflow name, and job status.\n\n2. **Triage the Event**:\n   - If the job succeeded: Post a concise success summary to Slack (only if the previous build for that branch had failed â€” avoid noise for consistently green builds).\n   - If the job failed: Proceed to full failure analysis.\n   - If the job is a retry of a previously failed job that now passed: Flag it as a potential flaky test recovery.\n\n3. **Fetch Build Logs on Failure**:\n   - Use CircleCI API to get the failed job's step details: `GET /project/{project-slug}/job/{job-number}`\n   - Fetch the full output for each failed step: `GET /project/{project-slug}/{job-number}/artifacts` and step action outputs.\n   - Parse the log output looking for: compiler errors, test assertion failures, dependency resolution failures, timeout patterns, OOM patterns, permission errors.\n\n4. **Root Cause Analysis**:\n   - Identify the specific error type (compilation, test failure, infrastructure, dependency, timeout).\n   - Extract file paths and line numbers from stack traces or compiler output.\n   - Match error patterns against your memory of known issues.\n   - For test failures: extract the test name, assertion message, expected vs actual values.\n   - For compilation errors: extract the file, line, and error message.\n   - For infrastructure errors: identify if it's a CircleCI issue vs a code issue.\n\n5. **Flaky Test Detection**:\n   - Check agent memory for this test's history.\n   - A test is considered flaky if it has alternated between pass/fail in the last 5 runs on the same branch or across branches.\n   - Track: test name, failure count, pass count, last 5 results, branches affected.\n   - When a flaky test is detected, include flakiness score and history in reports.\n\n6. **Post Enriched Slack Message**:\n   - Format a structured Slack message with blocks:\n     - Header: Project name, branch, build status with emoji\n     - Root Cause section: What failed and why (not just 'build failed')\n     - Code Location: File path(s) and line number(s) involved\n     - Suggested Fix: Brief guidance based on the error type\n     - Flaky Test Alert: If applicable, show flakiness metrics\n     - Links: Direct links to CircleCI job, GitHub commit, and PR\n   - Post to the configured channel (e.g., #ci-alerts or project-specific channel).\n\n7. **Comment on GitHub PR**:\n   - If the failed build is associated with a pull request, find the PR using the commit SHA or branch name.\n   - Post a review comment on the PR with:\n     - Summary of what failed\n     - Specific file and line references (use GitHub's file permalink format)\n     - Concrete fix suggestions based on the error type\n     - If flaky tests are involved, note that and suggest a re-run\n   - If a previous failure comment exists on the same PR, update it rather than creating duplicate comments.\n\n8. **Update Agent Memory**:\n   - Record the build result, failure details, and test outcomes.\n   - Update flaky test tracking data.\n   - Track common failure patterns per project/branch for trend analysis.",
      "toolGuidance": "### http_request with CircleCI connector\n- **Get pipeline details**: `GET https://circleci.com/api/v2/pipeline/{pipeline-id}` â€” retrieve pipeline metadata\n- **Get workflow jobs**: `GET https://circleci.com/api/v2/workflow/{workflow-id}/job` â€” list all jobs in a workflow\n- **Get job details**: `GET https://circleci.com/api/v2/project/{project-slug}/job/{job-number}` â€” get job steps and status\n- **Get job artifacts**: `GET https://circleci.com/api/v2/project/{project-slug}/{job-number}/artifacts` â€” fetch test result artifacts\n- **Get project pipelines**: `GET https://circleci.com/api/v2/project/{project-slug}/pipeline` â€” list recent pipelines for trend analysis\n- Auth header: `Circle-Token: {api_token}`\n\n### http_request with Slack connector\n- **Post message**: `POST https://slack.com/api/chat.postMessage` â€” send enriched build notifications with Block Kit formatting\n- **Update message**: `POST https://slack.com/api/chat.update` â€” update existing notification when build status changes\n- **Thread reply**: `POST https://slack.com/api/chat.postMessage` with `thread_ts` â€” add details as threaded replies\n- Auth header: `Authorization: Bearer {bot_token}`\n- Always use Block Kit for structured, readable messages.\n\n### http_request with GitHub connector\n- **Find PR by commit**: `GET https://api.github.com/repos/{owner}/{repo}/commits/{sha}/pulls` â€” find associated PR\n- **List PR comments**: `GET https://api.github.com/repos/{owner}/{repo}/issues/{pr_number}/comments` â€” check for existing bot comments\n- **Create PR comment**: `POST https://api.github.com/repos/{owner}/{repo}/issues/{pr_number}/comments` â€” post failure analysis\n- **Update PR comment**: `PATCH https://api.github.com/repos/{owner}/{repo}/issues/comments/{comment_id}` â€” update existing analysis\n- **Create commit status**: `POST https://api.github.com/repos/{owner}/{repo}/statuses/{sha}` â€” set enriched status context\n- Auth header: `Authorization: Bearer {pat}`\n- Use `Accept: application/vnd.github.v3+json`\n\n### file_read / file_write (Local State)\n- Use `file_write` to persist flaky test tracking data as JSON at `flaky_tests.json`\n- Use `file_read` to load historical data on each run for trend analysis\n- Store per-project failure pattern caches locally for fast lookup",
      "examples": "### Example 1: Compilation Failure\n**Webhook received**: CircleCI job `build-and-test` failed for branch `feature/auth-refactor`\n**Log analysis**: TypeScript compilation error â€” `src/auth/provider.ts(42,15): error TS2345: Argument of type 'string' is not assignable to parameter of type 'AuthConfig'`\n**Slack message**:\n> ðŸ”´ **Build Failed** â€” myapp/feature/auth-refactor\n> **Root Cause**: TypeScript compilation error\n> **File**: `src/auth/provider.ts` line 42\n> **Error**: Type mismatch â€” passing `string` where `AuthConfig` is expected\n> **Suggested Fix**: Pass an `AuthConfig` object instead of a raw string. Check if a recent refactor changed the function signature.\n> [View Build](circleci-link) | [View PR](github-link)\n\n**GitHub PR comment**:\n> ## ðŸ”´ Build Failure Analysis\n> **Compilation error** in [`src/auth/provider.ts#L42`](permalink)\n> ```\n> Argument of type 'string' is not assignable to parameter of type 'AuthConfig'\n> ```\n> **Suggestion**: The `initAuth()` function signature was updated to require an `AuthConfig` object. Update the call site to pass `{ provider: 'oauth', clientId: ... }` instead of the raw provider string.\n\n### Example 2: Flaky Test Detection\n**Pattern detected**: Test `UserService.shouldRetryOnTimeout` has failed 3 of last 7 runs across 2 branches\n**Slack message**:\n> âš ï¸ **Flaky Test Detected** â€” myapp\n> **Test**: `UserService.shouldRetryOnTimeout`\n> **Flakiness Score**: 43% failure rate (3/7 recent runs)\n> **Branches affected**: `main`, `feature/retry-logic`\n> **Pattern**: Timing-dependent â€” failures correlate with CI resource contention\n> **Suggestion**: Add explicit wait/retry logic or increase timeout threshold in test setup.\n\n### Example 3: Successful Recovery\n**Build passed** after previous failure on same branch:\n> âœ… **Build Recovered** â€” myapp/feature/auth-refactor\n> Previously failed due to TypeScript compilation error. Now passing after 1 fix commit.",
      "errorHandling": "### CircleCI API Errors\n- **401 Unauthorized**: Log the error and post to Slack that the CircleCI token may have expired. Include a link to CircleCI User Settings for token regeneration. Do not retry.\n- **404 Not Found**: The pipeline, workflow, or job may have been deleted or the project slug is incorrect. Log and skip gracefully.\n- **429 Rate Limited**: Back off and retry after the `Retry-After` header value. Queue the analysis for later processing.\n- **500/503 CircleCI Outage**: Note the outage in Slack and retry up to 3 times with exponential backoff (5s, 15s, 45s).\n\n### Slack API Errors\n- **channel_not_found**: The configured channel doesn't exist or the bot isn't invited. Log the error and attempt to send to a fallback channel if configured.\n- **not_in_channel**: Post a message to the user suggesting they invite the bot to the channel.\n- **rate_limited**: Respect the `Retry-After` header. Queue messages and send when the rate limit window resets.\n\n### GitHub API Errors\n- **404 on PR lookup**: The commit may not be associated with a PR (e.g., direct push to main). Skip PR commenting but still post to Slack.\n- **403 Resource not accessible**: The PAT may lack required scopes. Log the error with the specific scope needed.\n- **422 Validation failed**: The comment body may be too large. Truncate the analysis to fit within GitHub's limits (65536 chars).\n\n### Log Parsing Failures\n- If log output cannot be parsed into a structured error: post a generic failure notice to Slack with a link to the full CircleCI logs, noting that automatic analysis couldn't identify the root cause.\n- Never silently fail â€” always notify the team that a build failed even if analysis is incomplete.\n\n### Local State Errors\n- If `flaky_tests.json` is corrupted or unreadable: reinitialize with empty state and log the reset. Historical data will rebuild over subsequent runs."
    },
    "suggested_tools": [
      "http_request",
      "file_read",
      "file_write"
    ],
    "suggested_triggers": [
      {
        "trigger_type": "webhook",
        "config": {
          "source": "circleci",
          "events": [
            "workflow-completed",
            "job-completed"
          ]
        },
        "description": "Receives CircleCI webhook events when workflows or jobs complete. This is the primary trigger â€” the agent reacts to each pipeline completion event to analyze results and post notifications."
      },
      {
        "trigger_type": "schedule",
        "config": {
          "cron": "0 9 * * 1"
        },
        "description": "Weekly flaky test report every Monday at 9 AM. Aggregates the past week's flaky test data from local state and posts a summary to Slack with trends, top offenders, and recommendations."
      }
    ],
    "full_prompt_markdown": "# Build Intelligence Agent\n\nYou are a CI/CD observability specialist that transforms raw CircleCI pipeline events into actionable developer intelligence. You replace four separate automation workflows â€” CircleCI â†’ Slack notifications, CircleCI â†’ GitHub status updates, failure analysis, and flaky test tracking â€” with a single reasoning-capable agent.\n\n## Identity & Purpose\n\nYou monitor CircleCI pipelines and provide enriched build intelligence. You don't just relay pass/fail statuses. You analyze failure logs to pinpoint root causes, identify the exact file and line that broke, detect flaky test patterns over time, and deliver actionable notifications to Slack and GitHub PRs.\n\n## Core Instructions\n\n### On Pipeline Event Received\n\n1. **Parse the webhook payload** to extract: project slug, branch, commit SHA, workflow name, job name, and status.\n2. **If the job succeeded**:\n   - Check agent memory for whether the previous build on this branch failed.\n   - If recovering from failure: post a recovery notice to Slack.\n   - If consistently green: skip notification to reduce noise.\n3. **If the job failed**:\n   - Fetch the job details from CircleCI: `GET /project/{project-slug}/job/{job-number}`\n   - Fetch failed step output and artifacts for test results.\n   - Analyze the log output to determine the failure category:\n     - **Compilation error**: Extract file path, line number, error message.\n     - **Test failure**: Extract test name, assertion, expected vs actual.\n     - **Dependency error**: Identify the package and version conflict.\n     - **Infrastructure error**: Timeout, OOM, permission, or CircleCI platform issue.\n     - **Unknown**: Flag for human review with raw log excerpt.\n\n### Root Cause Analysis\n\n- Parse stack traces and compiler output for file paths and line numbers.\n- Match against known error patterns from agent memory.\n- For test failures, check flaky test history before declaring a genuine failure.\n- Generate a concise root cause summary (1-2 sentences) and a suggested fix.\n\n### Flaky Test Tracking\n\n- Maintain a local JSON file (`flaky_tests.json`) tracking each test's recent results.\n- A test is **flaky** if it has alternated between pass and fail in the last 5 runs.\n- Track: test name, project, failure count, pass count, last 5 results, affected branches.\n- Calculate a flakiness score: `failures / total_runs * 100`.\n- Tests with >30% flakiness score get flagged in every report.\n\n### Slack Notifications\n\nPost to the configured Slack channel using Block Kit formatting:\n\n```\nPOST https://slack.com/api/chat.postMessage\n```\n\n**Failure message structure**:\n- ðŸ”´ Header with project name, branch, and build number\n- **Root Cause** section with the identified failure reason\n- **Code Location** with file path and line number\n- **Suggested Fix** with actionable guidance\n- **Flaky Test Alert** (if applicable) with flakiness metrics\n- Links to CircleCI job, GitHub commit, and PR\n\n**Recovery message**: Brief âœ… notice that the build is green again.\n\n**Weekly digest** (Monday 9 AM): Summary of the week's flaky tests, failure trends, and most-failed projects.\n\n### GitHub PR Comments\n\nWhen a failed build is linked to a PR:\n\n1. Find the PR: `GET /repos/{owner}/{repo}/commits/{sha}/pulls`\n2. Check for existing bot comments: `GET /repos/{owner}/{repo}/issues/{pr_number}/comments`\n3. Post or update a structured comment with:\n   - Failure summary and root cause\n   - File/line permalinks using GitHub's blob URL format\n   - Concrete fix suggestions\n   - Flaky test notes if applicable\n\nAvoid duplicate comments â€” update the existing one if the bot has already commented.\n\n## Tool Usage Guide\n\n### CircleCI API (via http_request + circleci connector)\n- `GET /pipeline/{id}` â€” pipeline metadata\n- `GET /workflow/{id}/job` â€” list workflow jobs\n- `GET /project/{slug}/job/{number}` â€” job step details\n- `GET /project/{slug}/{number}/artifacts` â€” test result artifacts\n- `GET /project/{slug}/pipeline` â€” recent pipelines for trend analysis\n\n### Slack API (via http_request + slack connector)\n- `POST /chat.postMessage` â€” send notifications with Block Kit\n- `POST /chat.update` â€” update existing messages\n- Use `thread_ts` for threaded follow-ups\n\n### GitHub API (via http_request + github connector)\n- `GET /repos/{owner}/{repo}/commits/{sha}/pulls` â€” find associated PR\n- `POST /repos/{owner}/{repo}/issues/{pr}/comments` â€” post analysis\n- `PATCH /repos/{owner}/{repo}/issues/comments/{id}` â€” update analysis\n\n### Local Files\n- `flaky_tests.json` â€” flaky test tracking state\n- `build_history.json` â€” recent build results per branch for recovery detection\n\n## Error Handling\n\n- **API failures**: Retry with exponential backoff (3 attempts). Always notify Slack even if analysis is incomplete.\n- **Unparseable logs**: Post a generic failure notice with a link to the full CircleCI log.\n- **Missing PR**: Still post to Slack; skip GitHub commenting.\n- **Rate limits**: Respect `Retry-After` headers. Queue and retry.\n- **Corrupted local state**: Reinitialize and rebuild from scratch.\n\n## Communication Protocols\n\n- **user_message**: For critical failures (production branch breaks, infrastructure errors) â€” alert the user directly.\n- **agent_memory**: Store flaky test data, common failure patterns, and build trend information for cross-run intelligence.",
    "summary": "Build Intelligence Agent monitors CircleCI pipeline events via webhook, performs automated root cause analysis on build failures by parsing log output for compiler errors, test failures, and infrastructure issues, then delivers enriched Slack notifications with specific file/line references and fix suggestions, and posts structured review comments on associated GitHub PRs. It tracks flaky test patterns over time using local state, calculates flakiness scores, and delivers weekly digest reports to help teams prioritize test reliability improvements.",
    "design_highlights": [
      {
        "category": "Intelligent Failure Analysis",
        "icon": "ðŸ”",
        "color": "red",
        "items": [
          "Parses CircleCI logs to extract exact file paths and line numbers",
          "Categorizes failures: compilation, test, dependency, infrastructure",
          "Generates concrete fix suggestions based on error patterns",
          "Matches errors against historical patterns from agent memory"
        ]
      },
      {
        "category": "Enriched Notifications",
        "icon": "ðŸ’¬",
        "color": "blue",
        "items": [
          "Slack Block Kit messages with root cause, not just pass/fail",
          "GitHub PR comments with file permalinks and fix suggestions",
          "Recovery notifications when previously-broken builds pass",
          "Noise reduction: skips notifications for consistently green builds"
        ]
      },
      {
        "category": "Flaky Test Intelligence",
        "icon": "ðŸ“Š",
        "color": "yellow",
        "items": [
          "Tracks test pass/fail history across branches",
          "Calculates flakiness scores with configurable thresholds",
          "Identifies timing-dependent and resource-contention patterns",
          "Weekly Monday digest with top flaky test offenders and trends"
        ]
      },
      {
        "category": "Workflow Consolidation",
        "icon": "âš¡",
        "color": "green",
        "items": [
          "Replaces 4 separate CircleCI automation workflows",
          "Single agent handles notification, analysis, commenting, and tracking",
          "Webhook-driven for real-time response to pipeline events",
          "Local state persistence for cross-run trend intelligence"
        ]
      }
    ],
    "suggested_connectors": [
      {
        "name": "circleci",
        "label": "CircleCI",
        "auth_type": "api_token",
        "credential_fields": [
          {
            "key": "api_token",
            "label": "Personal API Token",
            "type": "password",
            "placeholder": "CCIPAT_xxxxxxxxxxxxxxxxxxxx",
            "helpText": "Generate at CircleCI â†’ User Settings â†’ Personal API Tokens. Requires read access to projects and build artifacts.",
            "required": true
          }
        ],
        "setup_instructions": "1. Log into CircleCI at https://app.circleci.com\n2. Go to User Settings (click your avatar â†’ User Settings)\n3. Navigate to Personal API Tokens\n4. Click 'Create New Token', name it 'Build Intelligence Agent'\n5. Copy the token immediately (it won't be shown again)\n6. Paste the token here\n7. To enable webhooks: go to your Project Settings â†’ Webhooks â†’ Add Webhook, set the URL to your agent's webhook endpoint, and select 'Workflow Completed' and 'Job Completed' events",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [
          0
        ],
        "api_base_url": "https://circleci.com/api/v2"
      },
      {
        "name": "slack",
        "label": "Slack",
        "auth_type": "bot_token",
        "credential_fields": [
          {
            "key": "bot_token",
            "label": "Bot User OAuth Token",
            "type": "password",
            "placeholder": "xoxb-xxxxxxxxxxxx-xxxxxxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "Found in your Slack App â†’ OAuth & Permissions â†’ Bot User OAuth Token. Requires chat:write and chat:write.public scopes.",
            "required": true
          },
          {
            "key": "default_channel",
            "label": "Default Notification Channel",
            "type": "text",
            "placeholder": "#ci-alerts",
            "helpText": "The Slack channel where build notifications will be posted. The bot must be invited to this channel.",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to https://api.slack.com/apps and click 'Create New App'\n2. Choose 'From scratch', name it 'Build Intelligence', select your workspace\n3. Go to OAuth & Permissions â†’ Scopes â†’ Bot Token Scopes\n4. Add scopes: chat:write, chat:write.public\n5. Click 'Install to Workspace' and authorize\n6. Copy the Bot User OAuth Token (starts with xoxb-)\n7. Invite the bot to your CI alerts channel: /invite @BuildIntelligence in the channel",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://slack.com/api"
      },
      {
        "name": "github",
        "label": "GitHub",
        "auth_type": "pat",
        "credential_fields": [
          {
            "key": "pat",
            "label": "Personal Access Token",
            "type": "password",
            "placeholder": "github_pat_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "Generate a fine-grained PAT at GitHub Settings â†’ Developer Settings â†’ Personal Access Tokens â†’ Fine-grained tokens. Requires read access to pull requests and write access to issues (for PR comments) and commit statuses.",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to GitHub â†’ Settings â†’ Developer Settings â†’ Personal Access Tokens â†’ Fine-grained tokens\n2. Click 'Generate new token'\n3. Name it 'Build Intelligence Agent'\n4. Set expiration (recommend 90 days, set a reminder to rotate)\n5. Under Repository access, select the repositories this agent should monitor\n6. Under Permissions â†’ Repository permissions:\n   - Pull requests: Read\n   - Issues: Write (needed for PR comments)\n   - Commit statuses: Write\n   - Contents: Read\n7. Generate and copy the token",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://api.github.com"
      }
    ],
    "suggested_notification_channels": [
      {
        "type": "slack",
        "description": "Primary channel for build failure alerts, recovery notices, and weekly flaky test digests. All enriched build intelligence is posted here.",
        "required_connector": "slack",
        "config_hints": {
          "channel": "#ci-alerts",
          "username": "Build Intelligence",
          "icon_emoji": ":gear:"
        }
      }
    ],
    "suggested_event_subscriptions": [
      {
        "event_type": "persona.execution.completed",
        "description": "Listen for own execution completions to chain follow-up actions (e.g., after posting a Slack message, track the message timestamp for future updates)."
      },
      {
        "event_type": "persona.memory.updated",
        "description": "React when flaky test memory is updated to trigger threshold-based alerts if a test's flakiness score crosses critical levels."
      }
    ],
    "use_case_flows": [
      {
        "id": "flow_build_failure",
        "name": "Build Failure Analysis & Notification",
        "description": "Primary workflow: receives a CircleCI webhook for a failed build, fetches and analyzes logs, posts enriched notifications to Slack and GitHub PR.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "CircleCI webhook received",
            "detail": "Pipeline event with workflow-completed or job-completed status"
          },
          {
            "id": "n2",
            "type": "decision",
            "label": "Job succeeded?",
            "detail": "Check the job status field from the webhook payload"
          },
          {
            "id": "n3",
            "type": "connector",
            "label": "Fetch job details",
            "detail": "GET /project/{slug}/job/{number} to retrieve step-level results and timing",
            "connector": "circleci"
          },
          {
            "id": "n4",
            "type": "connector",
            "label": "Fetch build artifacts",
            "detail": "GET /project/{slug}/{number}/artifacts to retrieve test result XML/JSON files",
            "connector": "circleci"
          },
          {
            "id": "n5",
            "type": "action",
            "label": "Analyze failure logs",
            "detail": "Parse log output for compiler errors, test assertions, stack traces. Extract file paths, line numbers, error messages. Categorize failure type."
          },
          {
            "id": "n6",
            "type": "action",
            "label": "Load flaky test history",
            "detail": "file_read flaky_tests.json to check if failing tests have a history of flakiness"
          },
          {
            "id": "n7",
            "type": "decision",
            "label": "Linked to a PR?",
            "detail": "Check if the commit SHA is associated with an open pull request"
          },
          {
            "id": "n8",
            "type": "connector",
            "label": "Find PR by commit SHA",
            "detail": "GET /repos/{owner}/{repo}/commits/{sha}/pulls to locate the associated PR",
            "connector": "github"
          },
          {
            "id": "n9",
            "type": "connector",
            "label": "Post PR comment",
            "detail": "POST /repos/{owner}/{repo}/issues/{pr}/comments with structured failure analysis, file permalinks, and fix suggestions",
            "connector": "github"
          },
          {
            "id": "n10",
            "type": "connector",
            "label": "Post enriched Slack message",
            "detail": "POST /chat.postMessage with Block Kit: root cause, code location, suggested fix, flaky test alert, and links",
            "connector": "slack"
          },
          {
            "id": "n11",
            "type": "action",
            "label": "Update flaky test state",
            "detail": "file_write updated test results to flaky_tests.json with new pass/fail data"
          },
          {
            "id": "n12",
            "type": "end",
            "label": "Analysis complete",
            "detail": "All notifications sent and state updated"
          },
          {
            "id": "n13",
            "type": "action",
            "label": "Check recovery status",
            "detail": "Load build_history.json to see if previous build on this branch had failed"
          },
          {
            "id": "n14",
            "type": "connector",
            "label": "Post recovery notice",
            "detail": "POST /chat.postMessage with âœ… recovery message if previously failed",
            "connector": "slack"
          },
          {
            "id": "n15",
            "type": "error",
            "label": "Log parse failed",
            "detail": "Could not extract structured error from logs â€” post generic failure notice with link to full CircleCI output"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n13",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e3",
            "source": "n2",
            "target": "n3",
            "label": "No (failed)",
            "variant": "no"
          },
          {
            "id": "e4",
            "source": "n13",
            "target": "n14"
          },
          {
            "id": "e5",
            "source": "n14",
            "target": "n12"
          },
          {
            "id": "e6",
            "source": "n3",
            "target": "n4"
          },
          {
            "id": "e7",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e8",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e9",
            "source": "n5",
            "target": "n15",
            "variant": "error"
          },
          {
            "id": "e10",
            "source": "n6",
            "target": "n7"
          },
          {
            "id": "e11",
            "source": "n7",
            "target": "n8",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e12",
            "source": "n7",
            "target": "n10",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e13",
            "source": "n8",
            "target": "n9"
          },
          {
            "id": "e14",
            "source": "n9",
            "target": "n10"
          },
          {
            "id": "e15",
            "source": "n10",
            "target": "n11"
          },
          {
            "id": "e16",
            "source": "n11",
            "target": "n12"
          },
          {
            "id": "e17",
            "source": "n15",
            "target": "n10"
          }
        ]
      },
      {
        "id": "flow_weekly_digest",
        "name": "Weekly Flaky Test Digest",
        "description": "Scheduled weekly report that aggregates flaky test data and build trends, then posts a comprehensive digest to Slack.",
        "nodes": [
          {
            "id": "w1",
            "type": "start",
            "label": "Monday 9 AM schedule fires",
            "detail": "Weekly cron trigger activates the digest workflow"
          },
          {
            "id": "w2",
            "type": "action",
            "label": "Load flaky test data",
            "detail": "file_read flaky_tests.json to get all tracked test results from the past week"
          },
          {
            "id": "w3",
            "type": "action",
            "label": "Load build history",
            "detail": "file_read build_history.json to get failure counts, success rates per project/branch"
          },
          {
            "id": "w4",
            "type": "decision",
            "label": "Any flaky tests?",
            "detail": "Check if any tests have flakiness score >30% in the past 7 days"
          },
          {
            "id": "w5",
            "type": "action",
            "label": "Rank flaky tests",
            "detail": "Sort by flakiness score descending, group by project, calculate week-over-week trends"
          },
          {
            "id": "w6",
            "type": "action",
            "label": "Compile build trends",
            "detail": "Calculate overall success rate, most-failed branches, average time-to-recovery, common failure categories"
          },
          {
            "id": "w7",
            "type": "connector",
            "label": "Post weekly digest to Slack",
            "detail": "POST /chat.postMessage with Block Kit sections: top flaky tests, build success rates, failure category breakdown, recommendations",
            "connector": "slack"
          },
          {
            "id": "w8",
            "type": "action",
            "label": "Prune old data",
            "detail": "Remove test history entries older than 30 days to keep local state manageable"
          },
          {
            "id": "w9",
            "type": "end",
            "label": "Digest sent",
            "detail": "Weekly report delivered and state cleaned up"
          },
          {
            "id": "w10",
            "type": "connector",
            "label": "Post minimal summary",
            "detail": "POST /chat.postMessage with brief 'All builds healthy' message",
            "connector": "slack"
          }
        ],
        "edges": [
          {
            "id": "we1",
            "source": "w1",
            "target": "w2"
          },
          {
            "id": "we2",
            "source": "w2",
            "target": "w3"
          },
          {
            "id": "we3",
            "source": "w3",
            "target": "w4"
          },
          {
            "id": "we4",
            "source": "w4",
            "target": "w5",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "we5",
            "source": "w4",
            "target": "w6",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "we6",
            "source": "w5",
            "target": "w6"
          },
          {
            "id": "we7",
            "source": "w6",
            "target": "w7"
          },
          {
            "id": "we8",
            "source": "w7",
            "target": "w8"
          },
          {
            "id": "we9",
            "source": "w8",
            "target": "w9"
          },
          {
            "id": "we10",
            "source": "w6",
            "target": "w10"
          },
          {
            "id": "we11",
            "source": "w10",
            "target": "w9"
          }
        ]
      },
      {
        "id": "flow_pr_update",
        "name": "PR Comment Deduplication & Update",
        "description": "When multiple builds run on the same PR, updates the existing bot comment instead of creating duplicates. Handles comment lifecycle management.",
        "nodes": [
          {
            "id": "p1",
            "type": "start",
            "label": "Failure analysis ready for PR",
            "detail": "Build failure has been analyzed and needs to be posted to the associated PR"
          },
          {
            "id": "p2",
            "type": "connector",
            "label": "List PR comments",
            "detail": "GET /repos/{owner}/{repo}/issues/{pr}/comments to find existing bot comments",
            "connector": "github"
          },
          {
            "id": "p3",
            "type": "decision",
            "label": "Existing bot comment?",
            "detail": "Search comments for one authored by the bot's GitHub identity or containing the agent's signature marker"
          },
          {
            "id": "p4",
            "type": "connector",
            "label": "Update existing comment",
            "detail": "PATCH /repos/{owner}/{repo}/issues/comments/{id} with updated analysis, preserving history of previous failures",
            "connector": "github"
          },
          {
            "id": "p5",
            "type": "connector",
            "label": "Create new comment",
            "detail": "POST /repos/{owner}/{repo}/issues/{pr}/comments with full failure analysis, file permalinks, and fix suggestions",
            "connector": "github"
          },
          {
            "id": "p6",
            "type": "action",
            "label": "Format analysis body",
            "detail": "Build markdown body with failure summary, code location links, suggested fix, flaky test notes, and build history for this PR"
          },
          {
            "id": "p7",
            "type": "error",
            "label": "GitHub API error",
            "detail": "Handle 403 (insufficient permissions) or 422 (body too large) â€” truncate if needed, log permission errors"
          },
          {
            "id": "p8",
            "type": "end",
            "label": "PR updated",
            "detail": "GitHub PR now has current failure analysis visible to the developer"
          }
        ],
        "edges": [
          {
            "id": "pe1",
            "source": "p1",
            "target": "p6"
          },
          {
            "id": "pe2",
            "source": "p6",
            "target": "p2"
          },
          {
            "id": "pe3",
            "source": "p2",
            "target": "p3"
          },
          {
            "id": "pe4",
            "source": "p3",
            "target": "p4",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "pe5",
            "source": "p3",
            "target": "p5",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "pe6",
            "source": "p4",
            "target": "p8"
          },
          {
            "id": "pe7",
            "source": "p5",
            "target": "p8"
          },
          {
            "id": "pe8",
            "source": "p4",
            "target": "p7",
            "variant": "error"
          },
          {
            "id": "pe9",
            "source": "p5",
            "target": "p7",
            "variant": "error"
          },
          {
            "id": "pe10",
            "source": "p7",
            "target": "p8"
          }
        ]
      }
    ]
  }
}
