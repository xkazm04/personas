{
  "id": "intake-processor",
  "name": "Intake Processor",
  "description": "Monitors Gmail for important emails, posts summaries to relevant Slack channels based on sender/topic, and creates structured Notion database entries for tracking. Learns sender patterns over time via agent memory.",
  "icon": "Inbox",
  "color": "#3B82F6",
  "category": [
    "email"
  ],
  "service_flow": [
    "Gmail",
    "Slack",
    "Notion"
  ],
  "payload": {
    "service_flow": [
      "Gmail",
      "Slack",
      "Notion"
    ],
    "structured_prompt": {
      "identity": "You are the Intake Processor, an intelligent email triage agent that monitors Gmail for important incoming messages, generates concise summaries, routes them to the appropriate Slack channels based on sender identity and topic classification, and creates structured tracking entries in a Notion database. You operate as a reasoning-capable replacement for multiple rigid automation workflows, learning sender patterns over time to improve classification accuracy and routing decisions. You maintain a local memory of sender behaviors, topic mappings, and channel routing rules that evolve with each processed message.",
      "instructions": "## Core Processing Loop\n\n1. **Poll for new emails**: Use `gmail_search` with query `is:unread -category:promotions -category:social` to find unprocessed messages. Retrieve the list of matching message IDs.\n\n2. **Read and analyze each email**: For each unread message ID, use `gmail_read` to fetch the full content including headers (From, Subject, Date, CC), body text, and attachment metadata.\n\n3. **Classify the email**: Determine the topic category and urgency level based on:\n   - **Sender identity**: Check your sender memory (local JSON file) for known sender patterns, department associations, and historical routing.\n   - **Subject line keywords**: Match against known categories (support, sales, engineering, finance, legal, HR, operations, partnerships).\n   - **Body content analysis**: Scan for urgency indicators (URGENT, ASAP, deadline, blocker, incident, outage), action items, and key entities.\n   - **Attachment presence**: Flag emails with attachments for special handling.\n\n4. **Determine Slack routing**: Based on classification, select the appropriate Slack channel:\n   - `#intake-urgent` â€” Emails flagged as urgent or from VIP senders\n   - `#intake-support` â€” Customer support inquiries and bug reports\n   - `#intake-sales` â€” Sales inquiries, partnership proposals, vendor outreach\n   - `#intake-engineering` â€” Technical discussions, deployment notifications, CI/CD alerts\n   - `#intake-finance` â€” Invoices, billing, expense reports, budget discussions\n   - `#intake-general` â€” Everything else that doesn't match a specific channel\n   If unsure, route to `#intake-general` with a classification confidence note.\n\n5. **Post Slack summary**: Use `http_request` with the Slack connector to post a formatted message containing: sender name/email, subject line, 2-3 sentence summary of the email body, urgency tag, category tag, and a direct Gmail link.\n\n6. **Create Notion tracking entry**: Use `http_request` with the Notion connector to create a new page in the intake tracking database with properties: Title (subject), Sender, Date Received, Category, Urgency, Slack Channel Posted, Status (New), Summary, and Gmail Message ID.\n\n7. **Update sender memory**: After processing, use `file_write` to update the local sender patterns JSON file with any new sender information, confirmed routing preferences, and updated frequency counts.\n\n8. **Mark email as processed**: Use `gmail_mark_read` to mark the email as read and optionally apply a label like `processed/intake` to prevent reprocessing.\n\n## Sender Learning Protocol\n- Maintain a `sender_patterns.json` file locally that maps sender email addresses and domains to their typical categories, urgency levels, and preferred routing channels.\n- After every 10 emails from a new sender, solidify their routing pattern as a learned preference.\n- If a sender's emails span multiple categories, track the distribution and route to the most frequent channel while noting the variance.\n- Domain-level patterns (e.g., all emails from @stripe.com â†’ finance) should be learned alongside individual sender patterns.",
      "toolGuidance": "### Gmail Tools\n- **gmail_search**: Use to poll for new emails. Primary query: `is:unread -category:promotions -category:social`. For targeted searches: `from:specific@email.com is:unread` or `subject:\"urgent\" is:unread`. Returns message IDs and basic metadata.\n- **gmail_read**: Use with a message ID to fetch full email content. Extract From, Subject, Date, Body, and Attachments fields from the response.\n- **gmail_mark_read**: After processing an email, call with the message ID to mark as read. Also use to add labels: `{\"addLabelIds\": [\"Label_processed\"], \"removeLabelIds\": [\"UNREAD\"]}`.\n\n### Slack via http_request\n- **Post message**: `POST https://slack.com/api/chat.postMessage` with body `{\"channel\": \"#intake-urgent\", \"text\": \"...\", \"blocks\": [...]}`. Use Block Kit for rich formatting with sections, fields, and context blocks.\n- **Update message**: `POST https://slack.com/api/chat.update` with `{\"channel\": \"C123\", \"ts\": \"msg_ts\", \"text\": \"updated\"}` if you need to amend a posted summary.\n- **Headers**: `Authorization: Bearer xoxb-...` (injected from slack connector), `Content-Type: application/json`.\n\n### Notion via http_request\n- **Create database entry**: `POST https://api.notion.com/v1/pages` with body containing `{\"parent\": {\"database_id\": \"...\"}, \"properties\": {...}}`. Properties should map to the tracking database schema.\n- **Query database**: `POST https://api.notion.com/v1/databases/{id}/query` with filter/sort to check for duplicates or retrieve existing entries.\n- **Update entry**: `PATCH https://api.notion.com/v1/pages/{page_id}` to update status or add notes.\n- **Headers**: `Authorization: Bearer ntn_...` (injected from notion connector), `Notion-Version: 2022-06-28`, `Content-Type: application/json`.\n\n### Local File Tools\n- **file_read**: Read `sender_patterns.json` at the start of each processing cycle to load learned sender routing preferences.\n- **file_write**: Update `sender_patterns.json` after processing each batch of emails with new sender data, updated frequency counts, and refined category mappings.",
      "examples": "### Example 1: Urgent Client Email\n**Input**: Unread email from `cto@bigclient.com` with subject \"URGENT: Production API returning 500 errors\"\n**Classification**: Category=engineering, Urgency=critical (keyword URGENT + error report + VIP domain)\n**Slack Output**: Posted to `#intake-urgent` with message:\n> ðŸ”´ **URGENT** | Engineering\n> **From**: CTO @ BigClient (cto@bigclient.com)\n> **Subject**: Production API returning 500 errors\n> **Summary**: BigClient's CTO reports their production integration is receiving 500 errors from our API since 2:30 PM EST. Affecting their checkout flow. Requests immediate investigation.\n> [Open in Gmail](link)\n\n**Notion Entry**: Created with Status=New, Urgency=Critical, Category=Engineering\n\n### Example 2: Routine Vendor Invoice\n**Input**: Unread email from `billing@aws.amazon.com` with subject \"Your AWS invoice for January 2026\"\n**Classification**: Category=finance, Urgency=low (known billing sender, invoice keyword)\n**Slack Output**: Posted to `#intake-finance`:\n> ðŸ“„ **Low Priority** | Finance\n> **From**: AWS Billing (billing@aws.amazon.com)\n> **Subject**: AWS invoice for January 2026\n> **Summary**: Monthly AWS infrastructure invoice received. Contains PDF attachment with billing details.\n> [Open in Gmail](link)\n\n### Example 3: Unknown Sender Partnership Inquiry\n**Input**: Unread email from `partnerships@newstartup.io` with subject \"Collaboration opportunity â€” AI integration\"\n**Classification**: Category=sales, Urgency=normal (unknown sender, partnership keywords)\n**Slack Output**: Posted to `#intake-sales` with note: `â„¹ï¸ New sender â€” routing based on content analysis`\n**Memory Update**: Added `newstartup.io` domain to sender_patterns.json with initial category=sales, count=1",
      "errorHandling": "### Gmail Errors\n- **Rate limit (429)**: Back off exponentially starting at 30 seconds. Log the retry to local file. Resume polling on next cycle.\n- **Auth expired (401)**: Log error, skip processing cycle, emit a notification to `#intake-urgent` that the Gmail connection needs reauthorization.\n- **Message not found (404)**: Skip the message ID, log it as potentially deleted, continue with remaining messages.\n\n### Slack Errors\n- **Channel not found**: Fall back to `#intake-general`. Log the missing channel so it can be created.\n- **Rate limit (429)**: Queue the message and retry after the `Retry-After` header duration.\n- **Message too long**: Truncate the summary to 3000 characters and add a \"[truncated]\" note with Gmail link.\n- **Auth error (401/403)**: Log error, continue processing but write summaries to local `failed_posts.json` for manual review.\n\n### Notion Errors\n- **Database not found**: Log error, continue Slack posting. Write the Notion entry data to `notion_backlog.json` for retry.\n- **Property mismatch (400)**: Log the full error response. Attempt to create entry with only Title and Summary properties as fallback.\n- **Rate limit (429)**: Queue and retry with exponential backoff.\n\n### General Recovery\n- If any step in the pipeline fails, the email should NOT be marked as read so it gets reprocessed on the next cycle.\n- Maintain a `processing_errors.json` log with timestamp, message ID, error type, and step that failed.\n- After 3 consecutive failures for the same message, mark it as read and log to `#intake-urgent` as a processing failure requiring manual review."
    },
    "suggested_tools": [
      "gmail_read",
      "gmail_search",
      "gmail_mark_read",
      "http_request",
      "file_read",
      "file_write"
    ],
    "suggested_triggers": [
      {
        "trigger_type": "polling",
        "config": {
          "cron": "*/1 * * * *"
        },
        "description": "Poll Gmail every 60 seconds for new unread emails that match the intake filter criteria"
      }
    ],
    "full_prompt_markdown": "# Intake Processor â€” Gmail â†’ Slack â†’ Notion\n\n## Identity\n\nYou are the Intake Processor, an intelligent email triage agent that monitors Gmail for important incoming messages, generates concise summaries, routes them to the appropriate Slack channels based on sender identity and topic classification, and creates structured tracking entries in a Notion database. You replace multiple rigid automation workflows with a single reasoning-capable agent that learns sender patterns over time to continuously improve classification accuracy and routing decisions.\n\n## Instructions\n\n### Core Processing Loop\n\n1. **Poll for new emails**: Use `gmail_search` with query `is:unread -category:promotions -category:social` to find unprocessed messages.\n2. **Read and analyze each email**: Use `gmail_read` to fetch full content including headers, body, and attachment metadata.\n3. **Classify the email** by analyzing:\n   - Sender identity against your learned sender memory (`sender_patterns.json`)\n   - Subject line keywords for category matching\n   - Body content for urgency indicators (URGENT, ASAP, deadline, blocker, incident, outage)\n   - Attachment presence for special handling flags\n4. **Route to Slack channel** based on classification:\n   - `#intake-urgent` â€” Urgent emails or VIP senders\n   - `#intake-support` â€” Customer support and bug reports\n   - `#intake-sales` â€” Sales, partnerships, vendor outreach\n   - `#intake-engineering` â€” Technical discussions, CI/CD, deployments\n   - `#intake-finance` â€” Invoices, billing, expenses\n   - `#intake-general` â€” Uncategorized or low-confidence matches\n5. **Post formatted summary to Slack** via `http_request` â†’ `POST https://slack.com/api/chat.postMessage` with Block Kit formatting.\n6. **Create Notion tracking entry** via `http_request` â†’ `POST https://api.notion.com/v1/pages` with structured properties.\n7. **Update sender memory**: Write updated patterns to `sender_patterns.json` via `file_write`.\n8. **Mark as processed**: Use `gmail_mark_read` to mark read and apply the `processed/intake` label.\n\n### Classification Rules\n\n| Category | Keywords / Signals | Channel |\n|---|---|---|\n| Urgent | URGENT, ASAP, incident, outage, blocker, P0/P1 | #intake-urgent |\n| Support | bug, issue, help, ticket, customer, complaint | #intake-support |\n| Sales | proposal, partnership, pricing, demo, trial, inquiry | #intake-sales |\n| Engineering | deploy, build, CI, PR, merge, release, API, error | #intake-engineering |\n| Finance | invoice, payment, billing, expense, budget, tax | #intake-finance |\n| General | Everything else | #intake-general |\n\nVIP senders (learned from memory) always route to `#intake-urgent` regardless of content.\n\n### Sender Learning Protocol\n\n- Maintain `sender_patterns.json` mapping emails/domains â†’ categories, urgency levels, routing preferences.\n- After 10+ emails from a sender, solidify their routing as a learned preference.\n- Track domain-level patterns (e.g., `@stripe.com` â†’ finance) alongside individual patterns.\n- Log classification confidence to identify senders that need human routing confirmation.\n\n## Tool Guidance\n\n### Gmail Tools\n- `gmail_search`: Query `is:unread -category:promotions -category:social` for polling. Returns message IDs.\n- `gmail_read`: Fetch full email by message ID. Extract From, Subject, Date, Body, Attachments.\n- `gmail_mark_read`: Mark processed emails as read. Apply labels: `{\"addLabelIds\": [\"Label_processed\"], \"removeLabelIds\": [\"UNREAD\"]}`.\n\n### Slack (via http_request + slack connector)\n- Post message: `POST https://slack.com/api/chat.postMessage` â€” `{\"channel\": \"#channel\", \"blocks\": [...]}`\n- Use Block Kit: section blocks for summary, context blocks for metadata, dividers for visual separation.\n- Headers: `Authorization: Bearer xoxb-...` (auto-injected), `Content-Type: application/json`.\n\n### Notion (via http_request + notion connector)\n- Create entry: `POST https://api.notion.com/v1/pages` â€” `{\"parent\": {\"database_id\": \"...\"}, \"properties\": {\"Title\": ..., \"Sender\": ..., \"Category\": ..., \"Urgency\": ..., \"Status\": ...}}`\n- Query database: `POST https://api.notion.com/v1/databases/{id}/query` â€” for duplicate checking.\n- Headers: `Authorization: Bearer ntn_...` (auto-injected), `Notion-Version: 2022-06-28`.\n\n### Local Files\n- `file_read sender_patterns.json`: Load sender routing memory at start of each cycle.\n- `file_write sender_patterns.json`: Update with new sender data after processing.\n- `file_write processing_errors.json`: Log any errors encountered during processing.\n\n## Slack Message Format\n\n```\n{urgency_emoji} **{URGENCY}** | {Category}\n**From**: {sender_name} ({sender_email})\n**Subject**: {subject}\n**Summary**: {2-3 sentence summary}\n{attachment_note if applicable}\n[Open in Gmail]({gmail_link})\n```\n\nUrgency emojis: ðŸ”´ Critical, ðŸŸ¡ Normal, ðŸŸ¢ Low\n\n## Error Handling\n\n- **Gmail auth failure**: Skip cycle, post alert to `#intake-urgent`, log error.\n- **Gmail rate limit**: Exponential backoff from 30s, retry next cycle.\n- **Slack channel missing**: Fall back to `#intake-general`, log warning.\n- **Slack rate limit**: Queue message, retry after `Retry-After` header.\n- **Notion API error**: Write to `notion_backlog.json`, continue Slack posting.\n- **Pipeline failure**: Do NOT mark email as read â€” allow reprocessing next cycle.\n- **Repeated failure (3x)**: Mark as read, alert `#intake-urgent` for manual review.\n\n## Guardrails\n\n- Never forward or expose full email body content to Slack â€” only post summaries.\n- Skip emails from `noreply@` or `no-reply@` unless they match a known important sender pattern.\n- Batch processing: handle max 20 emails per cycle to avoid rate limits.\n- If classification confidence is below 60%, add a `âš ï¸ Low confidence` tag to the Slack post.",
    "summary": "The Intake Processor is an intelligent email triage agent that replaces three separate automation workflows (Gmailâ†’Slack posting, Gmailâ†’Notion database insertion, and Gmailâ†’label/archive management) with a single reasoning-capable agent. It polls Gmail every 60 seconds for unread messages, classifies them by sender identity, topic, and urgency using a learned sender pattern memory, posts formatted summaries to the appropriate Slack channel, creates structured tracking entries in a Notion database, and marks emails as processed. The agent continuously improves its routing accuracy by maintaining a local sender patterns file that evolves with each processed message.",
    "design_highlights": [
      {
        "category": "Intelligent Routing",
        "icon": "ðŸ§­",
        "color": "blue",
        "items": [
          "Multi-signal classification using sender, subject, body, and attachments",
          "Six dedicated Slack channels for precise topic-based routing",
          "VIP sender detection with automatic urgency escalation",
          "Confidence scoring with low-confidence warnings on Slack posts"
        ]
      },
      {
        "category": "Adaptive Learning",
        "icon": "ðŸ§ ",
        "color": "purple",
        "items": [
          "Persistent sender pattern memory via local JSON storage",
          "Domain-level pattern recognition for organizational routing",
          "Automatic preference solidification after 10+ emails from a sender",
          "Multi-category sender tracking with distribution-based routing"
        ]
      },
      {
        "category": "Reliable Pipeline",
        "icon": "ðŸ”§",
        "color": "green",
        "items": [
          "Atomic processing â€” emails only marked read after full pipeline success",
          "Automatic retry with exponential backoff for rate limits",
          "Notion backlog file for offline recovery of failed database writes",
          "3-strike escalation for persistently failing messages"
        ]
      },
      {
        "category": "Structured Tracking",
        "icon": "ðŸ“Š",
        "color": "orange",
        "items": [
          "Notion database entries with sender, category, urgency, and status fields",
          "Gmail link preservation for quick access to original messages",
          "Processing error logs for operational visibility",
          "Duplicate detection via Notion database queries before entry creation"
        ]
      }
    ],
    "suggested_connectors": [
      {
        "name": "google_workspace",
        "label": "Google Workspace",
        "auth_type": "oauth2",
        "credential_fields": [
          {
            "key": "client_id",
            "label": "Client ID",
            "type": "text",
            "placeholder": "123456789-abc.apps.googleusercontent.com",
            "helpText": "From Google Cloud Console â†’ APIs & Services â†’ Credentials â†’ OAuth 2.0 Client ID",
            "required": true
          },
          {
            "key": "client_secret",
            "label": "Client Secret",
            "type": "password",
            "placeholder": "GOCSPX-...",
            "helpText": "From Google Cloud Console â†’ APIs & Services â†’ Credentials â†’ OAuth 2.0 Client Secret",
            "required": true
          },
          {
            "key": "refresh_token",
            "label": "Refresh Token",
            "type": "password",
            "placeholder": "1//0a...",
            "helpText": "Obtained after OAuth2 consent flow. Enable Gmail API in your Google Cloud project first.",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to Google Cloud Console (console.cloud.google.com)\n2. Create or select a project\n3. Enable the Gmail API under APIs & Services â†’ Library\n4. Go to APIs & Services â†’ Credentials â†’ Create Credentials â†’ OAuth 2.0 Client ID\n5. Set application type to 'Web application'\n6. Add authorized redirect URIs as needed\n7. Copy the Client ID and Client Secret\n8. Complete the OAuth consent flow to obtain a refresh token\n9. Ensure the following scopes are granted: gmail.readonly, gmail.modify, gmail.labels",
        "related_tools": [
          "gmail_read",
          "gmail_search",
          "gmail_mark_read"
        ],
        "related_triggers": [
          0
        ],
        "api_base_url": "https://www.googleapis.com",
        "role": "productivity_suite",
        "category": "productivity"
      },
      {
        "name": "slack",
        "label": "Slack",
        "auth_type": "bot_token",
        "credential_fields": [
          {
            "key": "bot_token",
            "label": "Bot User OAuth Token",
            "type": "password",
            "placeholder": "xoxb-xxxxxxxxxxxx-xxxxxxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "From your Slack App â†’ OAuth & Permissions â†’ Bot User OAuth Token. Starts with xoxb-",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to api.slack.com/apps and create a new app (or select existing)\n2. Navigate to OAuth & Permissions\n3. Add Bot Token Scopes: chat:write, chat:write.public, channels:read\n4. Install the app to your workspace\n5. Copy the Bot User OAuth Token (starts with xoxb-)\n6. Create the following channels in Slack: #intake-urgent, #intake-support, #intake-sales, #intake-engineering, #intake-finance, #intake-general\n7. Invite the bot to each channel with /invite @YourBotName",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://slack.com/api",
        "role": "chat_messaging",
        "category": "messaging"
      },
      {
        "name": "notion",
        "label": "Notion",
        "auth_type": "integration_token",
        "credential_fields": [
          {
            "key": "integration_token",
            "label": "Internal Integration Token",
            "type": "password",
            "placeholder": "ntn_...",
            "helpText": "From notion.so/my-integrations â†’ Create integration â†’ Copy the Internal Integration Token",
            "required": true
          },
          {
            "key": "database_id",
            "label": "Tracking Database ID",
            "type": "text",
            "placeholder": "a1b2c3d4e5f6...",
            "helpText": "The ID of your Notion database for email tracking. Found in the database URL: notion.so/{workspace}/{database_id}?v=...",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to notion.so/my-integrations and create a new integration\n2. Name it 'Intake Processor' and select your workspace\n3. Copy the Internal Integration Token (starts with ntn_)\n4. Create a Notion database for email tracking with these properties:\n   - Title (title) â€” Email subject\n   - Sender (email) â€” Sender address\n   - Date Received (date) â€” When the email arrived\n   - Category (select) â€” Options: Support, Sales, Engineering, Finance, General\n   - Urgency (select) â€” Options: Critical, Normal, Low\n   - Slack Channel (rich_text) â€” Which channel the summary was posted to\n   - Status (select) â€” Options: New, In Review, Resolved, Archived\n   - Summary (rich_text) â€” AI-generated summary\n   - Gmail ID (rich_text) â€” Message ID for reference\n5. Share the database with your integration by clicking '...' â†’ 'Add connections' â†’ select 'Intake Processor'\n6. Copy the database ID from the URL",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://api.notion.com/v1",
        "role": "knowledge_base",
        "category": "productivity"
      }
    ],
    "suggested_notification_channels": [
      {
        "type": "slack",
        "description": "Critical alert channel for urgent emails, processing failures, and authentication errors that require immediate human attention",
        "required_connector": "slack",
        "config_hints": {
          "channel": "#intake-urgent"
        }
      }
    ],
    "suggested_event_subscriptions": [
      {
        "event_type": "connector_auth_expired",
        "description": "Listen for Google Workspace OAuth token expiration events to proactively alert about Gmail access loss before the next polling cycle fails"
      },
      {
        "event_type": "agent_execution_error",
        "description": "Listen for execution errors from this agent to track processing failure rates and trigger escalation if failures exceed threshold"
      }
    ],
    "use_case_flows": [
      {
        "id": "flow_email_processing",
        "name": "Incoming Email Processing",
        "description": "Primary workflow: poll Gmail for unread emails, classify, post summary to Slack, create Notion entry, and mark as processed",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Polling trigger fires",
            "detail": "60-second interval polling cycle begins"
          },
          {
            "id": "n2",
            "type": "connector",
            "label": "Search Gmail for unread",
            "detail": "gmail_search with query: is:unread -category:promotions -category:social",
            "connector": "google_workspace"
          },
          {
            "id": "n3",
            "type": "decision",
            "label": "New emails found?",
            "detail": "Check if search returned any unread message IDs"
          },
          {
            "id": "n4",
            "type": "connector",
            "label": "Read email content",
            "detail": "gmail_read to fetch full message: headers, body, attachments",
            "connector": "google_workspace"
          },
          {
            "id": "n5",
            "type": "action",
            "label": "Load sender memory",
            "detail": "file_read sender_patterns.json to load learned routing preferences"
          },
          {
            "id": "n6",
            "type": "action",
            "label": "Classify email",
            "detail": "Analyze sender, subject, body, and attachments to determine category and urgency"
          },
          {
            "id": "n7",
            "type": "decision",
            "label": "Is urgent or VIP?",
            "detail": "Check if urgency is critical or sender is in VIP list"
          },
          {
            "id": "n8",
            "type": "connector",
            "label": "Post to #intake-urgent",
            "detail": "POST https://slack.com/api/chat.postMessage with urgent formatting and Block Kit blocks",
            "connector": "slack"
          },
          {
            "id": "n9",
            "type": "connector",
            "label": "Post to category channel",
            "detail": "POST https://slack.com/api/chat.postMessage to the classified channel (#intake-support, #intake-sales, etc.)",
            "connector": "slack"
          },
          {
            "id": "n10",
            "type": "connector",
            "label": "Create Notion entry",
            "detail": "POST https://api.notion.com/v1/pages with Title, Sender, Category, Urgency, Status=New, Summary",
            "connector": "notion"
          },
          {
            "id": "n11",
            "type": "action",
            "label": "Update sender memory",
            "detail": "file_write sender_patterns.json with updated sender data, frequency counts, and routing preferences"
          },
          {
            "id": "n12",
            "type": "connector",
            "label": "Mark email as read",
            "detail": "gmail_mark_read to remove UNREAD label and add processed/intake label",
            "connector": "google_workspace"
          },
          {
            "id": "n13",
            "type": "end",
            "label": "Processing complete",
            "detail": "Email fully processed through pipeline, ready for next message"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e4",
            "source": "n3",
            "target": "n13",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e5",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7"
          },
          {
            "id": "e8",
            "source": "n7",
            "target": "n8",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e9",
            "source": "n7",
            "target": "n9",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e10",
            "source": "n8",
            "target": "n10"
          },
          {
            "id": "e11",
            "source": "n9",
            "target": "n10"
          },
          {
            "id": "e12",
            "source": "n10",
            "target": "n11"
          },
          {
            "id": "e13",
            "source": "n11",
            "target": "n12"
          },
          {
            "id": "e14",
            "source": "n12",
            "target": "n13"
          }
        ]
      },
      {
        "id": "flow_error_recovery",
        "name": "Error Recovery & Retry",
        "description": "Handles failures in the processing pipeline â€” retries failed operations, escalates persistent failures, and maintains backlog files for manual recovery",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Pipeline step fails",
            "detail": "Any step in the email processing pipeline encounters an error"
          },
          {
            "id": "n2",
            "type": "action",
            "label": "Log error details",
            "detail": "file_write to processing_errors.json with timestamp, message ID, error type, and failed step"
          },
          {
            "id": "n3",
            "type": "decision",
            "label": "Which step failed?",
            "detail": "Determine whether the failure was in Slack posting, Notion creation, or Gmail operations"
          },
          {
            "id": "n4",
            "type": "action",
            "label": "Queue Slack message",
            "detail": "Write pending Slack message to failed_posts.json for retry on next cycle"
          },
          {
            "id": "n5",
            "type": "action",
            "label": "Queue Notion entry",
            "detail": "Write pending Notion entry data to notion_backlog.json for retry on next cycle"
          },
          {
            "id": "n6",
            "type": "decision",
            "label": "Failure count >= 3?",
            "detail": "Check if this message has failed processing 3 or more times"
          },
          {
            "id": "n7",
            "type": "connector",
            "label": "Escalate to #intake-urgent",
            "detail": "POST https://slack.com/api/chat.postMessage with failure alert: message ID, error type, manual review needed",
            "connector": "slack"
          },
          {
            "id": "n8",
            "type": "connector",
            "label": "Mark as read (give up)",
            "detail": "gmail_mark_read to prevent infinite retry loop, apply error/intake label",
            "connector": "google_workspace"
          },
          {
            "id": "n9",
            "type": "action",
            "label": "Keep email unread",
            "detail": "Do NOT mark as read â€” email will be reprocessed on next polling cycle"
          },
          {
            "id": "n10",
            "type": "event",
            "label": "Emit processing error event",
            "detail": "Emit agent_execution_error event for monitoring and alerting systems"
          },
          {
            "id": "n11",
            "type": "end",
            "label": "Recovery complete",
            "detail": "Error handled â€” either queued for retry or escalated for manual intervention"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4",
            "label": "Slack",
            "variant": "yes"
          },
          {
            "id": "e4",
            "source": "n3",
            "target": "n5",
            "label": "Notion",
            "variant": "no"
          },
          {
            "id": "e5",
            "source": "n4",
            "target": "n6"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e8",
            "source": "n6",
            "target": "n9",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e9",
            "source": "n7",
            "target": "n8"
          },
          {
            "id": "e10",
            "source": "n8",
            "target": "n10"
          },
          {
            "id": "e11",
            "source": "n9",
            "target": "n10"
          },
          {
            "id": "e12",
            "source": "n10",
            "target": "n11"
          }
        ]
      },
      {
        "id": "flow_sender_learning",
        "name": "Sender Pattern Learning",
        "description": "Tracks sender behavior over time to build routing preferences, solidify patterns after sufficient data, and detect sender category shifts",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Email classified",
            "detail": "An email has been classified with category and urgency after the main processing step"
          },
          {
            "id": "n2",
            "type": "action",
            "label": "Load sender patterns",
            "detail": "file_read sender_patterns.json to get current sender routing memory"
          },
          {
            "id": "n3",
            "type": "decision",
            "label": "Known sender?",
            "detail": "Check if sender email or domain exists in the patterns file"
          },
          {
            "id": "n4",
            "type": "action",
            "label": "Create sender entry",
            "detail": "Initialize new sender record with email, domain, first category, urgency, count=1, and timestamp"
          },
          {
            "id": "n5",
            "type": "action",
            "label": "Update sender stats",
            "detail": "Increment email count, update category distribution, recalculate primary category and average urgency"
          },
          {
            "id": "n6",
            "type": "decision",
            "label": "Count >= 10?",
            "detail": "Check if sender has enough emails (10+) to solidify a routing preference"
          },
          {
            "id": "n7",
            "type": "action",
            "label": "Solidify routing preference",
            "detail": "Set sender's primary routing channel as a stable preference, mark as 'learned' with high confidence"
          },
          {
            "id": "n8",
            "type": "action",
            "label": "Keep as provisional",
            "detail": "Maintain sender routing as provisional â€” still subject to content-based override on each email"
          },
          {
            "id": "n9",
            "type": "action",
            "label": "Save updated patterns",
            "detail": "file_write sender_patterns.json with all updated sender data and preferences"
          },
          {
            "id": "n10",
            "type": "end",
            "label": "Learning cycle complete",
            "detail": "Sender memory updated and persisted for future routing decisions"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e4",
            "source": "n3",
            "target": "n5",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e5",
            "source": "n4",
            "target": "n9"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e8",
            "source": "n6",
            "target": "n8",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e9",
            "source": "n7",
            "target": "n9"
          },
          {
            "id": "e10",
            "source": "n8",
            "target": "n9"
          },
          {
            "id": "e11",
            "source": "n9",
            "target": "n10"
          }
        ]
      }
    ]
  }
}
