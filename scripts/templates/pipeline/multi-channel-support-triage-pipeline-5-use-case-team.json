{
  "id": "multi-channel-support-triage-pipeline-5-use-case-team",
  "name": "Multi-Channel Support Triage Pipeline (5-Use Case Team)",
  "description": "**Use Case A â€” Email Support** (worker): Processes Zendesk email tickets, classifies and enriches.\n**Use Case B â€” Chat Support** (worker): Monitors Intercom conversations for handoff triggers.\n**Use Case C â€” Social Support** (worker): Tracks Twitter/X mentions via API for support requests.\n**Use Case D â€” Knowledge Use Case** (worker): Searches Notion KB and suggests responses for all channels.\n**Use Case E â€” Triage Coordinator** (orchestrator): Routes across channels, prevents duplicate handling, escalates VIP customers.",
  "icon": "GitBranch",
  "color": "#0EA5E9",
  "category": [
    "pipeline"
  ],
  "service_flow": [],
  "payload": {
    "service_flow": [
      "Zendesk",
      "Intercom",
      "Twitter/X",
      "Notion",
      "Slack",
      "Google Workspace"
    ],
    "structured_prompt": {
      "identity": "You are the Triage Coordinator â€” the orchestrating intelligence behind a multi-channel customer support pipeline. You oversee five specialized agents: Email Support (Zendesk), Chat Support (Intercom), Social Support (Twitter/X), and Knowledge Use Case (Notion KB), plus yourself as the routing and deduplication brain. Your core purpose is to ensure every inbound support request â€” regardless of channel â€” is classified, deduplicated, enriched with knowledge base context, routed to the correct handler, and resolved or escalated within SLA. You prevent duplicate handling when the same customer contacts via multiple channels, you prioritize VIP customers for immediate escalation, and you maintain a unified view of all open support interactions across the organization.",
      "instructions": "## Orchestration Loop\n\n1. **Poll All Channels** â€” On each execution cycle, collect new items from all inbound channels:\n   - Fetch unprocessed Zendesk tickets (status: new or open, updated since last poll)\n   - Fetch Intercom conversations with pending handoff signals or new user messages\n   - Fetch recent Twitter/X mentions and DMs matching support keywords\n   - Check the internal triage queue (local state file) for items awaiting routing\n\n2. **Normalize & Classify** â€” For each new item:\n   - Extract: customer identifier (email, handle, user ID), subject/topic, sentiment, urgency signals\n   - Classify into categories: billing, technical, account, feature-request, complaint, general\n   - Assign priority: P1 (outage/VIP), P2 (urgent), P3 (standard), P4 (low)\n   - Tag with source channel and timestamp\n\n3. **Deduplicate Across Channels** â€” Before routing:\n   - Search existing open tickets/conversations for matching customer identifiers\n   - If the same customer has contacted via multiple channels about the same issue, merge into a single case\n   - Link related items and mark duplicates as consolidated\n   - Write deduplication decisions to the local state log\n\n4. **VIP Detection & Escalation** â€” Check customer against VIP list:\n   - Query Notion database for VIP customer records\n   - If VIP: immediately escalate to priority queue, notify #support-escalations Slack channel\n   - If high-value account (based on tags or spend tier): flag for senior agent review\n\n5. **Knowledge Enrichment** â€” For each classified request:\n   - Search Notion knowledge base for relevant articles matching the issue category and keywords\n   - Attach top 3 matching KB articles as suggested responses\n   - If confidence > 80%, draft an auto-response for human review\n   - If no KB match, flag as knowledge gap for content team\n\n6. **Route & Assign** â€” Based on classification and channel:\n   - Email tickets: update Zendesk ticket with classification tags, priority, and suggested KB response\n   - Chat conversations: post internal note in Intercom with classification and KB suggestions\n   - Social mentions: create Zendesk ticket from tweet, link original social post\n   - Cross-channel cases: assign to the primary channel's queue with links to all touchpoints\n\n7. **Monitor SLA & Escalate** â€” Track response times:\n   - P1: 15-minute first response SLA\n   - P2: 1-hour first response SLA\n   - P3: 4-hour first response SLA\n   - P4: 24-hour first response SLA\n   - If SLA breach imminent: notify Slack, bump priority, reassign if needed\n\n8. **Report & Log** â€” After each cycle:\n   - Update local state file with processed items, routing decisions, and metrics\n   - Post daily summary to Slack #support-metrics channel\n   - Log any errors or anomalies for review",
      "toolGuidance": "### Zendesk (via http_request + zendesk connector)\n- `GET /api/v2/tickets.json?status=new,open&sort_by=updated_at` â€” Fetch open tickets\n- `GET /api/v2/tickets/{id}.json` â€” Get ticket details\n- `PUT /api/v2/tickets/{id}.json` â€” Update ticket tags, priority, assignee\n- `POST /api/v2/tickets.json` â€” Create ticket from social mention\n- `GET /api/v2/search.json?query=requester:{email}` â€” Find tickets by customer\n\n### Intercom (via http_request + intercom connector)\n- `GET /conversations?open=true&sort=updated_at` â€” List open conversations\n- `GET /conversations/{id}` â€” Get conversation details\n- `POST /conversations/{id}/parts` â€” Add internal note with classification\n- `POST /conversations/{id}/tags` â€” Tag conversation\n- Headers: `Accept: application/json`, `Intercom-Version: 2.11`\n\n### Twitter/X (via http_request + twitter connector)\n- `GET /2/tweets/search/recent?query=@YourHandle -is:retweet` â€” Search mentions\n- `GET /2/users/{id}/mentions` â€” Get user mentions\n- `GET /2/dm_conversations` â€” Check DMs (with appropriate permissions)\n- Headers: `Authorization: Bearer {token}`\n\n### Notion (via http_request + notion connector)\n- `POST /v1/databases/{kb_database_id}/query` â€” Search knowledge base articles\n- `POST /v1/databases/{vip_database_id}/query` â€” Query VIP customer list\n- `POST /v1/pages` â€” Create new KB gap entry\n- Headers: `Notion-Version: 2022-06-28`\n\n### Slack (via http_request + slack connector)\n- `POST /chat.postMessage` â€” Send alerts to channels\n- `POST /chat.update` â€” Update existing alert messages\n- Body: `{\"channel\": \"#support-escalations\", \"text\": \"...\", \"blocks\": [...]}`\n\n### Gmail (via gmail_read, gmail_send, gmail_search, gmail_mark_read)\n- Use gmail_search to find customer correspondence for enrichment\n- Use gmail_send to send internal digest emails to support leads\n- Use gmail_mark_read to manage processed notification emails\n\n### Local State (via file_read, file_write)\n- `file_read(\"triage_state.json\")` â€” Load current triage queue and processed item log\n- `file_write(\"triage_state.json\", ...)` â€” Persist updated state between cycles\n- `file_write(\"triage_log.jsonl\", ..., append=true)` â€” Append routing decisions for audit trail",
      "examples": "### Example 1: New Zendesk Email Ticket\nA customer emails about a billing discrepancy. The Email Support worker fetches the ticket from Zendesk, classifies it as `billing / P3`. The Triage Coordinator checks for duplicate contacts â€” finds the same customer also tweeted about the issue 2 hours ago. It merges both into a single case on the Zendesk ticket, links the tweet, searches Notion KB for \"billing discrepancy\" articles, attaches the top match as a suggested response, and updates the ticket with tags `[billing, cross-channel, kb-match]`.\n\n### Example 2: VIP Chat Escalation\nA VIP customer initiates an Intercom chat about a service outage. Chat Support detects the conversation. The Triage Coordinator queries the Notion VIP database, confirms VIP status, immediately escalates to P1, posts an alert to Slack #support-escalations with customer context and account value, and adds an internal note in Intercom flagging this as VIP/P1.\n\n### Example 3: Social Mention Capture\nA user tweets \"@YourCompany my account is locked, help!\" The Social Support worker captures the mention. The Triage Coordinator creates a Zendesk ticket from the tweet content, classifies as `account / P2`, searches for existing tickets from this customer (by matching Twitter handle to known accounts), and routes to the account support queue with KB article suggestions for account lockout resolution.\n\n### Example 4: SLA Breach Prevention\nDuring a monitoring cycle, the Triage Coordinator detects a P2 ticket that has been open for 50 minutes with no first response (SLA: 1 hour). It sends an urgent Slack notification to the assigned agent and their team lead, bumps visibility in the queue, and logs the near-breach event.",
      "errorHandling": "### API Failures\n- **Zendesk 429 (rate limit)**: Back off exponentially (30s, 60s, 120s). Log the delay. Process other channels while waiting.\n- **Intercom 5xx**: Retry up to 3 times with 10s intervals. If persistent, log error and skip Intercom polling for this cycle. Alert Slack #support-ops.\n- **Twitter API errors**: If 403 (suspended/restricted), alert immediately. For rate limits, respect the `x-rate-limit-reset` header.\n- **Notion timeout**: Retry once. If KB search fails, route ticket without KB suggestions and tag as `kb-unavailable` for manual enrichment.\n\n### Data Integrity\n- **Deduplication false positive**: If merge confidence < 70%, flag for human review instead of auto-merging. Log the decision rationale.\n- **Missing customer identifier**: If a social mention cannot be linked to a known customer, create a new contact record and route normally.\n- **Malformed ticket data**: Log the raw payload, skip the item, and alert #support-ops for manual handling.\n\n### State Management\n- **Corrupted state file**: If `triage_state.json` fails to parse, rename to `triage_state.json.corrupt.{timestamp}`, initialize fresh state, and alert. Recent items may be reprocessed (idempotent operations prevent duplicates).\n- **Concurrent execution**: Use file-based locking. If lock file exists and is < 10 minutes old, skip cycle. If stale (> 10 minutes), break lock and proceed.\n\n### Escalation Failures\n- **Slack notification fails**: Fall back to Gmail notification to support-leads@company.com.\n- **Cannot update Zendesk ticket**: Queue the update locally and retry next cycle. Do not block routing of other items."
    },
    "suggested_tools": [
      "http_request",
      "gmail_read",
      "gmail_send",
      "gmail_search",
      "gmail_mark_read",
      "file_read",
      "file_write"
    ],
    "suggested_triggers": [
      {
        "trigger_type": "polling",
        "config": {
          "cron": "*/3 * * * *"
        },
        "description": "Poll Zendesk for new/updated email tickets every 3 minutes to ensure timely triage of email support requests"
      },
      {
        "trigger_type": "polling",
        "config": {
          "cron": "*/2 * * * *"
        },
        "description": "Poll Intercom for new conversations and handoff signals every 2 minutes â€” chat requires faster response than email"
      },
      {
        "trigger_type": "polling",
        "config": {
          "cron": "*/5 * * * *"
        },
        "description": "Poll Twitter/X API for new mentions and DMs every 5 minutes to capture social support requests"
      },
      {
        "trigger_type": "schedule",
        "config": {
          "cron": "*/10 * * * *"
        },
        "description": "Run SLA monitoring sweep every 10 minutes to detect near-breach tickets and trigger escalation alerts"
      },
      {
        "trigger_type": "schedule",
        "config": {
          "cron": "0 9 * * 1-5"
        },
        "description": "Generate and post daily support metrics digest to Slack #support-metrics at 9 AM on weekdays"
      },
      {
        "trigger_type": "webhook",
        "config": {},
        "description": "Receive real-time Zendesk webhook events for ticket creation and status changes (if configured in Zendesk admin)"
      }
    ],
    "full_prompt_markdown": "# Multi-Channel Support Triage Coordinator\n\n## Identity\n\nYou are the **Triage Coordinator** â€” the orchestrating intelligence behind a multi-channel customer support pipeline. You oversee a team of four specialized worker agents (Email Support, Chat Support, Social Support, Knowledge Use Case) and serve as the central routing, deduplication, and escalation brain.\n\nYour mission: ensure every inbound support request â€” regardless of whether it arrives via email, chat, or social media â€” is classified, deduplicated across channels, enriched with knowledge base context, routed to the correct handler, and resolved or escalated within SLA.\n\n## Team Structure\n\n| Agent | Role | Channel | Primary Service |\n|-------|------|---------|----------------|\n| Email Support | Worker | Email | Zendesk |\n| Chat Support | Worker | Live Chat | Intercom |\n| Social Support | Worker | Social Media | Twitter/X |\n| Knowledge Use Case | Worker | All Channels | Notion KB |\n| Triage Coordinator (you) | Orchestrator | Cross-channel | All services |\n\n## Core Instructions\n\n### 1. Channel Polling & Ingestion\n\nOn each execution cycle, collect new items from all inbound channels:\n\n- **Zendesk**: `GET /api/v2/tickets.json?status=new,open&sort_by=updated_at` â€” Fetch tickets updated since last poll timestamp\n- **Intercom**: `GET /conversations?open=true&sort=updated_at` â€” Fetch conversations with new activity\n- **Twitter/X**: `GET /2/tweets/search/recent?query=@YourHandle -is:retweet` â€” Fetch recent mentions\n- **Local State**: `file_read(\"triage_state.json\")` â€” Load last poll timestamps and pending queue\n\n### 2. Normalize & Classify\n\nFor each new item, extract and standardize:\n- **Customer ID**: email, social handle, or platform user ID\n- **Subject/Topic**: issue summary\n- **Sentiment**: positive, neutral, negative, urgent\n- **Category**: billing, technical, account, feature-request, complaint, general\n- **Priority**: P1 (outage/VIP), P2 (urgent), P3 (standard), P4 (low)\n- **Source channel** and **timestamp**\n\n### 3. Cross-Channel Deduplication\n\nBefore routing any item:\n1. Search all channels for matching customer identifiers\n2. Check Zendesk: `GET /api/v2/search.json?query=requester:{email}+status:open`\n3. Check local state for recent items from the same customer\n4. If duplicate found (same customer + similar topic within 24h): merge into primary case, link duplicates\n5. Log deduplication decision with confidence score\n\n### 4. VIP Detection & Priority Escalation\n\n1. Query Notion VIP database: `POST /v1/databases/{vip_db_id}/query` with customer identifier filter\n2. If VIP match:\n   - Set priority to P1\n   - Immediately alert Slack: `POST /chat.postMessage` to #support-escalations\n   - Add VIP tag to all associated tickets/conversations\n3. If high-value account tag present: flag for senior agent review\n\n### 5. Knowledge Base Enrichment\n\nFor every classified request:\n1. Search Notion KB: `POST /v1/databases/{kb_db_id}/query` with category and keyword filters\n2. Rank results by relevance\n3. Attach top 3 KB articles as suggested responses\n4. If best match confidence > 80%: draft auto-response for human review\n5. If no match: create KB gap entry via `POST /v1/pages` and tag as `kb-gap`\n\n### 6. Routing Rules\n\n| Source | Action | Target |\n|--------|--------|--------|\n| Email (Zendesk) | Update ticket with tags, priority, KB suggestions | Zendesk queue |\n| Chat (Intercom) | Add internal note with classification | Intercom queue |\n| Social (Twitter) | Create Zendesk ticket, link tweet | Zendesk social queue |\n| Cross-channel | Assign to primary channel, link all touchpoints | Primary queue |\n\n### 7. SLA Monitoring\n\n| Priority | First Response SLA | Resolution SLA |\n|----------|-------------------|----------------|\n| P1 | 15 minutes | 4 hours |\n| P2 | 1 hour | 8 hours |\n| P3 | 4 hours | 24 hours |\n| P4 | 24 hours | 72 hours |\n\nWhen SLA breach is imminent (80% of time elapsed):\n1. Post urgent alert to Slack\n2. Bump ticket visibility\n3. If unassigned: auto-assign to available agent\n4. Log near-breach event\n\n### 8. Reporting\n\n- Maintain running metrics in `triage_state.json`: tickets processed, avg classification time, SLA compliance rate, deduplication hits\n- Daily digest at 9 AM to Slack #support-metrics\n- Weekly email summary to support leads via Gmail\n\n## Tool Usage\n\n### Zendesk (`http_request` + `zendesk` connector)\n- Tickets CRUD: `/api/v2/tickets.json`\n- Search: `/api/v2/search.json`\n- Users: `/api/v2/users.json`\n\n### Intercom (`http_request` + `intercom` connector)\n- Conversations: `/conversations`\n- Notes: `/conversations/{id}/parts`\n- Tags: `/conversations/{id}/tags`\n- Header: `Intercom-Version: 2.11`\n\n### Twitter/X (`http_request` + `twitter` connector)\n- Search: `/2/tweets/search/recent`\n- Mentions: `/2/users/{id}/mentions`\n- Bearer auth\n\n### Notion (`http_request` + `notion` connector)\n- Database query: `/v1/databases/{id}/query`\n- Page create: `/v1/pages`\n- Header: `Notion-Version: 2022-06-28`\n\n### Slack (`http_request` + `slack` connector)\n- Post message: `/chat.postMessage`\n- Update message: `/chat.update`\n\n### Gmail (native tools)\n- `gmail_search`: Find customer correspondence\n- `gmail_send`: Send digest emails\n- `gmail_mark_read`: Process notification emails\n\n### Local State (`file_read` / `file_write`)\n- `triage_state.json`: Persistent state between cycles\n- `triage_log.jsonl`: Append-only audit trail\n\n## Error Handling\n\n- API rate limits: exponential backoff, process other channels while waiting\n- Service outages: retry 3x, then skip and alert Slack #support-ops\n- State corruption: rename corrupt file, reinitialize, accept one-time reprocessing\n- Deduplication uncertainty (< 70% confidence): flag for human review, do not auto-merge\n- Slack failures: fallback to Gmail notification",
    "summary": "The Multi-Channel Support Triage Pipeline is a 5-agent orchestrated system that unifies customer support across email (Zendesk), live chat (Intercom), and social media (Twitter/X) into a single intelligent triage workflow. The Triage Coordinator agent serves as the central brain â€” polling all channels on configurable intervals, normalizing and classifying each request by category and priority, deduplicating contacts across channels to prevent double-handling, enriching tickets with Notion knowledge base suggestions, routing to the appropriate queue, and monitoring SLA compliance with proactive Slack escalation alerts. The system replaces six separate automation workflows (email triage, chat escalation, social capture, KB search, cross-channel deduplication, and VIP priority routing) with a coordinated reasoning pipeline that adapts to context rather than following rigid rules.",
    "design_highlights": [
      {
        "category": "Multi-Channel Ingestion",
        "icon": "ðŸ“¥",
        "color": "blue",
        "items": [
          "Unified polling across Zendesk, Intercom, and Twitter/X on configurable intervals",
          "Automatic normalization of tickets, conversations, and mentions into a standard format",
          "Stateful tracking of last-poll timestamps to prevent reprocessing",
          "Webhook support for real-time Zendesk ticket events"
        ]
      },
      {
        "category": "Intelligent Triage & Routing",
        "icon": "ðŸ§ ",
        "color": "purple",
        "items": [
          "AI-driven classification into categories (billing, technical, account, etc.) with priority assignment",
          "Cross-channel deduplication prevents the same customer from being handled by multiple agents",
          "VIP detection via Notion database lookup with automatic P1 escalation",
          "Context-aware routing rules that adapt based on channel, priority, and agent availability"
        ]
      },
      {
        "category": "Knowledge Enrichment",
        "icon": "ðŸ“š",
        "color": "green",
        "items": [
          "Automatic Notion KB search for every classified request",
          "Top-3 article suggestions attached to tickets and conversations",
          "Auto-response drafting when KB confidence exceeds 80%",
          "Knowledge gap detection and automatic content team notification"
        ]
      },
      {
        "category": "SLA Monitoring & Escalation",
        "icon": "â±ï¸",
        "color": "red",
        "items": [
          "Four-tier SLA tracking (P1: 15min, P2: 1hr, P3: 4hr, P4: 24hr)",
          "Proactive breach prevention alerts at 80% of SLA window",
          "Automatic Slack escalation to #support-escalations with full context",
          "Daily metrics digest and weekly email summaries for support leadership"
        ]
      }
    ],
    "suggested_connectors": [
      {
        "name": "zendesk",
        "label": "Zendesk",
        "auth_type": "api_token",
        "credential_fields": [
          {
            "key": "subdomain",
            "label": "Zendesk Subdomain",
            "type": "text",
            "placeholder": "yourcompany",
            "helpText": "Your Zendesk subdomain (e.g., 'yourcompany' from yourcompany.zendesk.com)",
            "required": true
          },
          {
            "key": "email",
            "label": "Agent Email",
            "type": "text",
            "placeholder": "agent@yourcompany.com",
            "helpText": "The email address of the Zendesk agent account used for API access",
            "required": true
          },
          {
            "key": "api_token",
            "label": "API Token",
            "type": "password",
            "placeholder": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "Generate at Zendesk Admin â†’ Channels â†’ API â†’ Add API Token",
            "required": true
          }
        ],
        "setup_instructions": "1. Log into Zendesk Admin Center\n2. Go to Apps and Integrations â†’ Zendesk API\n3. Enable Token Access if not already enabled\n4. Click 'Add API Token', give it a description like 'Personas Triage Bot'\n5. Copy the token immediately (it won't be shown again)\n6. Use email/token authentication: the API token is appended to your email as `{email}/token:{api_token}`",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [
          0,
          5
        ],
        "api_base_url": "https://{subdomain}.zendesk.com/api/v2"
      },
      {
        "name": "intercom",
        "label": "Intercom",
        "auth_type": "api_key",
        "credential_fields": [
          {
            "key": "access_token",
            "label": "Access Token",
            "type": "password",
            "placeholder": "dG9rOmxxxxxxxxxxxxxxxx",
            "helpText": "From Intercom Developer Hub â†’ Your Apps â†’ Authentication â†’ Access Token",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to Intercom Developer Hub (developers.intercom.com)\n2. Create a new app or select your existing app\n3. Go to Authentication section\n4. Copy the Access Token\n5. Ensure the app has permissions for: Read conversations, Write conversations, Read users\n6. Set API version header to 2.11 for latest features",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [
          1
        ],
        "api_base_url": "https://api.intercom.io"
      },
      {
        "name": "twitter",
        "label": "Twitter/X",
        "auth_type": "api_key",
        "credential_fields": [
          {
            "key": "bearer_token",
            "label": "Bearer Token",
            "type": "password",
            "placeholder": "AAAAAAAAAAAAAAAAAAAAAxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "From Twitter Developer Portal â†’ Projects & Apps â†’ Keys and Tokens â†’ Bearer Token",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to developer.twitter.com and sign in\n2. Create a Project and App (or use existing)\n3. Navigate to your App's 'Keys and Tokens' tab\n4. Generate a Bearer Token under 'Authentication Tokens'\n5. Ensure your App has 'Read' permissions at minimum\n6. For DM access, you'll need Elevated access and appropriate user-context auth",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [
          2
        ],
        "api_base_url": "https://api.twitter.com/2"
      },
      {
        "name": "notion",
        "label": "Notion",
        "auth_type": "integration_token",
        "credential_fields": [
          {
            "key": "integration_token",
            "label": "Internal Integration Token",
            "type": "password",
            "placeholder": "ntn_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "From notion.so/my-integrations â†’ Create or select integration â†’ Internal Integration Secret",
            "required": true
          },
          {
            "key": "kb_database_id",
            "label": "Knowledge Base Database ID",
            "type": "text",
            "placeholder": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "The Notion database ID for your knowledge base articles (from the database URL)",
            "required": true
          },
          {
            "key": "vip_database_id",
            "label": "VIP Customers Database ID",
            "type": "text",
            "placeholder": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "The Notion database ID for your VIP customer list (from the database URL)",
            "required": false
          }
        ],
        "setup_instructions": "1. Go to notion.so/my-integrations\n2. Click 'New Integration', name it 'Support Triage Bot'\n3. Select the workspace containing your KB and VIP databases\n4. Copy the Internal Integration Secret (starts with 'ntn_')\n5. Share your Knowledge Base database with the integration (open DB â†’ â€¢â€¢â€¢ â†’ Connections â†’ Add)\n6. Share your VIP Customers database with the integration\n7. Get database IDs from the URL: notion.so/{workspace}/{database_id}?v=...",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://api.notion.com/v1"
      },
      {
        "name": "slack",
        "label": "Slack",
        "auth_type": "bot_token",
        "credential_fields": [
          {
            "key": "bot_token",
            "label": "Bot User OAuth Token",
            "type": "password",
            "placeholder": "xoxb-xxxxxxxxxxxx-xxxxxxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "From Slack App â†’ OAuth & Permissions â†’ Bot User OAuth Token (starts with xoxb-)",
            "required": true
          },
          {
            "key": "escalation_channel",
            "label": "Escalation Channel ID",
            "type": "text",
            "placeholder": "C0XXXXXXXXX",
            "helpText": "Channel ID for #support-escalations (right-click channel â†’ View channel details â†’ copy ID)",
            "required": true
          },
          {
            "key": "metrics_channel",
            "label": "Metrics Channel ID",
            "type": "text",
            "placeholder": "C0XXXXXXXXX",
            "helpText": "Channel ID for #support-metrics where daily digests are posted",
            "required": false
          }
        ],
        "setup_instructions": "1. Go to api.slack.com/apps and create a new app (or select existing)\n2. Go to OAuth & Permissions\n3. Add Bot Token Scopes: chat:write, chat:write.public, channels:read\n4. Install the app to your workspace\n5. Copy the Bot User OAuth Token (starts with xoxb-)\n6. Invite the bot to #support-escalations and #support-metrics channels\n7. Get channel IDs by right-clicking the channel name â†’ View channel details",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://slack.com/api"
      },
      {
        "name": "google_workspace",
        "label": "Google Workspace",
        "auth_type": "oauth2",
        "credential_fields": [
          {
            "key": "client_id",
            "label": "OAuth Client ID",
            "type": "text",
            "placeholder": "xxxxxxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.apps.googleusercontent.com",
            "helpText": "From Google Cloud Console â†’ APIs & Services â†’ Credentials â†’ OAuth 2.0 Client ID",
            "required": true
          },
          {
            "key": "client_secret",
            "label": "OAuth Client Secret",
            "type": "password",
            "placeholder": "GOCSPX-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "From Google Cloud Console â†’ APIs & Services â†’ Credentials â†’ OAuth 2.0 Client Secret",
            "required": true
          },
          {
            "key": "refresh_token",
            "label": "Refresh Token",
            "type": "password",
            "placeholder": "1//0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "Obtained after OAuth2 consent flow. Enable Gmail API in Google Cloud Console first.",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to Google Cloud Console â†’ APIs & Services\n2. Enable the Gmail API\n3. Go to Credentials â†’ Create Credentials â†’ OAuth Client ID\n4. Set application type to 'Desktop app' or 'Web application'\n5. Complete the OAuth consent screen setup\n6. After creating credentials, copy the Client ID and Client Secret\n7. Run the OAuth2 consent flow to obtain a Refresh Token\n8. The agent uses Gmail for sending digest emails and searching customer correspondence",
        "related_tools": [
          "gmail_read",
          "gmail_send",
          "gmail_search",
          "gmail_mark_read"
        ],
        "related_triggers": [
          4
        ],
        "api_base_url": "https://www.googleapis.com"
      }
    ],
    "suggested_notification_channels": [
      {
        "type": "slack",
        "description": "Real-time escalation alerts for VIP customers and SLA breach warnings posted to #support-escalations",
        "required_connector": "slack",
        "config_hints": {
          "channel": "#support-escalations"
        }
      },
      {
        "type": "slack",
        "description": "Daily support metrics digest and weekly performance summaries posted to #support-metrics",
        "required_connector": "slack",
        "config_hints": {
          "channel": "#support-metrics"
        }
      },
      {
        "type": "email",
        "description": "Weekly support summary report emailed to support leadership for offline review",
        "required_connector": "google_workspace",
        "config_hints": {
          "to": "support-leads@yourcompany.com"
        }
      }
    ],
    "suggested_event_subscriptions": [
      {
        "event_type": "ticket.created",
        "description": "Listen for new Zendesk ticket creation events to trigger immediate triage without waiting for the next poll cycle"
      },
      {
        "event_type": "ticket.updated",
        "description": "Listen for Zendesk ticket status changes (e.g., reopened, escalated) to adjust routing and SLA tracking"
      },
      {
        "event_type": "conversation.user.replied",
        "description": "Listen for new Intercom user replies to detect handoff signals and re-triage if needed"
      },
      {
        "event_type": "sla.breach_warning",
        "description": "Internal event emitted when a ticket reaches 80% of its SLA window â€” triggers escalation workflow"
      },
      {
        "event_type": "vip.detected",
        "description": "Internal event emitted when a customer is identified as VIP â€” triggers priority routing and Slack alert"
      }
    ],
    "use_case_flows": [
      {
        "id": "flow_email_triage",
        "name": "Email Ticket Triage & Routing",
        "description": "End-to-end flow for processing a new Zendesk email ticket: fetch, classify, deduplicate, enrich with KB, route, and monitor SLA",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Zendesk Poll Trigger",
            "detail": "Polling trigger fires every 3 minutes to check for new/updated tickets"
          },
          {
            "id": "n2",
            "type": "connector",
            "label": "Fetch New Tickets",
            "detail": "GET /api/v2/tickets.json?status=new,open&sort_by=updated_at â€” retrieve tickets updated since last poll",
            "connector": "zendesk"
          },
          {
            "id": "n3",
            "type": "action",
            "label": "Classify Ticket",
            "detail": "Extract customer ID, subject, sentiment. Assign category (billing/technical/account/etc) and priority (P1-P4)"
          },
          {
            "id": "n4",
            "type": "connector",
            "label": "Check for Duplicates",
            "detail": "GET /api/v2/search.json?query=requester:{email}+status:open â€” search for existing open tickets from same customer",
            "connector": "zendesk"
          },
          {
            "id": "n5",
            "type": "decision",
            "label": "Duplicate Found?",
            "detail": "Does an open ticket from the same customer about a similar topic already exist?"
          },
          {
            "id": "n6",
            "type": "action",
            "label": "Merge Cases",
            "detail": "Link duplicate ticket to primary case, add internal note with cross-reference, mark duplicate as consolidated"
          },
          {
            "id": "n7",
            "type": "connector",
            "label": "Check VIP Status",
            "detail": "POST /v1/databases/{vip_db_id}/query â€” filter by customer email to check VIP list",
            "connector": "notion"
          },
          {
            "id": "n8",
            "type": "decision",
            "label": "Is VIP Customer?",
            "detail": "Does the customer appear in the Notion VIP database?"
          },
          {
            "id": "n9",
            "type": "connector",
            "label": "Alert VIP Escalation",
            "detail": "POST /chat.postMessage to #support-escalations with VIP context, account value, and ticket link",
            "connector": "slack"
          },
          {
            "id": "n10",
            "type": "connector",
            "label": "Search Knowledge Base",
            "detail": "POST /v1/databases/{kb_db_id}/query â€” search by category and keywords for relevant articles",
            "connector": "notion"
          },
          {
            "id": "n11",
            "type": "connector",
            "label": "Update Ticket",
            "detail": "PUT /api/v2/tickets/{id}.json â€” add classification tags, priority, KB article suggestions as internal note",
            "connector": "zendesk"
          },
          {
            "id": "n12",
            "type": "action",
            "label": "Update State",
            "detail": "Write processed ticket ID, classification, and routing decision to triage_state.json and triage_log.jsonl"
          },
          {
            "id": "n13",
            "type": "end",
            "label": "Ticket Routed",
            "detail": "Ticket is classified, enriched, and in the appropriate agent queue"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4"
          },
          {
            "id": "e4",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e5",
            "source": "n5",
            "target": "n6",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n7",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7"
          },
          {
            "id": "e8",
            "source": "n7",
            "target": "n8"
          },
          {
            "id": "e9",
            "source": "n8",
            "target": "n9",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e10",
            "source": "n8",
            "target": "n10",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e11",
            "source": "n9",
            "target": "n10"
          },
          {
            "id": "e12",
            "source": "n10",
            "target": "n11"
          },
          {
            "id": "e13",
            "source": "n11",
            "target": "n12"
          },
          {
            "id": "e14",
            "source": "n12",
            "target": "n13"
          }
        ]
      },
      {
        "id": "flow_social_capture",
        "name": "Social Mention Capture & Ticket Creation",
        "description": "Captures support requests from Twitter/X mentions, creates Zendesk tickets, and routes through the standard triage pipeline",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Twitter Poll Trigger",
            "detail": "Polling trigger fires every 5 minutes to search for new mentions"
          },
          {
            "id": "n2",
            "type": "connector",
            "label": "Search Mentions",
            "detail": "GET /2/tweets/search/recent?query=@YourHandle -is:retweet â€” fetch mentions since last poll",
            "connector": "twitter"
          },
          {
            "id": "n3",
            "type": "decision",
            "label": "Support Request?",
            "detail": "Analyze tweet content â€” does it contain support keywords (help, broken, issue, bug, can't, error)?"
          },
          {
            "id": "n4",
            "type": "action",
            "label": "Extract Details",
            "detail": "Parse tweet for customer handle, issue description, urgency signals, and any referenced order/account IDs"
          },
          {
            "id": "n5",
            "type": "connector",
            "label": "Search Existing Tickets",
            "detail": "GET /api/v2/search.json?query=twitter:{handle} â€” check if this Twitter user has existing open tickets",
            "connector": "zendesk"
          },
          {
            "id": "n6",
            "type": "decision",
            "label": "Existing Ticket?",
            "detail": "Does this customer already have an open ticket about the same issue?"
          },
          {
            "id": "n7",
            "type": "connector",
            "label": "Add to Existing Ticket",
            "detail": "PUT /api/v2/tickets/{id}.json â€” add tweet as comment, update tags with 'cross-channel-social'",
            "connector": "zendesk"
          },
          {
            "id": "n8",
            "type": "connector",
            "label": "Create New Ticket",
            "detail": "POST /api/v2/tickets.json â€” create ticket with tweet content, Twitter handle, classification, and social source tag",
            "connector": "zendesk"
          },
          {
            "id": "n9",
            "type": "connector",
            "label": "Enrich with KB",
            "detail": "POST /v1/databases/{kb_db_id}/query â€” search for relevant knowledge base articles",
            "connector": "notion"
          },
          {
            "id": "n10",
            "type": "action",
            "label": "Log & Update State",
            "detail": "Record social capture event in triage_log.jsonl, update triage_state.json with processed tweet IDs"
          },
          {
            "id": "n11",
            "type": "error",
            "label": "API Error",
            "detail": "Twitter API rate limit or Zendesk creation failure â€” log error, queue for retry next cycle"
          },
          {
            "id": "n12",
            "type": "end",
            "label": "Social Request Captured",
            "detail": "Tweet is now tracked as a Zendesk ticket in the support pipeline"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e4",
            "source": "n3",
            "target": "n12",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e5",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e8",
            "source": "n6",
            "target": "n8",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e9",
            "source": "n7",
            "target": "n9"
          },
          {
            "id": "e10",
            "source": "n8",
            "target": "n9"
          },
          {
            "id": "e11",
            "source": "n9",
            "target": "n10"
          },
          {
            "id": "e12",
            "source": "n10",
            "target": "n12"
          },
          {
            "id": "e13",
            "source": "n5",
            "target": "n11",
            "variant": "error"
          },
          {
            "id": "e14",
            "source": "n11",
            "target": "n12",
            "variant": "error"
          }
        ]
      },
      {
        "id": "flow_sla_monitor",
        "name": "SLA Monitoring & Breach Escalation",
        "description": "Periodic sweep of all open tickets to detect approaching SLA breaches and trigger proactive escalation before deadlines are missed",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "SLA Monitor Trigger",
            "detail": "Schedule trigger fires every 10 minutes to sweep all open tickets"
          },
          {
            "id": "n2",
            "type": "action",
            "label": "Load State",
            "detail": "Read triage_state.json to get all tracked open tickets with their priorities and timestamps"
          },
          {
            "id": "n3",
            "type": "connector",
            "label": "Fetch Open Tickets",
            "detail": "GET /api/v2/tickets.json?status=open â€” get current status and last response time for all open tickets",
            "connector": "zendesk"
          },
          {
            "id": "n4",
            "type": "action",
            "label": "Calculate SLA Status",
            "detail": "For each ticket: compute elapsed time since creation/last response, compare against SLA threshold (P1:15m, P2:1h, P3:4h, P4:24h)"
          },
          {
            "id": "n5",
            "type": "decision",
            "label": "SLA At Risk?",
            "detail": "Has any ticket consumed >= 80% of its SLA window without a first response?"
          },
          {
            "id": "n6",
            "type": "connector",
            "label": "Send Breach Alert",
            "detail": "POST /chat.postMessage â€” alert #support-escalations with ticket details, priority, time remaining, and assigned agent",
            "connector": "slack"
          },
          {
            "id": "n7",
            "type": "connector",
            "label": "Bump Ticket Priority",
            "detail": "PUT /api/v2/tickets/{id}.json â€” increase priority, add 'sla-warning' tag, reassign if unassigned",
            "connector": "zendesk"
          },
          {
            "id": "n8",
            "type": "action",
            "label": "Update Metrics",
            "detail": "Record SLA compliance data, near-breach events, and actual breach events in triage_state.json"
          },
          {
            "id": "n9",
            "type": "decision",
            "label": "Daily Digest Time?",
            "detail": "Is it 9 AM on a weekday? Time for the daily metrics summary."
          },
          {
            "id": "n10",
            "type": "connector",
            "label": "Post Daily Digest",
            "detail": "POST /chat.postMessage to #support-metrics â€” tickets processed, SLA compliance rate, avg response time, top categories",
            "connector": "slack"
          },
          {
            "id": "n11",
            "type": "action",
            "label": "Send Email Summary",
            "detail": "Use gmail_send to email weekly summary to support-leads@company.com with detailed metrics and trends"
          },
          {
            "id": "n12",
            "type": "end",
            "label": "Monitoring Complete",
            "detail": "SLA sweep complete, alerts sent if needed, metrics updated"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4"
          },
          {
            "id": "e4",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e5",
            "source": "n5",
            "target": "n6",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n8",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7"
          },
          {
            "id": "e8",
            "source": "n7",
            "target": "n8"
          },
          {
            "id": "e9",
            "source": "n8",
            "target": "n9"
          },
          {
            "id": "e10",
            "source": "n9",
            "target": "n10",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e11",
            "source": "n9",
            "target": "n12",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e12",
            "source": "n10",
            "target": "n11"
          },
          {
            "id": "e13",
            "source": "n11",
            "target": "n12"
          }
        ]
      }
    ],
    "customSections": [
      {
        "key": "team_structure",
        "label": "Pipeline Team Structure",
        "content": "## Agent Team\n\n| Agent | Role | Channel | Schedule | Primary Actions |\n|-------|------|---------|----------|----------------|\n| **Email Support** | Worker | Zendesk Email | Every 3 min | Fetch tickets, classify, extract customer data |\n| **Chat Support** | Worker | Intercom Chat | Every 2 min | Monitor conversations, detect handoff triggers |\n| **Social Support** | Worker | Twitter/X | Every 5 min | Capture mentions, identify support requests |\n| **Knowledge Use Case** | Worker | Notion KB | On-demand | Search articles, suggest responses, detect gaps |\n| **Triage Coordinator** | Orchestrator | All channels | Continuous | Route, deduplicate, escalate VIP, monitor SLA |\n\n## Communication Protocol\n- Workers write normalized items to the shared triage queue (triage_state.json)\n- Coordinator reads the queue, applies cross-channel logic, and routes\n- All agents log decisions to triage_log.jsonl for audit\n- Slack channels serve as the human notification layer"
      },
      {
        "key": "sla_policy",
        "label": "SLA Policy Matrix",
        "content": "| Priority | First Response | Resolution | Escalation Trigger |\n|----------|---------------|------------|-------------------|\n| P1 (Critical/VIP) | 15 minutes | 4 hours | Auto-escalate at 80% (12 min) |\n| P2 (Urgent) | 1 hour | 8 hours | Auto-escalate at 80% (48 min) |\n| P3 (Standard) | 4 hours | 24 hours | Auto-escalate at 80% (3h 12min) |\n| P4 (Low) | 24 hours | 72 hours | Auto-escalate at 80% (19h 12min) |"
      },
      {
        "key": "deduplication_rules",
        "label": "Cross-Channel Deduplication Rules",
        "content": "1. **Exact match**: Same email address across Zendesk + Intercom â†’ auto-merge (confidence 95%+)\n2. **Handle match**: Twitter handle linked to known customer profile â†’ auto-merge (confidence 85%+)\n3. **Topic similarity**: Same customer + similar keywords within 24h window â†’ suggest merge (confidence 70-85%), require human review below 70%\n4. **Merge strategy**: Keep the earliest ticket as primary, link all others as related. Add internal notes on each with cross-references.\n5. **Never auto-merge**: Different customers, different topics, or items older than 48 hours apart"
      }
    ]
  }
}
