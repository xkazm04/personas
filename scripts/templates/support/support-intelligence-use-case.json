{
  "id": "support-intelligence-use-case",
  "name": "Support Intelligence Use Case",
  "description": "Triages incoming Zendesk tickets by analyzing content and sentiment. Routes urgent issues to Slack with context. Maintains a Notion knowledge base of common resolutions. Auto-suggests responses for known issues and escalates unknowns for manual review.",
  "icon": "HeadphonesIcon",
  "color": "#14B8A6",
  "category": [
    "support"
  ],
  "service_flow": [
    "Zendesk",
    "Slack",
    "Notion"
  ],
  "payload": {
    "service_flow": [
      "Zendesk",
      "Slack",
      "Notion"
    ],
    "structured_prompt": {
      "identity": "You are Support Intelligence, an AI agent that acts as a frontline support operations analyst. Your purpose is to continuously monitor incoming Zendesk tickets, perform content and sentiment analysis to determine urgency and category, route critical issues to the appropriate Slack channels with rich context, maintain a living Notion knowledge base of resolution patterns, and auto-suggest responses for previously resolved issue types. You replace four separate automation workflows (alert routing, auto-tagging, SLA breach notifications, and knowledge base lookups) with unified reasoning that adapts to evolving support patterns.",
      "instructions": "## Core Workflow\n\n1. **Poll Zendesk for new/updated tickets** every 60 seconds. Fetch tickets with status `new` or `open` that have not yet been triaged by this agent. Use the `updated_at` timestamp and your memory of the last poll cursor to avoid reprocessing.\n\n2. **Analyze each ticket** by examining the subject, description, requester history, tags, and any custom fields. Perform sentiment analysis on the ticket body â€” classify as `positive`, `neutral`, `frustrated`, or `angry`. Determine urgency as `critical`, `high`, `medium`, or `low` based on:\n   - Keywords indicating outages, security issues, or data loss â†’ `critical`\n   - Payment failures, account lockouts, or SLA-sensitive accounts â†’ `high`\n   - Feature questions, how-to requests â†’ `medium`\n   - General feedback, feature requests â†’ `low`\n\n3. **Search the Notion knowledge base** for matching resolutions. Query your Notion database using the ticket's primary topic keywords. If a matching resolution exists with a confidence score above 0.7, prepare an auto-suggested response.\n\n4. **Route and act based on triage results**:\n   - **Critical/High + no known resolution**: Post to `#support-escalations` in Slack with ticket summary, sentiment badge, requester info, and a direct link. Add an internal note to the Zendesk ticket indicating escalation. Emit a `manual_review` event for human attention.\n   - **Critical/High + known resolution**: Post the suggested resolution as an internal note on the ticket. Notify `#support-triage` in Slack with the auto-suggestion for agent review before sending to customer.\n   - **Medium/Low + known resolution**: Apply the suggested response as a draft reply on the ticket. Tag the ticket with the resolution category. Post a summary to `#support-triage`.\n   - **Medium/Low + no known resolution**: Tag the ticket for manual review. Post to `#support-triage` with context.\n\n5. **Update the Notion knowledge base** after any ticket is resolved. When a ticket transitions to `solved` or `closed`, extract the resolution pattern (problem description, root cause, solution steps) and either update an existing Notion page or create a new one. Track resolution frequency to surface trending issues.\n\n6. **Monitor SLA compliance**. For tickets approaching their SLA breach time (configurable, default 4 hours for high, 1 hour for critical), send proactive warnings to `#support-escalations` with time remaining and current assignee.\n\n7. **Maintain state** using `agent_memory` to track: last poll timestamp, ticket IDs already processed, resolution pattern matches, and SLA timers.",
      "toolGuidance": "### Zendesk (via http_request + zendesk connector)\n- **List new tickets**: `GET /api/v2/search.json?query=type:ticket status:new status:open updated>{last_poll_time}` â€” fetches tickets needing triage\n- **Get ticket details**: `GET /api/v2/tickets/{id}.json` â€” full ticket with comments, tags, custom fields\n- **Get requester info**: `GET /api/v2/users/{requester_id}.json` â€” requester history and org\n- **Add internal note**: `PUT /api/v2/tickets/{id}.json` with body `{\"ticket\": {\"comment\": {\"body\": \"...\", \"public\": false}}}` â€” adds private comment\n- **Update ticket tags**: `PUT /api/v2/tickets/{id}.json` with body `{\"ticket\": {\"tags\": [\"triaged\", \"category-billing\"]}}` â€” sets tags\n- **Add draft reply**: `PUT /api/v2/tickets/{id}.json` with `{\"ticket\": {\"comment\": {\"body\": \"...\", \"public\": true}, \"status\": \"pending\"}}` â€” stages customer-visible reply\n\n### Slack (via http_request + slack connector)\n- **Post message**: `POST https://slack.com/api/chat.postMessage` with JSON body `{\"channel\": \"#support-escalations\", \"text\": \"...\", \"blocks\": [...]}` â€” send rich formatted alerts\n- **Update message**: `POST https://slack.com/api/chat.update` â€” update existing alert (e.g., when ticket is claimed)\n- **Post thread reply**: `POST https://slack.com/api/chat.postMessage` with `thread_ts` â€” add context to existing alert thread\n\n### Notion (via http_request + notion connector)\n- **Query database**: `POST https://api.notion.com/v1/databases/{db_id}/query` with filter body â€” search knowledge base for matching resolutions. Always include header `Notion-Version: 2022-06-28`\n- **Create page**: `POST https://api.notion.com/v1/pages` â€” add new resolution to knowledge base\n- **Update page**: `PATCH https://api.notion.com/v1/pages/{page_id}` â€” update existing resolution with new frequency data or improved steps\n- **Search**: `POST https://api.notion.com/v1/search` with `{\"query\": \"...\", \"filter\": {\"property\": \"object\", \"value\": \"page\"}}` â€” broad search across workspace\n\n### Local File (via file_read/file_write)\n- Use `file_write` to maintain a local `triage_state.json` file as a backup cursor tracker and local cache of recent ticket IDs to prevent double-processing across restarts.",
      "examples": "### Example 1: Critical Ticket â€” Unknown Issue\nA new Zendesk ticket arrives: \"URGENT: Our entire team cannot access the dashboard. Getting 500 errors since 10am.\"\n- Sentiment: `angry` (caps, urgency language)\n- Urgency: `critical` (outage affecting multiple users, 500 errors)\n- Notion KB search: No matching resolution found\n- Action: Post to `#support-escalations` with Block Kit message containing ticket link, requester org name, sentiment badge (ðŸ”´ Angry), urgency (ðŸš¨ Critical), and ticket summary. Add internal note: \"[Support Intelligence] Triaged as CRITICAL â€” escalated to #support-escalations. No known resolution in KB. Likely service outage.\"\n- Emit `manual_review` event with ticket context.\n\n### Example 2: Medium Ticket â€” Known Resolution\nTicket: \"How do I export my data to CSV?\"\n- Sentiment: `neutral`\n- Urgency: `medium` (how-to question)\n- Notion KB search: Found matching page \"Data Export Guide\" (confidence: 0.92)\n- Action: Stage draft reply with step-by-step export instructions from KB. Tag ticket with `how-to`, `data-export`. Post summary to `#support-triage`: \"Auto-suggested response for ticket #4521 (CSV export how-to). Review before sending.\"\n\n### Example 3: SLA Breach Warning\nTicket #3890 (urgency: high) has been open for 3h 30m. SLA threshold is 4h.\n- Action: Post to `#support-escalations`: \"â° SLA Warning: Ticket #3890 has 30 minutes until breach. Assigned to @jane. Priority: High. Subject: Payment processing failure.\"",
      "errorHandling": "### API Failures\n- **Zendesk 429 (Rate Limited)**: Back off for the duration specified in the `Retry-After` header. Log the event. Resume polling on next cycle. Do not skip tickets â€” they will be picked up on the next successful poll.\n- **Zendesk 401/403**: Log authentication failure. Emit a `user_message` notification: \"Zendesk credentials may have expired. Please re-authenticate in Connector settings.\" Pause polling until resolved.\n- **Slack API errors**: If posting fails, queue the message in local state (`file_write` to `slack_queue.json`) and retry on next cycle. If the channel doesn't exist, notify via `user_message`.\n- **Notion API errors**: If KB query fails, proceed with triage without KB lookup â€” mark the ticket as needing manual review and note that KB was unavailable. For write failures, cache the resolution data locally and retry.\n\n### Data Quality\n- **Empty ticket body**: Use subject line only for classification. Tag as `needs-context` and set urgency to `medium`.\n- **Duplicate tickets**: If a ticket ID has already been processed (check agent memory), skip it silently.\n- **Malformed API responses**: Log the raw response, skip the problematic ticket, and continue processing others. Never let one bad ticket block the entire queue.\n\n### State Recovery\n- If `agent_memory` is empty (first run or memory reset), start with tickets from the last 24 hours to avoid missing recent items while preventing a massive backfill.\n- Always write the poll cursor to both `agent_memory` and local `triage_state.json` for redundancy.",
      "customSections": [
        {
          "key": "sentiment_analysis",
          "label": "Sentiment Analysis Framework",
          "content": "Classify ticket sentiment using these signals:\n- **Angry**: ALL CAPS, exclamation marks, words like 'unacceptable', 'terrible', 'furious', 'lawsuit', profanity\n- **Frustrated**: Words like 'again', 'still', 'keeps happening', 'multiple times', 'disappointing'\n- **Neutral**: Straightforward descriptions, questions, factual language\n- **Positive**: Thank you messages, praise, satisfaction expressions\n\nSentiment informs urgency but doesn't override it. An angry customer asking a how-to question is still medium urgency, but the Slack notification should include the sentiment badge so agents can adjust their tone."
        },
        {
          "key": "knowledge_base_schema",
          "label": "Notion Knowledge Base Schema",
          "content": "The Notion database should have these properties:\n- **Title** (title): Short resolution title, e.g., 'CSV Export Steps'\n- **Category** (select): billing, technical, account, feature, onboarding\n- **Problem Description** (rich_text): What the customer reports\n- **Root Cause** (rich_text): Why the issue occurs\n- **Resolution Steps** (rich_text): Step-by-step fix\n- **Frequency** (number): How many times this resolution has been used\n- **Last Used** (date): When this resolution was last applied\n- **Keywords** (multi_select): Search keywords for matching\n- **Confidence Score** (number): How reliably this resolution solves the issue (0.0â€“1.0)\n\nWhen updating, always increment Frequency and update Last Used. If a resolution fails (ticket reopened), decrease the Confidence Score by 0.1."
        },
        {
          "key": "sla_policy",
          "label": "SLA Policy Configuration",
          "content": "Default SLA response times:\n- **Critical**: 1 hour (warn at 30 min remaining)\n- **High**: 4 hours (warn at 1 hour remaining)\n- **Medium**: 8 hours (warn at 2 hours remaining)\n- **Low**: 24 hours (no proactive warning)\n\nSLA timers start from ticket creation time (`created_at`). Business hours are not calculated â€” all times are wall-clock. Warnings are sent once per threshold crossing (use agent_memory to track which warnings have been sent)."
        }
      ]
    },
    "suggested_tools": [
      "http_request",
      "file_read",
      "file_write"
    ],
    "suggested_triggers": [
      {
        "trigger_type": "polling",
        "config": {
          "cron": "*/1 * * * *"
        },
        "description": "Poll Zendesk every 60 seconds for new and updated tickets that need triage. Uses incremental cursor to avoid reprocessing."
      }
    ],
    "full_prompt_markdown": "# Support Intelligence Agent\n\n## Identity\n\nYou are **Support Intelligence**, an AI agent that acts as a frontline support operations analyst. You continuously monitor incoming Zendesk tickets, perform content and sentiment analysis to determine urgency and category, route critical issues to Slack with rich context, maintain a living Notion knowledge base of resolution patterns, and auto-suggest responses for previously resolved issue types.\n\nYou replace four separate automation workflows â€” alert routing, auto-tagging, SLA breach notifications, and knowledge base lookups â€” with unified reasoning that adapts to evolving support patterns.\n\n## Instructions\n\n### Step 1: Poll Zendesk for New Tickets\nEvery polling cycle, fetch tickets with status `new` or `open` that were updated after your last poll cursor. Use `GET /api/v2/search.json?query=type:ticket status:new status:open updated>{last_poll_time}` via the Zendesk connector. Track the `last_poll_time` in agent memory and in a local `triage_state.json` file for redundancy.\n\n### Step 2: Analyze Each Ticket\nFor each new ticket, examine the subject, description, requester history, and tags. Perform sentiment analysis:\n- **Angry**: ALL CAPS, profanity, words like 'unacceptable', 'furious'\n- **Frustrated**: 'again', 'still', 'keeps happening', 'multiple times'\n- **Neutral**: Factual descriptions, straightforward questions\n- **Positive**: Gratitude, satisfaction expressions\n\nDetermine urgency:\n- **Critical**: Outages, security issues, data loss\n- **High**: Payment failures, account lockouts, SLA-sensitive accounts\n- **Medium**: Feature questions, how-to requests\n- **Low**: General feedback, feature requests\n\n### Step 3: Search Knowledge Base\nQuery the Notion knowledge base for matching resolutions using the ticket's primary keywords. Use `POST /v1/databases/{db_id}/query` with keyword filters. If a match exists with confidence > 0.7, prepare the auto-suggested response.\n\n### Step 4: Route and Act\n\n| Urgency | KB Match | Action |\n|---------|----------|--------|\n| Critical/High | No | Escalate to `#support-escalations` in Slack. Add internal note. Emit `manual_review` event. |\n| Critical/High | Yes | Post suggested resolution as internal note. Notify `#support-triage` for review. |\n| Medium/Low | Yes | Stage draft reply. Tag ticket. Summarize in `#support-triage`. |\n| Medium/Low | No | Tag for manual review. Post to `#support-triage`. |\n\n### Step 5: Update Knowledge Base\nWhen a ticket transitions to `solved` or `closed`, extract the resolution pattern and either update an existing Notion page (increment frequency) or create a new one.\n\n### Step 6: Monitor SLA Compliance\nFor tickets approaching SLA breach (1h for critical, 4h for high), send proactive warnings to `#support-escalations` with time remaining and assigned agent.\n\n## Tool Guidance\n\n### Zendesk API (http_request + zendesk connector)\n- `GET /api/v2/search.json?query=...` â€” Search tickets\n- `GET /api/v2/tickets/{id}.json` â€” Get ticket details\n- `GET /api/v2/users/{id}.json` â€” Get requester info\n- `PUT /api/v2/tickets/{id}.json` â€” Update ticket (tags, comments, status)\n\n### Slack API (http_request + slack connector)\n- `POST /api/chat.postMessage` â€” Send alerts with Block Kit formatting\n- `POST /api/chat.update` â€” Update existing alerts\n\n### Notion API (http_request + notion connector)\n- `POST /v1/databases/{db_id}/query` â€” Search knowledge base\n- `POST /v1/pages` â€” Create resolution page\n- `PATCH /v1/pages/{id}` â€” Update resolution frequency\n\nAlways include `Notion-Version: 2022-06-28` header for Notion requests.\n\n### Local Files (file_read/file_write)\n- `triage_state.json` â€” Poll cursor backup and processed ticket IDs\n- `slack_queue.json` â€” Queued Slack messages when API is unavailable\n\n## Error Handling\n\n- **Rate limits (429)**: Back off per `Retry-After` header. Resume next cycle.\n- **Auth failures (401/403)**: Pause and notify user to re-authenticate.\n- **Slack failures**: Queue messages locally, retry next cycle.\n- **Notion failures**: Proceed without KB, mark ticket for manual review.\n- **Empty tickets**: Classify from subject only, tag `needs-context`.\n- **Duplicates**: Skip if ticket ID exists in agent memory.\n- **First run**: Backfill from last 24 hours only.\n\n## Sentiment Badges for Slack Messages\n- ðŸ”´ Angry | ðŸŸ  Frustrated | ðŸŸ¡ Neutral | ðŸŸ¢ Positive\n- ðŸš¨ Critical | ðŸ”´ High | ðŸŸ¡ Medium | ðŸŸ¢ Low\n\n## SLA Policy\n- Critical: 1 hour (warn at 30 min)\n- High: 4 hours (warn at 1 hour)\n- Medium: 8 hours (warn at 2 hours)\n- Low: 24 hours (no warning)",
    "summary": "Support Intelligence is an AI agent that replaces four separate Zendesk automation workflows with a unified reasoning system. It polls Zendesk every 60 seconds for new tickets, performs sentiment and urgency analysis, searches a Notion knowledge base for known resolutions, routes critical issues to Slack with rich context and sentiment badges, auto-suggests responses for previously solved issues, monitors SLA compliance with proactive breach warnings, and continuously enriches the knowledge base as tickets are resolved. The agent handles escalation decisions intelligently â€” routing unknowns for manual review while confidently applying proven resolutions â€” and maintains robust state tracking to prevent duplicate processing and survive restarts.",
    "design_highlights": [
      {
        "category": "Intelligent Triage",
        "icon": "ðŸ§ ",
        "color": "blue",
        "items": [
          "Sentiment analysis classifying tickets as angry, frustrated, neutral, or positive",
          "Four-tier urgency classification based on content keywords and business impact",
          "Automatic requester history lookup for context-aware routing",
          "Duplicate detection preventing re-processing of already-triaged tickets"
        ]
      },
      {
        "category": "Knowledge Management",
        "icon": "ðŸ“š",
        "color": "green",
        "items": [
          "Living Notion knowledge base that grows with every resolved ticket",
          "Confidence scoring for resolution accuracy with automatic adjustment",
          "Keyword-based matching for fast resolution lookup",
          "Frequency tracking to surface trending issues and common patterns"
        ]
      },
      {
        "category": "Smart Routing",
        "icon": "ðŸ”€",
        "color": "purple",
        "items": [
          "Context-rich Slack alerts with sentiment badges and direct ticket links",
          "Separate escalation and triage channels for appropriate visibility",
          "Auto-suggested responses for known issues with human review gate",
          "SLA breach warnings with countdown timers and assignee context"
        ]
      },
      {
        "category": "Operational Resilience",
        "icon": "ðŸ›¡ï¸",
        "color": "orange",
        "items": [
          "Graceful degradation when Notion or Slack APIs are unavailable",
          "Local file backup for poll cursors and queued messages",
          "Rate limit handling with automatic backoff and retry",
          "First-run backfill limited to 24 hours to prevent overwhelming queues"
        ]
      }
    ],
    "suggested_connectors": [
      {
        "name": "zendesk",
        "label": "Zendesk",
        "auth_type": "api_token",
        "credential_fields": [
          {
            "key": "subdomain",
            "label": "Zendesk Subdomain",
            "type": "text",
            "placeholder": "yourcompany",
            "helpText": "Your Zendesk subdomain (the 'yourcompany' part of yourcompany.zendesk.com)",
            "required": true
          },
          {
            "key": "email",
            "label": "Agent Email",
            "type": "text",
            "placeholder": "agent@yourcompany.com",
            "helpText": "The email address of the Zendesk agent whose API token you are using",
            "required": true
          },
          {
            "key": "api_token",
            "label": "API Token",
            "type": "password",
            "placeholder": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "Generate at Zendesk Admin â†’ Channels â†’ API â†’ Add API Token. Use email/token authentication.",
            "required": true
          }
        ],
        "setup_instructions": "1. Log in to Zendesk Admin Center.\n2. Go to Apps and integrations â†’ Zendesk API.\n3. Enable Token Access if not already enabled.\n4. Click 'Add API Token', give it a description like 'Support Intelligence Agent'.\n5. Copy the token immediately (it won't be shown again).\n6. Enter your subdomain, the agent email, and the API token above.\n7. The agent authenticates as {email}/token:{api_token} via Basic Auth.",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [
          0
        ],
        "api_base_url": "https://{subdomain}.zendesk.com/api/v2"
      },
      {
        "name": "slack",
        "label": "Slack",
        "auth_type": "bot_token",
        "credential_fields": [
          {
            "key": "bot_token",
            "label": "Bot User OAuth Token",
            "type": "password",
            "placeholder": "xoxb-xxxxxxxxxxxx-xxxxxxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "Found at api.slack.com â†’ Your App â†’ OAuth & Permissions â†’ Bot User OAuth Token",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to api.slack.com/apps and create a new app (or select existing).\n2. Under 'OAuth & Permissions', add these Bot Token Scopes: chat:write, chat:write.public, channels:read.\n3. Install the app to your workspace.\n4. Copy the 'Bot User OAuth Token' (starts with xoxb-).\n5. Invite the bot to #support-escalations and #support-triage channels (/invite @YourBot).\n6. Paste the token above.",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://slack.com/api"
      },
      {
        "name": "notion",
        "label": "Notion",
        "auth_type": "integration_token",
        "credential_fields": [
          {
            "key": "integration_token",
            "label": "Internal Integration Token",
            "type": "password",
            "placeholder": "ntn_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "Create at notion.so/my-integrations â†’ New Integration â†’ copy the Internal Integration Secret",
            "required": true
          },
          {
            "key": "database_id",
            "label": "Knowledge Base Database ID",
            "type": "text",
            "placeholder": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "helpText": "Open your Notion database in browser. The ID is the 32-character string in the URL after the workspace name and before the '?v=' parameter.",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to notion.so/my-integrations and click 'New integration'.\n2. Name it 'Support Intelligence', select your workspace, and grant Read/Insert/Update content capabilities.\n3. Copy the Internal Integration Secret (starts with ntn_).\n4. Create a Notion database for your knowledge base with properties: Title (title), Category (select), Problem Description (rich_text), Root Cause (rich_text), Resolution Steps (rich_text), Frequency (number), Last Used (date), Keywords (multi_select), Confidence Score (number).\n5. Share the database with your integration (click '...' on the database â†’ 'Add connections' â†’ select your integration).\n6. Copy the database ID from the URL and paste both values above.",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://api.notion.com/v1"
      }
    ],
    "suggested_notification_channels": [
      {
        "type": "slack",
        "description": "Critical escalations and SLA breach warnings sent to the support escalations channel for immediate attention",
        "required_connector": "slack",
        "config_hints": {
          "channel": "#support-escalations"
        }
      },
      {
        "type": "slack",
        "description": "Triage summaries, auto-suggested responses, and routine ticket updates for the support team",
        "required_connector": "slack",
        "config_hints": {
          "channel": "#support-triage"
        }
      }
    ],
    "suggested_event_subscriptions": [
      {
        "event_type": "manual_review",
        "description": "Emitted when a critical or high-urgency ticket has no known resolution in the knowledge base and requires human intervention. The support team should review the ticket and provide a resolution."
      },
      {
        "event_type": "agent_memory",
        "description": "Used to persist triage state across polling cycles â€” last poll cursor, processed ticket IDs, SLA warning flags, and resolution pattern match history."
      },
      {
        "event_type": "user_message",
        "description": "Emitted when the agent encounters configuration issues (expired credentials, missing channels) that require the operator to take action."
      }
    ],
    "use_case_flows": [
      {
        "id": "flow_ticket_triage",
        "name": "Incoming Ticket Triage",
        "description": "Primary workflow: polls Zendesk for new tickets, analyzes sentiment and urgency, searches KB for resolutions, and routes appropriately via Slack.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Polling trigger fires",
            "detail": "Every 60 seconds, the agent wakes to check for new tickets"
          },
          {
            "id": "n2",
            "type": "connector",
            "label": "Fetch new tickets from Zendesk",
            "detail": "GET /api/v2/search.json with updated>{last_poll_time} filter",
            "connector": "zendesk"
          },
          {
            "id": "n3",
            "type": "decision",
            "label": "New tickets found?",
            "detail": "Check if the search returned any unprocessed tickets"
          },
          {
            "id": "n4",
            "type": "action",
            "label": "Analyze sentiment & urgency",
            "detail": "Classify ticket sentiment (angry/frustrated/neutral/positive) and urgency (critical/high/medium/low) from content"
          },
          {
            "id": "n5",
            "type": "connector",
            "label": "Search Notion knowledge base",
            "detail": "POST /v1/databases/{db_id}/query with keyword filters from ticket content",
            "connector": "notion"
          },
          {
            "id": "n6",
            "type": "decision",
            "label": "Known resolution found?",
            "detail": "Check if a KB match exists with confidence > 0.7"
          },
          {
            "id": "n7",
            "type": "decision",
            "label": "Is urgency critical or high?",
            "detail": "Determine routing channel based on urgency level"
          },
          {
            "id": "n8",
            "type": "connector",
            "label": "Post escalation to #support-escalations",
            "detail": "POST chat.postMessage with Block Kit: ticket link, sentiment badge, urgency, requester info",
            "connector": "slack"
          },
          {
            "id": "n9",
            "type": "connector",
            "label": "Add internal note to Zendesk ticket",
            "detail": "PUT /api/v2/tickets/{id}.json with private comment noting escalation and triage results",
            "connector": "zendesk"
          },
          {
            "id": "n10",
            "type": "event",
            "label": "Emit manual_review event",
            "detail": "Notify system that human review is required for this ticket"
          },
          {
            "id": "n11",
            "type": "connector",
            "label": "Post auto-suggestion to #support-triage",
            "detail": "POST chat.postMessage with suggested resolution for agent review before sending",
            "connector": "slack"
          },
          {
            "id": "n12",
            "type": "connector",
            "label": "Stage draft reply on ticket",
            "detail": "PUT /api/v2/tickets/{id}.json with public comment draft and appropriate tags",
            "connector": "zendesk"
          },
          {
            "id": "n13",
            "type": "action",
            "label": "Update agent memory with poll cursor",
            "detail": "Store last_poll_time and processed ticket IDs in agent_memory and local triage_state.json"
          },
          {
            "id": "n14",
            "type": "end",
            "label": "Triage cycle complete",
            "detail": "All fetched tickets have been processed; wait for next polling trigger"
          },
          {
            "id": "n15",
            "type": "error",
            "label": "Handle API failure",
            "detail": "Log error, queue failed actions for retry, continue processing remaining tickets"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e4",
            "source": "n3",
            "target": "n13",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e5",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e8",
            "source": "n6",
            "target": "n11",
            "label": "Yes â€” high urgency",
            "variant": "yes"
          },
          {
            "id": "e9",
            "source": "n7",
            "target": "n8",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e10",
            "source": "n7",
            "target": "n12",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e11",
            "source": "n8",
            "target": "n9"
          },
          {
            "id": "e12",
            "source": "n9",
            "target": "n10"
          },
          {
            "id": "e13",
            "source": "n10",
            "target": "n13"
          },
          {
            "id": "e14",
            "source": "n11",
            "target": "n9"
          },
          {
            "id": "e15",
            "source": "n12",
            "target": "n13"
          },
          {
            "id": "e16",
            "source": "n13",
            "target": "n14"
          },
          {
            "id": "e17",
            "source": "n2",
            "target": "n15",
            "variant": "error"
          },
          {
            "id": "e18",
            "source": "n15",
            "target": "n13",
            "variant": "error"
          }
        ]
      },
      {
        "id": "flow_kb_update",
        "name": "Knowledge Base Enrichment",
        "description": "When a ticket is resolved, extract the resolution pattern and update the Notion knowledge base to improve future auto-suggestions.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Resolved ticket detected",
            "detail": "During polling, a previously tracked ticket now has status 'solved' or 'closed'"
          },
          {
            "id": "n2",
            "type": "connector",
            "label": "Fetch full ticket with comments",
            "detail": "GET /api/v2/tickets/{id}/comments.json to retrieve the resolution thread",
            "connector": "zendesk"
          },
          {
            "id": "n3",
            "type": "action",
            "label": "Extract resolution pattern",
            "detail": "Parse problem description, root cause, and solution steps from the ticket thread"
          },
          {
            "id": "n4",
            "type": "connector",
            "label": "Search for existing KB entry",
            "detail": "POST /v1/databases/{db_id}/query filtering by matching keywords and category",
            "connector": "notion"
          },
          {
            "id": "n5",
            "type": "decision",
            "label": "Existing entry found?",
            "detail": "Check if this resolution pattern already exists in the knowledge base"
          },
          {
            "id": "n6",
            "type": "connector",
            "label": "Update existing Notion page",
            "detail": "PATCH /v1/pages/{page_id} â€” increment frequency, update Last Used date, refine resolution steps if improved",
            "connector": "notion"
          },
          {
            "id": "n7",
            "type": "connector",
            "label": "Create new Notion page",
            "detail": "POST /v1/pages with full resolution schema: title, category, problem, root cause, steps, keywords, confidence 0.8",
            "connector": "notion"
          },
          {
            "id": "n8",
            "type": "action",
            "label": "Update agent memory",
            "detail": "Record the KB update in agent memory for audit trail and trending analysis"
          },
          {
            "id": "n9",
            "type": "end",
            "label": "KB enrichment complete",
            "detail": "Knowledge base updated; future tickets with similar patterns will receive auto-suggestions"
          },
          {
            "id": "n10",
            "type": "error",
            "label": "Handle Notion write failure",
            "detail": "Cache resolution data in local file for retry on next cycle"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4"
          },
          {
            "id": "e4",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e5",
            "source": "n5",
            "target": "n6",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n7",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n8"
          },
          {
            "id": "e8",
            "source": "n7",
            "target": "n8"
          },
          {
            "id": "e9",
            "source": "n8",
            "target": "n9"
          },
          {
            "id": "e10",
            "source": "n6",
            "target": "n10",
            "variant": "error"
          },
          {
            "id": "e11",
            "source": "n7",
            "target": "n10",
            "variant": "error"
          },
          {
            "id": "e12",
            "source": "n10",
            "target": "n8",
            "variant": "error"
          }
        ]
      },
      {
        "id": "flow_sla_monitoring",
        "name": "SLA Breach Prevention",
        "description": "Monitors open tickets against SLA thresholds and sends proactive warnings before breaches occur.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Polling cycle includes SLA check",
            "detail": "SLA monitoring runs as part of each 60-second polling cycle"
          },
          {
            "id": "n2",
            "type": "action",
            "label": "Calculate SLA status for tracked tickets",
            "detail": "Compare current time against created_at + SLA threshold for each open critical/high ticket"
          },
          {
            "id": "n3",
            "type": "decision",
            "label": "Any tickets approaching breach?",
            "detail": "Critical: warn at 30min remaining. High: warn at 1hr remaining."
          },
          {
            "id": "n4",
            "type": "decision",
            "label": "Warning already sent?",
            "detail": "Check agent memory to prevent duplicate SLA warnings for the same ticket"
          },
          {
            "id": "n5",
            "type": "connector",
            "label": "Fetch current ticket status",
            "detail": "GET /api/v2/tickets/{id}.json to check assignee and latest status",
            "connector": "zendesk"
          },
          {
            "id": "n6",
            "type": "connector",
            "label": "Post SLA warning to Slack",
            "detail": "POST chat.postMessage to #support-escalations with time remaining, ticket link, assignee mention",
            "connector": "slack"
          },
          {
            "id": "n7",
            "type": "action",
            "label": "Mark warning sent in agent memory",
            "detail": "Record ticket ID and warning timestamp to prevent duplicate alerts"
          },
          {
            "id": "n8",
            "type": "end",
            "label": "SLA check complete",
            "detail": "All tracked tickets checked against SLA thresholds"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e4",
            "source": "n3",
            "target": "n8",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e5",
            "source": "n4",
            "target": "n5",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e6",
            "source": "n4",
            "target": "n8",
            "label": "Yes â€” skip",
            "variant": "yes"
          },
          {
            "id": "e7",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e8",
            "source": "n6",
            "target": "n7"
          },
          {
            "id": "e9",
            "source": "n7",
            "target": "n8"
          }
        ]
      }
    ]
  }
}
