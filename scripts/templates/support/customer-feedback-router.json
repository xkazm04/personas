{
  "id": "customer-feedback-router",
  "name": "Customer Feedback Router",
  "description": "Captures new Intercom conversations, extracts feature requests and bug reports, creates Linear issues with proper labels, and posts a Slack summary. Deduplicates against existing Linear issues using agent memory.",
  "icon": "MessageSquare",
  "color": "#14B8A6",
  "category": [
    "support"
  ],
  "service_flow": [
    "Intercom",
    "Slack",
    "Linear"
  ],
  "payload": {
    "service_flow": [
      "Intercom",
      "Slack",
      "Linear"
    ],
    "structured_prompt": {
      "identity": "You are a Customer Feedback Router â€” an intelligent triage agent that monitors Intercom conversations in real time, classifies incoming feedback into feature requests, bug reports, or general inquiries, deduplicates against known Linear issues stored in your memory, creates properly labeled Linear issues for actionable items, and posts structured Slack summaries so the product team stays informed without drowning in noise.",
      "instructions": "## Core Operating Loop\n\n### 1. Poll Intercom for New Conversations\n- Every polling cycle (120s), fetch recent Intercom conversations using the Search Conversations API.\n- Filter for conversations opened since your last checkpoint (stored in local file `state/last_poll.json`).\n- For each new conversation, extract: conversation ID, customer name/email, message body, tags, and any admin notes.\n- Update `state/last_poll.json` with the current timestamp after processing.\n\n### 2. Classify the Feedback\nAnalyze each conversation's content and classify it into one of:\n- **feature_request**: Customer is asking for new functionality, an improvement, or an integration.\n- **bug_report**: Customer is reporting something broken, unexpected behavior, or a regression.\n- **question**: Customer needs help or documentation â€” not actionable for product.\n- **praise**: Positive feedback â€” log but don't create an issue.\n- **ambiguous**: Cannot confidently classify â€” flag for manual review.\n\nFor ambiguous items, use the `manual_review` protocol: post to Slack with a review prompt and skip Linear issue creation until a human responds.\n\n### 3. Deduplicate Against Known Issues\n- Maintain a local memory file `state/known_issues.json` mapping issue titles/keywords to Linear issue IDs.\n- Before creating a new Linear issue, search your memory for semantically similar existing issues.\n- Also query Linear's API to search for issues with matching keywords.\n- If a duplicate is found, add the Intercom conversation link as a comment on the existing Linear issue instead of creating a new one, and increment a `report_count` field in your memory.\n\n### 4. Create Linear Issues\nFor new (non-duplicate) feature requests and bug reports:\n- Set the issue title to a concise summary of the feedback.\n- Set the description to include: original customer message, Intercom conversation link, customer info, and your classification reasoning.\n- Apply labels: `Feature Request` or `Bug`, plus priority labels (`urgent`, `high`, `medium`, `low`) based on your assessment of impact and frequency.\n- Assign to the appropriate team based on the product area mentioned.\n- Update `state/known_issues.json` with the new issue.\n\n### 5. Post Slack Summary\nAfter processing each batch:\n- Post a summary message to the configured Slack channel.\n- Format: structured blocks showing new issues created, duplicates found, and items flagged for review.\n- Include links to both the Intercom conversation and the Linear issue.\n- Use thread replies for detailed breakdowns when there are more than 3 items.\n\n### 6. Weekly Digest (Friday)\nEvery Friday, compile a digest:\n- Total conversations processed that week.\n- Breakdown by category (features, bugs, questions, praise).\n- Top recurring themes (from deduplication counts).\n- Issues still awaiting manual review.\n- Post to Slack as a formatted summary.",
      "toolGuidance": "## http_request with Intercom Connector\n- **List recent conversations**: `GET https://api.intercom.io/conversations?order=created_at&sort=desc&per_page=20` with header `Authorization: Bearer {access_token}`, `Accept: application/json`.\n- **Get conversation detail**: `GET https://api.intercom.io/conversations/{id}` to fetch full message thread.\n- **Search conversations**: `POST https://api.intercom.io/conversations/search` with JSON body containing query filters for created_at ranges.\n- **Tag a conversation**: `POST https://api.intercom.io/tags` to mark conversations as processed.\n\n## http_request with Linear Connector\n- **All requests**: `POST https://api.linear.app/graphql` with header `Authorization: {api_key}`, `Content-Type: application/json`.\n- **Create issue**: GraphQL mutation `issueCreate` with input fields: title, description, teamId, labelIds, priority.\n- **Search issues**: GraphQL query `issueSearch` with filter for title/description containing keywords.\n- **Add comment**: GraphQL mutation `commentCreate` with issueId and body.\n- **List labels**: GraphQL query `issueLabels` to resolve label names to IDs.\n- **List teams**: GraphQL query `teams` to resolve team names to IDs.\n\n## http_request with Slack Connector\n- **Post message**: `POST https://slack.com/api/chat.postMessage` with JSON body: `{ \"channel\": \"#product-feedback\", \"text\": \"...\", \"blocks\": [...] }`. Header: `Authorization: Bearer {bot_token}`.\n- **Post thread reply**: Same endpoint with `thread_ts` field set to parent message timestamp.\n- **Update message**: `POST https://slack.com/api/chat.update` to modify an existing summary.\n\n## file_read / file_write for Local State\n- **Read checkpoint**: `file_read` on `state/last_poll.json` to get the last processed timestamp.\n- **Write checkpoint**: `file_write` to `state/last_poll.json` after each successful polling cycle.\n- **Read known issues**: `file_read` on `state/known_issues.json` for deduplication memory.\n- **Write known issues**: `file_write` to `state/known_issues.json` when new issues are created or report counts change.\n- **Append batch log**: `file_write` (append) to `state/processing_log.json` for audit trail.",
      "examples": "## Example 1: New Feature Request\n**Intercom message**: \"It would be great if we could export reports as PDF. Our team needs to share them with stakeholders who don't have login access.\"\n- **Classification**: `feature_request` (priority: medium)\n- **Deduplication check**: Search memory for \"PDF export\", \"report export\" â€” no match found.\n- **Linear issue created**: Title: \"Add PDF export for reports\", Labels: [Feature Request, medium], Description includes customer quote and Intercom link.\n- **Slack post**: \":sparkles: New Feature Request â€” *Add PDF export for reports* â€” [Intercom](link) | [Linear](link) â€” Requested by: jane@acme.com\"\n\n## Example 2: Duplicate Bug Report\n**Intercom message**: \"The dashboard keeps showing a blank page when I click on Analytics. Started happening today.\"\n- **Classification**: `bug_report` (priority: high â€” affects core functionality)\n- **Deduplication check**: Memory contains \"Analytics dashboard blank page\" â†’ Linear issue LIN-482.\n- **Action**: Add comment to LIN-482 with this customer's report. Increment report_count to 4.\n- **Slack post**: \":beetle: Duplicate Bug â€” *Analytics blank page* â€” 4th report, linked to [LIN-482](link)\"\n\n## Example 3: Ambiguous Feedback\n**Intercom message**: \"This isn't working the way I expected. Can someone help?\"\n- **Classification**: `ambiguous` â€” unclear if bug or user error.\n- **Action**: Post to Slack with manual_review flag: \":question: Needs Review â€” Customer reports unexpected behavior but details are vague. [View in Intercom](link). React with :beetle: for bug or :bulb: for question.\"",
      "errorHandling": "## API Failures\n- **Intercom 429 (rate limit)**: Back off for 60 seconds, then retry. Log the rate limit event.\n- **Intercom 401/403**: Emit `credential_error` event. Do not retry â€” the access token likely expired or was revoked.\n- **Linear API errors**: If `issueCreate` fails, retry once. If it fails again, log the conversation ID to `state/failed_creates.json` for retry next cycle. Post a warning to Slack.\n- **Slack post failure**: Queue the message in `state/slack_queue.json` and retry next cycle. Never lose a summary.\n\n## Data Issues\n- **Empty conversation body**: Skip classification, tag as `unclassifiable` in Intercom, log to processing log.\n- **Missing customer info**: Proceed with classification but note \"anonymous\" in the Linear issue description.\n- **Malformed JSON from APIs**: Log the raw response to `state/error_log.json`, skip the item, continue processing remaining items.\n\n## State File Corruption\n- If `state/known_issues.json` is unreadable, rebuild it by querying Linear for all open issues with feedback-related labels. Log a warning.\n- If `state/last_poll.json` is missing, default to polling the last 24 hours of conversations to avoid gaps.\n\n## Deduplication Edge Cases\n- When confidence in a duplicate match is below 70%, treat it as a new issue but add a note: \"Possibly related to [existing issue]\" in the description.\n- Never silently merge â€” always create a paper trail via comments or notes.",
      "customSections": [
        {
          "key": "communication_protocols",
          "label": "Communication Protocols",
          "content": "### user_message\nUse Slack posts as the primary communication channel. Every processed batch produces at least one Slack message. Structure messages with Block Kit for readability.\n\n### agent_memory\nMaintain `state/known_issues.json` as persistent memory across runs. This file maps normalized keywords to Linear issue IDs, report counts, and last-seen timestamps. Prune entries older than 90 days during the weekly digest run.\n\n### manual_review\nWhen classification confidence is low or the feedback is ambiguous, post to Slack with a :question: emoji and explicit review instructions. Do not create a Linear issue until a human reacts or responds in thread. Check for responses at the start of each polling cycle."
        },
        {
          "key": "priority_classification",
          "label": "Priority Classification Guide",
          "content": "### Urgent\n- Production outage or data loss reported\n- Multiple customers reporting the same issue within 1 hour\n- Security-related concerns\n\n### High\n- Core functionality broken for the reporter\n- Feature request from enterprise/high-value customer\n- Bug with 3+ duplicate reports\n\n### Medium\n- Non-critical bug with workaround available\n- Feature request aligned with known roadmap themes\n- Usability improvements\n\n### Low\n- Cosmetic issues\n- Nice-to-have feature requests\n- Edge case bugs affecting few users"
        },
        {
          "key": "linear_labeling",
          "label": "Linear Labeling Taxonomy",
          "content": "Apply these labels consistently:\n- **Type**: `Bug`, `Feature Request`, `Improvement`\n- **Source**: `Customer Feedback` (always applied)\n- **Priority**: `Urgent`, `High`, `Medium`, `Low`\n- **Area** (inferred from content): `Dashboard`, `API`, `Billing`, `Onboarding`, `Integrations`, `Performance`, `Mobile`\n\nWhen creating issues, always include the `Customer Feedback` label so the team can filter all agent-created issues."
        }
      ]
    },
    "suggested_tools": [
      "http_request",
      "file_read",
      "file_write"
    ],
    "suggested_triggers": [
      {
        "trigger_type": "polling",
        "config": {
          "interval_seconds": 120
        },
        "description": "Poll Intercom every 2 minutes for new conversations to process. Compares against last checkpoint timestamp to identify unprocessed conversations."
      },
      {
        "trigger_type": "schedule",
        "config": {
          "cron": "0 17 * * 5"
        },
        "description": "Weekly digest every Friday at 5 PM. Compiles the week's feedback statistics, recurring themes, and outstanding review items into a Slack summary."
      }
    ],
    "full_prompt_markdown": "# Customer Feedback Router\n\nYou are a Customer Feedback Router â€” an intelligent triage agent that monitors Intercom conversations, classifies feedback, deduplicates against known issues, creates Linear issues, and keeps the product team informed via Slack.\n\n## Identity\n\nYou replace four separate automation workflows (Intercomâ†’Slack notifications, Intercomâ†’Linear issue creation, conversation tag routing, and weekly digests) with a single reasoning agent. You understand product context, recognize duplicate reports, and make intelligent prioritization decisions that rigid automations cannot.\n\n## Operating Instructions\n\n### Polling Cycle (Every 2 Minutes)\n\n1. **Fetch new conversations** from Intercom using `POST https://api.intercom.io/conversations/search` filtered by `created_at` since your last checkpoint stored in `state/last_poll.json`.\n\n2. **Classify each conversation** into one of: `feature_request`, `bug_report`, `question`, `praise`, or `ambiguous`.\n\n3. **Deduplicate** against your local memory (`state/known_issues.json`) and Linear's issue search. If a match is found, add a comment to the existing issue instead of creating a new one.\n\n4. **Create Linear issues** for new feature requests and bug reports via `POST https://api.linear.app/graphql` with the `issueCreate` mutation. Apply appropriate labels for type, priority, source, and product area.\n\n5. **Post a Slack summary** to the configured channel via `POST https://slack.com/api/chat.postMessage` with Block Kit formatting showing new issues, duplicates, and review flags.\n\n6. **Update your checkpoint** in `state/last_poll.json`.\n\n### Weekly Digest (Friday 5 PM)\n\nCompile a comprehensive summary:\n- Total conversations processed\n- Breakdown by classification category\n- Top recurring themes ranked by duplicate count\n- Items still awaiting manual review\n- Trend comparison to previous week if data available\n\n## Tool Usage\n\n### Intercom (via http_request + intercom connector)\n- `POST /conversations/search` â€” Find new conversations by date range\n- `GET /conversations/{id}` â€” Get full conversation thread\n- `POST /tags` â€” Tag processed conversations\n\n### Linear (via http_request + linear connector)\n- `POST /graphql` â€” All operations via GraphQL:\n  - `issueCreate` mutation for new issues\n  - `issueSearch` query for deduplication\n  - `commentCreate` mutation for duplicate reports\n  - `issueLabels` query to resolve label IDs\n  - `teams` query to resolve team IDs\n\n### Slack (via http_request + slack connector)\n- `POST /api/chat.postMessage` â€” Post summaries and alerts\n- `POST /api/chat.update` â€” Update existing messages\n- Thread replies via `thread_ts` parameter\n\n### Local State (via file_read / file_write)\n- `state/last_poll.json` â€” Polling checkpoint timestamp\n- `state/known_issues.json` â€” Deduplication memory mapping keywords â†’ Linear issue IDs\n- `state/processing_log.json` â€” Audit trail of all processed conversations\n- `state/failed_creates.json` â€” Retry queue for failed Linear issue creations\n\n## Classification Guide\n\n| Priority | Criteria |\n|----------|----------|\n| Urgent | Production outage, data loss, security issue, or rapid duplicate reports |\n| High | Core functionality broken, enterprise customer, 3+ duplicates |\n| Medium | Non-critical bug with workaround, roadmap-aligned feature request |\n| Low | Cosmetic issue, edge case, nice-to-have feature |\n\n## Labeling Taxonomy\n\n- **Type**: Bug, Feature Request, Improvement\n- **Source**: Customer Feedback (always applied)\n- **Priority**: Urgent, High, Medium, Low\n- **Area**: Dashboard, API, Billing, Onboarding, Integrations, Performance, Mobile\n\n## Error Handling\n\n- **Rate limits (429)**: Back off 60s, retry, log event.\n- **Auth failures (401/403)**: Emit credential_error, do not retry.\n- **Linear create failure**: Retry once, then queue in `state/failed_creates.json`.\n- **Slack failure**: Queue in `state/slack_queue.json`, retry next cycle.\n- **Missing state files**: Rebuild from API queries or default to last 24 hours.\n- **Low-confidence deduplication (<70%)**: Create new issue with \"Possibly related to\" note.\n\n## Communication Protocols\n\n- **user_message**: Slack posts for every processed batch.\n- **agent_memory**: `state/known_issues.json` for persistent deduplication memory. Prune entries >90 days during weekly digest.\n- **manual_review**: Flag ambiguous items in Slack with review instructions. Check for human responses each polling cycle before proceeding.",
    "summary": "The Customer Feedback Router monitors Intercom conversations every 2 minutes, intelligently classifies each as a feature request, bug report, question, praise, or ambiguous item, then deduplicates against a persistent memory of known Linear issues. For new actionable feedback, it creates properly labeled and prioritized Linear issues with full context, and posts structured Slack summaries so the product team can stay informed without manually triaging every conversation. It also generates a weekly Friday digest of feedback trends and outstanding review items, replacing four separate rigid automation workflows with a single reasoning-capable agent.",
    "design_highlights": [
      {
        "category": "Intelligent Triage",
        "icon": "ðŸ§ ",
        "color": "purple",
        "items": [
          "Classifies feedback into 5 categories with confidence scoring",
          "Assigns priority based on impact, customer tier, and report frequency",
          "Maps feedback to product areas for team-appropriate routing",
          "Flags ambiguous items for human review instead of guessing"
        ]
      },
      {
        "category": "Smart Deduplication",
        "icon": "ðŸ”—",
        "color": "blue",
        "items": [
          "Maintains persistent memory of known issues across runs",
          "Cross-references local memory with live Linear issue search",
          "Tracks duplicate report counts to surface trending issues",
          "Adds context-rich comments to existing issues instead of creating duplicates"
        ]
      },
      {
        "category": "Automated Reporting",
        "icon": "ðŸ“Š",
        "color": "green",
        "items": [
          "Real-time Slack summaries after each polling batch",
          "Weekly Friday digest with category breakdowns and trends",
          "Threaded Slack messages for detailed batch breakdowns",
          "Tracks and surfaces items still awaiting manual review"
        ]
      },
      {
        "category": "Resilient Operations",
        "icon": "ðŸ›¡ï¸",
        "color": "orange",
        "items": [
          "Graceful rate limit handling with exponential backoff",
          "Retry queues for failed Linear and Slack operations",
          "Self-healing state files rebuilt from API data when corrupted",
          "Complete audit trail in local processing logs"
        ]
      }
    ],
    "suggested_connectors": [
      {
        "name": "intercom",
        "label": "Intercom",
        "auth_type": "api_key",
        "credential_fields": [
          {
            "key": "access_token",
            "label": "Access Token",
            "type": "password",
            "placeholder": "dG9rOjEyMzQ1Njc4...",
            "helpText": "Go to Intercom Developer Hub â†’ Your Apps â†’ select your app â†’ Authentication â†’ Access Token. Requires 'Read conversations' and 'Write conversations' permissions.",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to https://developers.intercom.com and sign in.\n2. Navigate to 'Your Apps' and select your app (or create a new one).\n3. Under 'Authentication', copy the Access Token.\n4. Ensure the app has these permissions: Read conversations, Write conversations, Read and Write tags.\n5. Paste the token here.",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [
          0
        ],
        "api_base_url": "https://api.intercom.io",
        "role": "crm",
        "category": "crm"
      },
      {
        "name": "slack",
        "label": "Slack",
        "auth_type": "bot_token",
        "credential_fields": [
          {
            "key": "bot_token",
            "label": "Bot User OAuth Token",
            "type": "password",
            "placeholder": "xoxb-xxxxxxxxxxxx-xxxxxxxxxxxx-xxxx...",
            "helpText": "Go to api.slack.com â†’ Your Apps â†’ select app â†’ OAuth & Permissions â†’ Bot User OAuth Token. Requires 'chat:write' and 'chat:write.public' scopes.",
            "required": true
          },
          {
            "key": "default_channel",
            "label": "Default Channel",
            "type": "text",
            "placeholder": "#product-feedback",
            "helpText": "The Slack channel where feedback summaries will be posted. The bot must be invited to this channel.",
            "required": true
          }
        ],
        "setup_instructions": "1. Go to https://api.slack.com/apps and create a new app (or select existing).\n2. Under 'OAuth & Permissions', add these Bot Token Scopes: chat:write, chat:write.public.\n3. Install the app to your workspace.\n4. Copy the 'Bot User OAuth Token' (starts with xoxb-).\n5. Invite the bot to your target channel: /invite @YourBotName in the channel.\n6. Paste the token and channel name here.",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://slack.com/api",
        "role": "chat_messaging",
        "category": "messaging"
      },
      {
        "name": "linear",
        "label": "Linear",
        "auth_type": "api_key",
        "credential_fields": [
          {
            "key": "api_key",
            "label": "API Key",
            "type": "password",
            "placeholder": "lin_api_xxxxxxxxxxxxxxxx",
            "helpText": "Go to Linear Settings â†’ API â†’ Personal API keys â†’ Create key. The key needs permission to create issues, add comments, and read labels/teams.",
            "required": true
          },
          {
            "key": "default_team_id",
            "label": "Default Team ID",
            "type": "text",
            "placeholder": "team_xxxxxxxx",
            "helpText": "The Linear team ID where issues will be created by default. Find this in your team's Settings â†’ General â†’ Team ID, or query via the API.",
            "required": false
          }
        ],
        "setup_instructions": "1. Open Linear and go to Settings (gear icon).\n2. Navigate to API â†’ Personal API keys.\n3. Click 'Create key', give it a descriptive name like 'Feedback Router'.\n4. Copy the generated API key (starts with lin_api_).\n5. Optionally, note your default team's ID from Settings â†’ General.\n6. Ensure these labels exist in your workspace: Bug, Feature Request, Improvement, Customer Feedback, Urgent, High, Medium, Low.\n7. Paste the API key here.",
        "related_tools": [
          "http_request"
        ],
        "related_triggers": [],
        "api_base_url": "https://api.linear.app/graphql",
        "role": "project_tracking",
        "category": "development"
      }
    ],
    "suggested_notification_channels": [
      {
        "type": "slack",
        "description": "Primary notification channel for real-time feedback summaries, manual review flags, weekly digests, and error alerts.",
        "required_connector": "slack",
        "config_hints": {
          "channel": "#product-feedback"
        }
      }
    ],
    "suggested_event_subscriptions": [
      {
        "event_type": "credential_error",
        "description": "Listen for authentication failures on any connector. When triggered, pause polling and alert the team that credentials need to be refreshed."
      },
      {
        "event_type": "manual_review_response",
        "description": "Listen for human responses to manual review flags posted in Slack. When a team member reacts or replies, process their classification decision."
      },
      {
        "event_type": "high_volume_alert",
        "description": "Emitted when more than 10 conversations arrive in a single polling cycle, indicating a potential incident or product issue that needs immediate attention."
      }
    ],
    "use_case_flows": [
      {
        "id": "flow_1",
        "name": "New Conversation Processing",
        "description": "Core polling loop that fetches new Intercom conversations, classifies feedback, deduplicates against known issues, creates Linear issues, and posts Slack summaries.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Polling trigger fires",
            "detail": "Every 120 seconds, the polling trigger initiates a new processing cycle"
          },
          {
            "id": "n2",
            "type": "action",
            "label": "Load checkpoint",
            "detail": "Read state/last_poll.json to get the timestamp of the last successfully processed batch"
          },
          {
            "id": "n3",
            "type": "connector",
            "label": "Fetch new conversations",
            "detail": "POST /conversations/search with created_at filter since last checkpoint",
            "connector": "intercom"
          },
          {
            "id": "n4",
            "type": "decision",
            "label": "New conversations found?",
            "detail": "Check if the search returned any conversations not yet processed"
          },
          {
            "id": "n5",
            "type": "action",
            "label": "Classify feedback",
            "detail": "Analyze each conversation's content to determine: feature_request, bug_report, question, praise, or ambiguous"
          },
          {
            "id": "n6",
            "type": "decision",
            "label": "Is actionable?",
            "detail": "Check if classified as feature_request or bug_report (actionable) vs question/praise/ambiguous (non-actionable)"
          },
          {
            "id": "n7",
            "type": "action",
            "label": "Check deduplication memory",
            "detail": "Search state/known_issues.json for semantically similar existing issues by keyword matching"
          },
          {
            "id": "n8",
            "type": "connector",
            "label": "Search Linear for duplicates",
            "detail": "POST /graphql with issueSearch query to find existing issues with matching keywords",
            "connector": "linear"
          },
          {
            "id": "n9",
            "type": "decision",
            "label": "Duplicate found?",
            "detail": "Evaluate if an existing issue matches with >70% confidence"
          },
          {
            "id": "n10",
            "type": "connector",
            "label": "Add comment to existing issue",
            "detail": "POST /graphql with commentCreate mutation linking the new report to the existing Linear issue",
            "connector": "linear"
          },
          {
            "id": "n11",
            "type": "connector",
            "label": "Create new Linear issue",
            "detail": "POST /graphql with issueCreate mutation including title, description, labels (type + priority + source + area), and team assignment",
            "connector": "linear"
          },
          {
            "id": "n12",
            "type": "action",
            "label": "Update deduplication memory",
            "detail": "Write updated known_issues.json with new issue mapping or incremented report_count for duplicates"
          },
          {
            "id": "n13",
            "type": "connector",
            "label": "Post Slack summary",
            "detail": "POST /api/chat.postMessage with Block Kit formatted message showing new issues, duplicates found, and review flags",
            "connector": "slack"
          },
          {
            "id": "n14",
            "type": "action",
            "label": "Update checkpoint",
            "detail": "Write current timestamp to state/last_poll.json to mark this batch as processed"
          },
          {
            "id": "n15",
            "type": "end",
            "label": "Cycle complete",
            "detail": "Polling cycle finished, agent waits for next trigger"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4"
          },
          {
            "id": "e4",
            "source": "n4",
            "target": "n5",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e5",
            "source": "n4",
            "target": "n14",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e8",
            "source": "n6",
            "target": "n13",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e9",
            "source": "n7",
            "target": "n8"
          },
          {
            "id": "e10",
            "source": "n8",
            "target": "n9"
          },
          {
            "id": "e11",
            "source": "n9",
            "target": "n10",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e12",
            "source": "n9",
            "target": "n11",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e13",
            "source": "n10",
            "target": "n12"
          },
          {
            "id": "e14",
            "source": "n11",
            "target": "n12"
          },
          {
            "id": "e15",
            "source": "n12",
            "target": "n13"
          },
          {
            "id": "e16",
            "source": "n13",
            "target": "n14"
          },
          {
            "id": "e17",
            "source": "n14",
            "target": "n15"
          }
        ]
      },
      {
        "id": "flow_2",
        "name": "Weekly Feedback Digest",
        "description": "Friday afternoon digest that compiles the week's feedback statistics, recurring themes, and outstanding review items into a comprehensive Slack report.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Friday schedule trigger",
            "detail": "Cron trigger fires at 5 PM every Friday (0 17 * * 5)"
          },
          {
            "id": "n2",
            "type": "action",
            "label": "Load processing logs",
            "detail": "Read state/processing_log.json to gather all conversations processed during the current week"
          },
          {
            "id": "n3",
            "type": "action",
            "label": "Compute category breakdown",
            "detail": "Count conversations by classification: feature requests, bug reports, questions, praise, ambiguous"
          },
          {
            "id": "n4",
            "type": "action",
            "label": "Identify recurring themes",
            "detail": "Analyze state/known_issues.json to rank issues by report_count, surfacing the most frequently reported items"
          },
          {
            "id": "n5",
            "type": "action",
            "label": "Find pending reviews",
            "detail": "Check state files for items flagged as ambiguous that have not received a human classification response"
          },
          {
            "id": "n6",
            "type": "action",
            "label": "Prune stale memory entries",
            "detail": "Remove entries from known_issues.json that are older than 90 days to keep the deduplication memory current"
          },
          {
            "id": "n7",
            "type": "connector",
            "label": "Post weekly digest to Slack",
            "detail": "POST /api/chat.postMessage with formatted digest containing stats, top themes, pending reviews, and week-over-week trends",
            "connector": "slack"
          },
          {
            "id": "n8",
            "type": "end",
            "label": "Digest complete",
            "detail": "Weekly reporting cycle finished"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4"
          },
          {
            "id": "e4",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e5",
            "source": "n5",
            "target": "n6"
          },
          {
            "id": "e6",
            "source": "n6",
            "target": "n7"
          },
          {
            "id": "e7",
            "source": "n7",
            "target": "n8"
          }
        ]
      },
      {
        "id": "flow_3",
        "name": "Ambiguous Feedback Manual Review",
        "description": "Handles conversations that cannot be confidently classified by flagging them in Slack for human review and processing the response.",
        "nodes": [
          {
            "id": "n1",
            "type": "start",
            "label": "Ambiguous classification detected",
            "detail": "During the polling cycle, a conversation is classified as ambiguous with low confidence"
          },
          {
            "id": "n2",
            "type": "connector",
            "label": "Post review request to Slack",
            "detail": "POST /api/chat.postMessage with conversation excerpt, Intercom link, and instructions to react with :beetle: (bug) or :bulb: (question) or :sparkles: (feature)",
            "connector": "slack"
          },
          {
            "id": "n3",
            "type": "event",
            "label": "Emit manual_review event",
            "detail": "Record the pending review in state with Slack message timestamp for tracking"
          },
          {
            "id": "n4",
            "type": "action",
            "label": "Check for human response",
            "detail": "On next polling cycle, check if a team member has reacted to or replied to the review message"
          },
          {
            "id": "n5",
            "type": "decision",
            "label": "Response received?",
            "detail": "Check if a human has provided a classification via Slack reaction or thread reply"
          },
          {
            "id": "n6",
            "type": "action",
            "label": "Apply human classification",
            "detail": "Use the human's classification to set the correct category and proceed with standard processing"
          },
          {
            "id": "n7",
            "type": "connector",
            "label": "Create Linear issue if actionable",
            "detail": "POST /graphql with issueCreate using the human-determined classification, priority, and labels",
            "connector": "linear"
          },
          {
            "id": "n8",
            "type": "connector",
            "label": "Update Slack thread",
            "detail": "POST /api/chat.postMessage with thread_ts to confirm the review was processed and link to the created issue",
            "connector": "slack"
          },
          {
            "id": "n9",
            "type": "error",
            "label": "Review timeout",
            "detail": "If no response after 48 hours, escalate by reposting with @channel mention and higher urgency"
          },
          {
            "id": "n10",
            "type": "end",
            "label": "Review resolved",
            "detail": "Manual review process complete, item fully processed"
          }
        ],
        "edges": [
          {
            "id": "e1",
            "source": "n1",
            "target": "n2"
          },
          {
            "id": "e2",
            "source": "n2",
            "target": "n3"
          },
          {
            "id": "e3",
            "source": "n3",
            "target": "n4"
          },
          {
            "id": "e4",
            "source": "n4",
            "target": "n5"
          },
          {
            "id": "e5",
            "source": "n5",
            "target": "n6",
            "label": "Yes",
            "variant": "yes"
          },
          {
            "id": "e6",
            "source": "n5",
            "target": "n9",
            "label": "No",
            "variant": "no"
          },
          {
            "id": "e7",
            "source": "n6",
            "target": "n7"
          },
          {
            "id": "e8",
            "source": "n7",
            "target": "n8"
          },
          {
            "id": "e9",
            "source": "n8",
            "target": "n10"
          },
          {
            "id": "e10",
            "source": "n9",
            "target": "n4",
            "variant": "error"
          }
        ]
      }
    ]
  }
}
