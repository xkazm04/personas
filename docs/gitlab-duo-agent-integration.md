# GitLab Duo Agent Integration

Deploy your Personas Desktop agents as GitLab Duo Agents directly from the app.

## Overview

The GitLab integration lets you export any persona — including its system prompt, tools, and metadata — to a GitLab project as a Duo Agent. It uses a dual-path deployment strategy:

| Path | When used | How it works |
|------|-----------|--------------|
| **Duo Agent API** (primary) | GitLab 17.0+ with Duo enabled | Native API creates a first-class agent in the project |
| **AGENTS.md** (fallback) | API unavailable or unsupported | Commits a markdown file describing the agent to the repo |

The fallback is automatic — if the API call fails for any reason, the system switches to the file-based path without user intervention.

---

## Prerequisites

- **GitLab account** on gitlab.com (SaaS)
- **Personal Access Token (PAT)** with the `api` scope
- **Developer access** (or higher) to the target project

### Creating a Personal Access Token

1. Go to **GitLab > User Settings > Access Tokens**
   (`https://gitlab.com/-/user_settings/personal_access_tokens`)
2. Give it a name (e.g. "Personas Desktop")
3. Select the **`api`** scope
4. Click **Create personal access token**
5. Copy the token (`glpat-...`) — you won't see it again

---

## Quick Start

### 1. Connect

Open the **GitLab** section in the sidebar and paste your PAT into the token field. Press **Connect to GitLab**. The app validates the token against `GET /api/v4/user` and, on success, stores it securely in your OS keyring (Windows Credential Manager / macOS Keychain / Linux Secret Service).

### 2. Deploy

Switch to the **Deploy** tab. Select a target project and a persona, then click **Deploy to GitLab**.

Optionally, enable **Provision API credentials** to push the persona's tool credentials to the GitLab project as masked CI/CD variables. This allows the deployed agent to authenticate with external services (OpenAI, Slack, etc.) at runtime.

Behind the scenes:

1. The persona's system prompt is assembled from its identity, instructions, tool guidance, examples, and error handling sections.
2. Each tool is converted to the GitLab agent tool format with its name, description, and input schema.
3. Metadata is attached: `{ source: "personas-desktop", version: "<app version>", persona_id: "<id>" }`.
4. If credential provisioning is enabled, credentials are resolved, decrypted, and pushed as masked CI/CD variables (see [Credential Provisioning](#credential-provisioning) below).
5. The app tries the Duo Agent API first. If that fails, it falls back to committing an `AGENTS.md` file to the project's default branch.

### 3. Manage

Switch to the **Agents** tab to see deployed Duo Agents for the selected project. From here you can:

- **Open in GitLab** — view the agent in the GitLab UI
- **Undeploy** — remove the agent via the API

---

## How Deployment Works

### Primary Path: Duo Agent API

```
POST /api/v4/projects/:id/duo/agents
```

The request body is a JSON object built from the persona:

```json
{
  "name": "My Agent",
  "description": "Monitors CI pipelines and reports failures",
  "system_prompt": "# Persona: My Agent\n\n## Identity\n...",
  "model": "claude-sonnet-4-5-20250929",
  "tools": [
    {
      "name": "read_file",
      "description": "Read a file from the repository",
      "input_schema": { "type": "object", "properties": { "path": { "type": "string" } } }
    }
  ],
  "metadata": {
    "source": "personas-desktop",
    "version": "0.1.5",
    "persona_id": "abc-123"
  }
}
```

On success the API returns an agent ID and web URL. The result card in the UI links directly to the agent in GitLab.

### Fallback Path: AGENTS.md

If the Duo Agent API returns an error (404, 403, feature not available, etc.), the app automatically:

1. Fetches the project's default branch name
2. Generates a markdown representation of the agent
3. Commits it as `AGENTS.md` to the repository root

The generated file looks like:

```markdown
# AGENTS.md

<!-- Generated by Personas Desktop -->

## Agent: My Agent

**Description:** Monitors CI pipelines and reports failures

### System Prompt

\```
# Persona: My Agent
...full assembled prompt...
\```

### Tools

- **read_file**: Read a file from the repository
- **run_command**: Execute a shell command

---
*Source: Personas Desktop v0.1.5*
```

The upsert logic tries `PUT` first (update existing file), and falls back to `POST` (create new file) if the file doesn't exist yet.

---

## Architecture

### Data Flow

```
UI Component (GitLabPanel)
  -> Zustand Store (gitlabSlice)
    -> API Layer (src/api/gitlab.ts)
      -> Tauri IPC (invoke)
        -> Rust Command (commands/infrastructure/gitlab.rs)
          -> GitLab Client (gitlab/client.rs)
            -> GitLab REST API v4
```

### Backend Modules

| File | Purpose |
|------|---------|
| `src-tauri/src/gitlab/client.rs` | HTTP client wrapping all GitLab API v4 endpoints |
| `src-tauri/src/gitlab/types.rs` | Shared types with `#[derive(TS)]` for TypeScript binding generation |
| `src-tauri/src/gitlab/converter.rs` | Converts a `Persona` + tools into `GitLabAgentDefinition` or AGENTS.md |
| `src-tauri/src/gitlab/config.rs` | OS keyring storage for the PAT |
| `src-tauri/src/commands/infrastructure/gitlab.rs` | Tauri command handlers (8 commands) |

### Frontend Modules

| File | Purpose |
|------|---------|
| `src/api/gitlab.ts` | Typed `invoke()` wrappers |
| `src/stores/slices/gitlabSlice.ts` | Zustand state slice (state + actions) |
| `src/features/gitlab/components/GitLabPanel.tsx` | Main panel with Connection / Deploy / Agents tabs |
| `src/features/gitlab/components/GitLabConnectionForm.tsx` | PAT input and connection status |
| `src/features/gitlab/components/GitLabDeployModal.tsx` | Project picker, persona picker, deploy button |
| `src/features/gitlab/components/GitLabAgentList.tsx` | Lists deployed agents with undeploy action |

### Tauri Commands

| Command | Returns | Description |
|---------|---------|-------------|
| `gitlab_connect` | `GitLabUser` | Validate PAT, store in keyring, init client |
| `gitlab_disconnect` | `()` | Clear keyring, drop client |
| `gitlab_get_config` | `Option<GitLabConfig>` | Current connection state |
| `gitlab_list_projects` | `Vec<GitLabProject>` | Projects with Developer+ access |
| `gitlab_deploy_persona` | `GitLabDeployResult` | Deploy via API or AGENTS.md fallback; optionally provision credentials |
| `gitlab_revoke_credentials` | `u32` | Delete provisioned CI/CD variables from a project |
| `gitlab_list_agents` | `Vec<GitLabAgent>` | Duo Agents in a project (empty if API unavailable) |
| `gitlab_undeploy_agent` | `()` | Delete a Duo Agent |

---

## Credential Provisioning

Deployed Duo Agents need API keys to call external services (OpenAI, Slack, GitHub, etc.). The credential provisioning system bridges locally-encrypted credentials to GitLab's secret management without exposing plaintext values in prompts, logs, or metadata.

### How It Works

When you enable **Provision API credentials** during deploy:

1. **Resolve**: The app finds all connectors linked to the persona's tools (same logic as local execution in `engine/runner.rs`).
2. **Decrypt**: Each connector's credentials are decrypted from the local AES-256-GCM encrypted SQLite store.
3. **Push**: Each credential field is pushed to the GitLab project as a CI/CD variable via `POST /api/v4/projects/:id/variables`.
4. **Hint**: The system prompt includes env var **names only** (e.g. `OPENAI_API_KEY`) so the agent knows how to authenticate — values are never in the prompt.
5. **Audit**: Each provisioning is logged to the local credential audit trail.

### Env Var Naming Convention

Variables follow the same naming pattern as local execution:

```
{CONNECTOR_NAME_UPPER}_{FIELD_KEY_UPPER}
```

Examples:
| Connector | Field | GitLab CI/CD Variable |
|-----------|-------|-----------------------|
| openai | api_key | `OPENAI_API_KEY` |
| slack-bot | bot_token | `SLACK_BOT_BOT_TOKEN` |
| github | personal_access_token | `GITHUB_PERSONAL_ACCESS_TOKEN` |

### Security Model

| Layer | Protection |
|-------|-----------|
| **In transit** | HTTPS/TLS between app and GitLab API |
| **At rest (GitLab)** | Variables are created with `masked: true` — GitLab redacts them from job logs |
| **Branch protection** | Variables are created with `protected: true` — only available on protected branches |
| **Prompt isolation** | System prompt contains env var **names only**, never values |
| **Metadata isolation** | Agent metadata never includes credential values |
| **Local audit trail** | Every provisioning is recorded in the credential audit log with `operation: "gitlab_provision"` |
| **Revocation** | `gitlab_revoke_credentials` deletes variables from the project when undeploying |

### What Gets Sent to GitLab

```
POST /api/v4/projects/:id/variables
{
  "key": "OPENAI_API_KEY",
  "value": "sk-...",          <-- encrypted in transit via TLS
  "masked": true,             <-- GitLab redacts from logs
  "protected": true,          <-- only on protected branches
  "variable_type": "env_var"
}
```

### What Does NOT Get Sent

- Credential values are **never** included in the system prompt
- Credential values are **never** included in agent metadata
- Credential values are **never** included in AGENTS.md
- Credential values are **never** logged (locally or remotely)

### Revoking Credentials

Use the `gitlab_revoke_credentials` command to delete provisioned variables from a project:

```typescript
await gitlabRevokeCredentials(projectId, ["OPENAI_API_KEY", "SLACK_BOT_BOT_TOKEN"]);
```

This calls `DELETE /api/v4/projects/:id/variables/:key` for each variable. Variables that don't exist are silently skipped.

### GitLab Masking Limitations

GitLab's variable masking has a minimum length requirement (8 characters). If a credential value is shorter than 8 characters, the `masked: true` flag is still set but GitLab will not be able to redact it from logs. The `protected: true` flag provides defence in depth by limiting which branches can access the variable.

---

## PAT Security

- The PAT is stored in the OS keyring under service `"personas-desktop"`, key `"gitlab-token"`.
- It is **never** written to disk, logged, or included in error messages.
- On disconnect, the keyring entry is deleted.
- On app startup, if a stored token exists, the client is restored automatically (no re-authentication needed).

---

## Error Handling

Backend errors are translated into user-friendly messages in the frontend:

| Raw error | Displayed message |
|-----------|-------------------|
| `401 Unauthorized` | Invalid personal access token. Please check your token and try again. |
| `403 Forbidden` | Access denied. Your token may not have the required scopes (api, read_api). |
| Connection refused | Could not reach GitLab. Check your network connection. |
| Token empty | Please enter your GitLab personal access token. |
| Keyring failure | Could not access stored credentials. You may need to reconnect. |
| Not connected | Not connected to GitLab. Please connect first. |

---

## Limitations

- **gitlab.com only** — the base URL is hardcoded to `https://gitlab.com`. Self-managed instances are not yet supported.
- **Duo Agent API availability** — the API is part of GitLab Duo and may not be available on all tiers. The AGENTS.md fallback ensures deployment always works.
- **One agent per deploy** — each deploy creates a new agent (or overwrites AGENTS.md). There is no update-in-place for API-deployed agents yet.
- **No real-time sync** — changes to a persona after deployment are not automatically pushed. Re-deploy to update.
